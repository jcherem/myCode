#! /builds/nuke/11.3v6/8717ebaf34/priv/libnuke-11.3.6.so -nx
version 11.3 v6
define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="0" y="0" w="1920" h="1170" maximized="1" screen="1">
        <splitter orientation="2">
            <split size="1126"/>
            <dock id="" activePageId="Viewer.1">
                <page id="Viewer.1"/>
                <page id="com.dneg.NukeIvyPanel"/>
            </dock>
        </splitter>
    </window>
    <window x="1922" y="423" w="1424" h="826" screen="0">
        <splitter orientation="1">
            <split size="708"/>
            <dock id="" activePageId="DAG.1" focus="true">
                <page id="DAG.1"/>
                <page id="Curve Editor.1"/>
                <page id="DopeSheet.1"/>
                <page id="uk.co.thefoundry.scripteditor.1"/>
                <page id="com.dneg.NukeIvyPanel"/>
            </dock>
            <split size="708"/>
            <dock id="" activePageId="Properties.1">
                <page id="Properties.1"/>
                <page id="com.dneg.DNegTools"/>
            </dock>
            <split size="0"/>
            <dock id="" activePageId="uk.co.thefoundry.backgroundrenderview.1">
                <page id="uk.co.thefoundry.backgroundrenderview.1"/>
            </dock>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name "/u/pnef/Downloads/Dumb Tricks for Smart Compositing - Part Three.nk"
 frame 1017
 first_frame 1003
 last_frame 1079
 lock_range true
 format "1920 1080 0 0 1920 1080 1 Canon 5D mkIII HD"
 proxy_type scale
 proxy_format "640 480 0 0 640 480 1 "
 colorManagement Nuke
 workingSpaceLUT linear
 monitorLut sRGB
 int8Lut PaintSpace
 int16Lut PaintSpace
 logLut dnLog
 floatLut linear
 luts {linear {}
   sRGB {}
   rec709 {}
   Cineon {}
   Gamma1.8 {}
   Gamma2.2 {}
   Gamma2.4 {}
   Gamma2.6 {}
   Panalog {}
   REDLog {}
   ViperLog {}
   AlexaV3LogC {}
   PLogLin {}
   SLog {}
   SLog1 {}
   SLog2 {}
   SLog3 {}
   CLog {}
   Log3G10 {}
   Log3G12 {}
   HybridLogGamma {}
   Protune {}
   BT1886 {}
   HDR2084 {}
   st2084 {}
   REDSpace {}
   dnAlexaV3LogC {pow(10.0,(1023*x-394)*0.002/0.5064)*0.18-0.00947}
   dnLog {pow(10.0,(1023*x-445)*0.002/0.6)*0.18}
   PaintSpace {curve 0.005914787846 x0.0009779999964 0.006148717949 x0.001954999985 0.006391548691 x0.002932999982 0.006643134902 x0.00390999997 0.006903377326 x0.004887999967 0.007172181342 x0.005865000188 0.007449287601 x0.006843000185 0.007734549118 x0.007819999941 0.00802764524 x0.008798000403 0.008328446912 x0.009774999693 0.008636585798 x0.01075300016 0.008951836712 x0.01173000038 0.00927393338 x0.01270799991 0.009602641861 x0.01368500013 0.009937537758 x0.01466299966 0.01027862382 x0.01563999988 0.01062532497 x0.01661800034 0.01097759898 x0.01759500057 0.01133523144 x0.01857299916 0.01169789993 x0.01954999939 0.01206544382 x0.02052799985 0.01243760018 x0.02150500007 0.01281429128 x0.02248300053 0.01319513664 x0.02346000075 0.01357983496 x0.02443799935 0.01396774062 x0.02541499957 0.01435826888 x0.02639300004 0.01475114261 x0.02737000026 0.01514560659 x0.02834800072 0.01554158621 x0.02932599932 0.01593852991 x0.03030299954 0.01633611725 x0.03128099814 0.01673415941 x0.03225800022 0.01713234659 x0.03323600069 0.01753064607 x0.03421299905 0.01792877107 x0.03519099951 0.01832658189 x0.03616800159 0.01872410215 x0.03714599833 0.01912108455 x0.03812300041 0.01951743995 x0.03910100088 0.01991325347 x0.04007799923 0.02030816259 x0.0410559997 0.02070261147 x0.04203300178 0.02109610662 x0.04301099852 0.02148914923 x0.0439880006 0.02188092269 x0.04496600106 0.02227231764 x0.04594299942 0.02266288274 x0.04692099988 0.02305251227 x0.04789799824 0.02344147698 x0.04887599871 0.02382951931 x0.04985300079 0.0242169487 x0.05083100125 0.02460372146 x0.05180799961 0.02498960674 x0.05278600007 0.0253749685 x0.05376299843 0.02575939518 x0.05474099889 0.02614328165 x0.05571800098 0.02652643161 x0.05669600144 0.02690906897 x0.05767399818 0.02729122511 x0.05865100026 0.02767272401 x0.05962900072 0.02805338757 x0.06060599908 0.0284334823 x0.06158399954 0.02881329673 x0.0625609979 0.02919245381 x0.06353899837 0.02957079508 x0.06451600045 0.02994886594 x0.06549400091 0.03032629336 x0.066471003 0.03070293207 x0.06744900346 0.03107912347 x0.06842599809 0.03145473725 x0.06940399855 0.03182964184 x0.07038100064 0.03220395727 x0.0713590011 0.03257755838 x0.07233600318 0.03295057759 x0.07331400365 0.03332289631 x0.07429099828 0.03369465948 x0.07526899874 0.03406602272 x0.07624600083 0.03443634116 x0.07722400129 0.03480658553 x0.07820100337 0.03517556256 x0.07917899638 0.03554454357 x0.08015599847 0.03591288309 x0.08113399893 0.0362801966 x0.08211100101 0.03664723826 x0.08308900148 0.03701392424 x0.08406600356 0.03737987647 x0.08504399657 0.03774529742 x0.08602199703 0.03811010118 x0.08699899912 0.03847480539 x0.08797699958 0.03883842518 x0.08895400167 0.03920178764 x0.08993200213 0.03956451094 x0.09090899676 0.03992714176 x0.09188699722 0.04028929999 x0.09286399931 0.0406505936 x0.09384199977 0.04101158478 x0.09481900185 0.04137188338 x0.09579700232 0.04173207044 x0.09677399695 0.0420920882 x0.09775199741 0.0424515451 x0.0987289995 0.04281037398 x0.09970699996 0.04316918522 x0.100684002 0.04352724418 x0.1016620025 0.04388482711 x0.1026389971 0.0442422211 x0.1036169976 0.04459937388 x0.1045939997 0.04495587984 x0.1055720001 0.04531238918 x0.1065490022 0.04566849837 x0.1075270027 0.04602415374 x0.1085039973 0.04637966547 x0.1094819978 0.04673462064 x0.1104589999 0.04708970413 x0.1114370003 0.04744413268 x0.1124140024 0.04779822638 x0.1133920029 0.04815231615 0.04850636292 x0.115346998 0.04885994365 x0.1163249984 0.04921301037 x0.1173020005 0.04956590404 x0.118280001 0.04991858448 x0.1192570031 0.05027101127 x0.1202350035 0.05062354123 x0.1212119982 0.05097534125 x0.1221899986 0.05132716791 x0.1231670007 0.05167898815 x0.1241450012 0.05203036012 x0.1251219958 0.05238206459 x0.1261000037 0.05273324801 x0.1270769984 0.05308428495 x0.1280550063 0.05343472169 x0.1290320009 0.05378536024 x0.1300099939 0.05413574924 x0.1309870034 0.05448585393 x0.1319649965 0.05483650052 x0.132942006 0.05518637043 x0.133919999 0.05553629225 x0.1348969936 0.05588579995 x0.1358750015 0.05623529941 x0.1368519962 0.05658520737 x0.1378300041 0.05693461022 x0.1388069987 0.05728392161 x0.1397850066 0.05763266095 x0.1407620013 0.0579817023 x0.1417399943 0.05833102551 x0.1427170038 0.05868014952 x0.1436949968 0.05902858216 x0.1446730047 0.05937721882 x0.1456499994 0.05972603876 x0.1466280073 0.06007502107 x0.1476050019 0.06042319584 x0.1485829949 0.06077147982 x0.1495600045 0.06111985169 x0.1505379975 0.06146877267 x0.151515007 0.06181677325 x0.152493 0.06216479156 x0.1534699947 0.0625132966 x0.1544480026 0.06286178107 x0.1554249972 0.06320972658 x0.1564030051 0.06355810085 x0.1573799998 0.06390688977 x0.1583579928 0.06425507011 x0.1593350023 0.06460311837 x0.1603129953 0.06495203191 x0.1612900048 0.06530077894 x0.1622679979 0.06564933659 x0.1632450074 0.06599871833 x0.1642230004 0.06634787561 x0.165199995 0.06669678527 x0.166178003 0.06704647689 x0.1671549976 0.06739641437 x0.1681330055 0.06774605054 x0.1691100001 0.06809589649 x0.1700879931 0.06844701163 x0.1710650027 0.06879723622 x0.1720429957 0.06914816693 x0.1730210036 0.06949979631 x0.1739979982 0.06985101992 x0.1749760062 0.0702023648 x0.1759530008 0.07055492293 x0.1769309938 0.07090702458 x0.1779080033 0.07126032386 x0.1788859963 0.07161369656 x0.1798630059 0.07196712637 x0.1808409989 0.07232116472 x0.1818179935 0.07267580346 x0.1827960014 0.07303046094 x0.1837729961 0.07338569672 x0.184751004 0.07374150243 x0.1857279986 0.07409728781 x0.1867060065 0.07445420518 x0.1876830012 0.07481107954 x0.1886609942 0.07516848405 x0.1896380037 0.07552640999 x0.1906159967 0.07588484856 x0.1915930063 0.07624438958 x0.1925709993 0.07660382964 x0.1935479939 0.07696375559 x0.1945260018 0.07732415839 x0.1955029964 0.07768502892 x0.1964810044 0.07804697082 x0.197457999 0.07840936772 x0.1984360069 0.07877221032 x0.1994130015 0.07913548926 x0.2003909945 0.07949919513 x0.2013690025 0.07986394551 x0.2023459971 0.0802291095 x0.203324005 0.08059531031 x0.2043009996 0.08096191122 x0.2052789927 0.08132826393 x0.2062560022 0.08169627439 x0.2072339952 0.08206466137 x0.2082110047 0.08243341498 x0.2091889977 0.0828031754 x0.2101660073 0.08317328828 x0.2111440003 0.08354505548 x0.2121209949 0.0839158488 x0.2130990028 0.08428894961 x0.2140759975 0.084661715 x0.2150540054 0.08503546125 x0.216031 0.08541018681 x0.217008993 0.08578521652 x0.2179860026 0.08616121644 x0.2189639956 0.08653750541 x0.2199410051 0.08691543774 x0.2209189981 0.08729364976 x0.2218959928 0.08767213078 x0.2228740007 0.0880522528 x0.2238509953 0.08843263419 x0.2248290032 0.08881396146 x0.2258059978 0.08919553233 x0.2267840058 0.08957874254 x0.2277610004 0.0899621864 x0.2287389934 0.09034727159 x0.2297170013 0.09073186789 x0.230693996 0.09111810137 x0.2316720039 0.09150526051 x0.2326489985 0.09189334315 x0.2336270064 0.09228162251 x0.234604001 0.09267081485 x0.2355819941 0.09306164858 x0.2365590036 0.09345266308 x0.2375369966 0.09384458363 x0.2385140061 0.09423740788 x0.2394919991 0.09463187645 x0.2404689938 0.09502650395 x0.2414470017 0.09542202787 x0.2424239963 0.0958184457 x0.2434020042 0.09621575493 x0.2443789989 0.09661471159 x0.2453570068 0.09701379903 x0.2463340014 0.09741377012 x0.2473119944 0.09781462218 x0.248289004 0.09821712373 x0.249266997 0.09861973286 x0.2502439916 0.09902399234 x0.2512220144 0.09942912826 x0.2521989942 0.09983513781 x0.2531769872 0.1002420182 x0.2541539967 0.1006497665 x0.2551319897 0.1010591734 x0.2561089993 0.1014686522 x0.2570869923 0.1018797902 0.1022917908 x0.2590419948 0.1027046511 x0.2600199878 0.1031183682 x0.2609969974 0.1035337517 x0.2619749904 0.1039491762 x0.2629519999 0.1043670869 x0.2639299929 0.1047850323 x0.2649070024 0.1052038254 x0.2658849955 0.1056242922 x0.266862005 0.1060456069 x0.267839998 0.1064677661 x0.2688170075 0.1068916059 x0.2697950006 0.1073162903 x0.2707720101 0.1077418161 x0.2717500031 0.1081690291 x0.2727270126 0.1085970835 x0.2737050056 0.1090259756 x0.2746819854 0.1094557023 x0.2756600082 0.1098871227 x0.2766369879 0.1103193773 x0.2776150107 0.1107533323 x0.2785919905 0.1111881212 x0.2795700133 0.1116237405 x0.280546993 0.1120610666 x0.281524986 0.1124992227 x0.2825019956 0.1129382052 x0.2834799886 0.1133789007 x0.2844569981 0.1138213158 x0.2854349911 0.11426456 x0.2864130139 0.1147086297 x0.2873899937 0.115153521 x0.2883679867 0.1156001378 x0.2893449962 0.1160484868 x0.2903229892 0.1164976599 x0.2912999988 0.1169476534 x0.2922779918 0.117399385 x0.2932550013 0.1178528615 x0.2942329943 0.1183062318 x0.2952100039 0.1187622787 x0.2961879969 0.1192191474 x0.2971650064 0.119676834 x0.2981429994 0.1201362777 x0.2991200089 0.1205965383 x0.300098002 0.1210585623 x0.3010750115 0.1215223563 x0.3020530045 0.1219869693 x0.303030014 0.1224523973 x0.304008007 0.122919601 x0.3049849868 0.1233885873 x0.3059630096 0.1238583904 x0.3069399893 0.1243299823 x0.3079180121 0.1248023899 x0.3088949919 0.1252765924 x0.3098730147 0.1257516093 x0.3108499944 0.1262284274 x0.3118279874 0.1267070535 x0.312804997 0.1271864957 x0.31378299 0.1276677521 x0.3147610128 0.1281498233 x0.3157379925 0.1286347248 x0.3167159855 0.1291194334 x0.3176929951 0.1296069862 x0.3186709881 0.1300943369 x0.3196479976 0.1305845455 x0.3206259906 0.1310755721 x0.3216030002 0.131568445 x0.3225809932 0.1320631712 x0.3235580027 0.1325587169 x0.3245359957 0.1330561221 x0.3255130053 0.133554345 x0.3264909983 0.1340544335 x0.3274680078 0.1345563946 x0.3284460008 0.1350602352 x0.3294230103 0.135564898 x0.3304010034 0.1360714466 x0.3313780129 0.1365788155 x0.3323560059 0.1370891526 x0.3333329856 0.1376003162 x0.3343110085 0.1381123013 x0.3352879882 0.1386272799 x0.336266011 0.1391430862 x0.3372429907 0.1396597151 x0.3382210135 0.1401793629 x0.3391979933 0.1406998394 x0.3401759863 0.1412222484 x0.3411529958 0.1417465972 x0.3421309888 0.1422717756 x0.3431090117 0.1427988999 x0.3440859914 0.1433279772 x0.3450640142 0.1438578853 x0.3460409939 0.1443897524 x0.3470189869 0.144923586 x0.3479959965 0.1454593933 x0.3489739895 0.1459960352 x0.349950999 0.1465346569 x0.350928992 0.1470752657 x0.3519060016 0.1476178691 x0.3528839946 0.1481613109 x0.3538610041 0.1487067533 x0.3548389971 0.1492530318 x0.3558160067 0.1498024933 x0.3567939997 0.150352797 x0.3577710092 0.1509051223 x0.3587490022 0.1514582874 x0.3597260118 0.1520146738 x0.3607040048 0.152571906 x0.3616810143 0.1531311809 x0.3626590073 0.1536912992 x0.363635987 0.1542534662 x0.3646140099 0.1548176895 x0.3655909896 0.1553839766 x0.3665690124 0.1559511105 x0.3675459921 0.1565215434 x0.3685239851 0.1570928294 x0.3695009947 0.1576649625 x0.3704789877 0.1582404218 x0.3714570105 0.1588167344 x0.3724339902 0.159395146 x0.3734120131 0.159974408 x0.3743889928 0.1605570359 x0.3753669858 0.1611405204 x0.3763439953 0.1617261253 x0.3773219883 0.162312584 x0.3782989979 0.1629024484 x0.3792769909 0.1634931727 x0.3802540004 0.1640860392 x0.3812319934 0.1646797624 x0.382209003 0.1652769317 x0.383186996 0.1658749641 x0.3841640055 0.1664751603 x0.3851419985 0.1670762164 x0.3861190081 0.1676807592 x0.3870970011 0.1682861682 x0.3880740106 0.1688937629 x0.3890520036 0.1695022205 x0.3900290132 0.1701142057 x0.3910070062 0.1707270601 x0.3919839859 0.1713421222 x0.3929620087 0.1719580501 x0.3939389884 0.172577547 x0.3949170113 0.1731979159 x0.395893991 0.1738205148 x0.3968720138 0.1744453517 x0.3978489935 0.1750710602 x0.3988269866 0.175699013 x0.3998039961 0.1763292181 x0.4007819891 0.1769616837 x0.4017600119 0.1775950234 x0.4027369916 0.1782320293 x0.4037150145 0.1788699155 x0.4046919942 0.1795100847 x0.4056699872 0.1801511305 x0.4066469967 0.1807958851 x0.4076249897 0.1814415226 x0.4086019993 0.1820894658 x0.4095799923 0.182738288 x0.4105570018 0.183390862 x0.4115349948 0.1840443213 x0.4125120044 0.184700109 x0.4134899974 0.1853582334 x0.4144670069 0.1860172423 x0.4154449999 0.18668006 x0.4164220095 0.1873437684 x0.4174000025 0.1880098365 x0.418377012 0.1886767913 x0.419355005 0.1893475987 x0.4203320146 0.1900192991 x0.4213100076 0.1906933823 x0.4222869873 0.1913698567 x0.4232650101 0.1920472231 x0.4242419899 0.1927285002 x0.4252200127 0.1934106755 x0.4261969924 0.1940952654 x0.4271749854 0.1947807491 x0.4281519949 0.1954701885 x0.429129988 0.196160528 x0.4301080108 0.1968533055 x0.4310849905 0.1975485297 x0.4320630133 0.1982446527 x0.433039993 0.1989447907 x0.4340179861 0.1996458338 x0.4349949956 0.2003493472 x0.4359729886 0.2010553397 x0.4369499981 0.2017622358 x0.4379279912 0.202473207 x0.4389050007 0.2031850882 x0.4398829937 0.2038994723 x0.4408600032 0.2046163681 x0.4418379962 0.2053341722 x0.4428150058 0.2060544944 x0.4437929988 0.2067789672 x0.4447700083 0.2075027285 x0.4457480013 0.2082306581 x0.4467250109 0.2089611414 x0.4477030039 0.2096925407 x0.4486800134 0.2104265 x0.4496580064 0.2111630284 x0.4506349862 0.2119021347 x0.451613009 0.2126421583 x0.4525899887 0.2133847664 x0.4535680115 0.2141316492 x0.4545449913 0.2148794589 x0.4555230141 0.2156281872 x0.4564999938 0.2163812233 x0.4574779868 0.2171351844 x0.4584560096 0.2178917725 x0.4594329894 0.2186509969 x0.4604110122 0.2194128668 x0.4613879919 0.2201756625 x0.4623660147 0.2209428449 x0.4633429945 0.2217109597 x0.4643209875 0.2224817448 x0.465297997 0.2232552096 x0.46627599 0.2240296043 x0.4672529995 0.2248084503 x0.4682309926 0.2255882326 x0.4692080021 0.2263707198 x0.4701859951 0.2271559211 x0.4711630046 0.2279420563 x0.4721409976 0.228732708 x0.4731180072 0.2295243001 x0.4740960002 0.2303186317 x0.4750730097 0.2311157123 x0.4760510027 0.2319155514 x0.4770280123 0.2327163313 x0.4780060053 0.2335217098 x0.4789830148 0.2343280356 x0.4799610078 0.2351371455 x0.4809379876 0.2359490493 x0.4819160104 0.2367618974 x0.4828929901 0.2375794113 x0.4838710129 0.238397876 x0.4848479927 0.2392191604 x0.4858259857 0.2400432741 x0.4868040085 0.2408702269 x0.4877809882 0.2416981308 x0.488759011 0.2425307846 x0.4897359908 0.2433643961 x0.4907140136 0.2442008728 x0.4916909933 0.2450402245 x0.4926689863 0.2458805307 x0.4936459959 0.2467256557 x0.4946239889 0.2475717416 x0.4956009984 0.2484207289 x0.4965789914 0.2492726277 x0.4975560009 0.2501274478 x0.498533994 0.2509851993 x0.4995110035 0.2518439149 x0.5004889965 0.2527055684 x0.5014659762 0.25357017 x0.5024440289 0.2544377297 x0.5034210086 0.2553082576 x0.5043990016 0.256181764 x0.5053759813 0.2570562406 x0.5063539743 0.2579357275 x0.5073310137 0.2588161912 x0.5083090067 0.2596996604 x0.5092859864 0.2605840993 x0.5102639794 0.2614736033 x0.5112410188 0.2623640835 x0.5122190118 0.2632596635 x0.5131959915 0.2641562263 x0.5141739845 0.2650558426 0.2659585226 x0.5161290169 0.2668621814 x0.5171070099 0.2677710131 x0.5180839896 0.2686808303 x0.5190619826 0.2695937389 x0.520039022 0.2705097492 x0.521017015 0.2714288719 x0.5219939947 0.2723511176 x0.5229719877 0.2732743511 x0.5239490271 0.2742007143 x0.5249270201 0.275132378 x0.5259039998 0.2760650396 x0.5268819928 0.2769986878 x0.5278589725 0.277937676 x0.5288370252 0.2788798472 x0.5298140049 0.2798230151 x0.5307919979 0.2807693728 x0.5317689776 0.281718931 x0.5327469707 0.2826717006 x0.53372401 0.2836276925 x0.534702003 0.2845869176 x0.5356789827 0.2855471447 x0.5366569757 0.2865128613 x0.5376340151 0.2874795867 x0.5386120081 0.2884495739 x0.5395889878 0.289422834 x0.5405669808 0.2903970978 x0.5415440202 0.2913769291 x0.5425220132 0.2923577708 0.2933442176 x0.5444769859 0.2943316817 x0.5454549789 0.2953224698 x0.5464320183 0.2963165931 x0.5474100113 0.2973117285 x0.548386991 0.2983125481 x0.549364984 0.2993143866 x0.5503420234 0.3003195896 x0.5513200164 0.3013305344 x0.5522969961 0.3023425083 x0.5532749891 0.3033578808 x0.5542520285 0.3043742734 x0.5552300215 0.3053964692 x0.5562070012 0.306419692 x0.5571849942 0.3074487572 x0.558161974 0.3084788561 x0.5591400266 0.3095124064 x0.5601170063 0.3105494195 x0.5610949993 0.3115899071 x0.562071979 0.3126338809 x0.5630499721 0.3136813524 x0.5640270114 0.3147323335 x0.5650050044 0.3157843564 x0.5659819841 0.3168423836 x0.5669599771 0.3179014595 x0.5679370165 0.3189665799 x0.5689150095 0.3200327562 x0.5698919892 0.3211024962 x0.5708699822 0.322175812 0.3232527154 x0.5728250146 0.3243332185 x0.5738030076 0.3254198884 x0.5747799873 0.3265050718 x0.5757579803 0.3275964461 x0.5767350197 0.3286914686 x0.5777130127 0.3297901512 x0.5786899924 0.3308925063 x0.5796679854 0.3319985461 x0.5806450248 0.3331056674 x0.5816230178 0.3342191049 x0.5825999975 0.3353362642 x0.5835779905 0.3364545159 x0.5845549703 0.3375791472 x0.5855330229 0.3387075378 x0.5865100026 0.3398370317 x0.5874879956 0.3409729695 x0.5884649754 0.3421127042 x0.589443028 0.3432562486 x0.5904200077 0.3444009112 x0.5913980007 0.3455521041 x0.5923749804 0.346707145 x0.5933529735 0.3478660467 x0.5943300128 0.3490260817 x0.5953080058 0.3501927347 x0.5962849855 0.3513632874 x0.5972629786 0.3525377527 x0.5982400179 0.3537161439 x0.5992180109 0.3548984738 0.3560847559 x0.6011729836 0.3572750032 x0.6021509767 0.358469229 x0.603128016 0.3596702707 x0.604106009 0.3608725029 x0.6050829887 0.3620787537 x0.6060609818 0.363291889 x0.6070380211 0.3645062269 x0.6080160141 0.3657274953 x0.6089929938 0.3669528557 x0.6099709868 0.3681794306 x0.6109480262 0.3694130061 x0.6119260192 0.3706507146 x0.6129029989 0.37189257 x0.6138809919 0.3731415161 x0.6148579717 0.3743917169 x0.6158360243 0.3756461065 x0.616813004 0.3769076582 x0.617790997 0.3781734467 x0.6187679768 0.3794434862 x0.6197460294 0.3807177909 x0.6207230091 0.3819963751 x0.6217010021 0.3832792533 x0.6226779819 0.3845664399 x0.6236559749 0.3858609789 x0.6246330142 0.3871568358 x0.6256110072 0.3884600948 x0.6265879869 0.3897677408 x0.62756598 0.3910797886 x0.6285430193 0.3923993342 x0.6295210123 0.3937202405 0.3950486953 x0.6314759851 0.3963816323 x0.6324539781 0.3977190668 x0.6334310174 0.399061014 x0.6344090104 0.400410633 x0.6353859901 0.4017616618 x0.6363639832 0.4031204144 x0.6373410225 0.4044837622 x0.6383190155 0.4058517209 x0.6392959952 0.4072275034 x0.6402739882 0.4086079496 x0.6412510276 0.4099930754 x0.6422290206 0.4113828966 x0.6432060003 0.4127774291 x0.6441839933 0.4141799409 x0.6451609731 0.415587218 x0.6461390257 0.4169992768 x0.6471160054 0.4184161333 x0.6480939984 0.4198411005 x0.6490709782 0.4212709206 x0.6500489712 0.4227056101 x0.6510260105 0.4241485159 x0.6520040035 0.4255930054 x0.6529809833 0.4270457674 x0.6539589763 0.4285034884 x0.6549360156 0.4299695613 x0.6559140086 0.4314406502 x0.6568909883 0.4329167723 x0.6578689814 0.4344013555 0.4358910298 x0.6598240137 0.4373858126 x0.6608020067 0.4388857213 x0.6617789865 0.4403942315 x0.6627569795 0.4419079267 x0.6637340188 0.4434303064 x0.6647120118 0.4449544369 x0.6656889915 0.4464873119 x0.6666669846 0.4480289854 x0.6676440239 0.4495759822 x0.6686220169 0.4511283206 x0.6695989966 0.4526860191 x0.6705769897 0.4542562295 x0.671554029 0.4558283074 x0.672532022 0.4574094173 x0.6735090017 0.4589924076 x0.6744869947 0.4605881092 x0.6754639745 0.4621893582 x0.6764420271 0.4637961741 x0.6774190068 0.4654122304 x0.6783969998 0.4670339177 x0.6793739796 0.4686649355 x0.6803519726 0.4703016493 x0.6813290119 0.471944079 x0.6823070049 0.473595963 x0.6832839847 0.475253629 x0.6842619777 0.4769208417 x0.685239017 0.4785939031 x0.68621701 0.4802766047 0.4819652226 x0.6881719828 0.4836635751 x0.6891499758 0.4853679124 x0.6901270151 0.4870820798 x0.6911050081 0.4888023011 x0.6920819879 0.4905285978 x0.6930599809 0.4922648563 x0.6940370202 0.4940111393 x0.6950150132 0.4957636171 x0.695991993 0.4975262182 x0.696969986 0.499295086 x0.6979470253 0.5010741769 x0.6989250183 0.5028596072 x0.699901998 0.5046553617 x0.7008799911 0.5064615057 x0.7018569708 0.5082741137 x0.7028350234 0.5100932091 x0.7038120031 0.5119228344 x0.7047899961 0.5137630563 x0.7057669759 0.5156139417 x0.7067450285 0.5174714952 x0.7077220082 0.5193357407 x0.7087000012 0.5212148872 x0.709676981 0.5230967259 x0.710654974 0.5249936032 x0.7116320133 0.526897359 x0.7126100063 0.5288121705 x0.7135869861 0.5307339406 x0.7145649791 0.5326710594 0.5346110509 x0.7165200114 0.5365665338 x0.7174980044 0.5385291694 x0.7184749842 0.5405032277 x0.7194529772 0.5424887818 x0.7204300165 0.5444816299 x0.7214080095 0.5464903805 x0.7223849893 0.5485022353 x0.7233629823 0.5505301418 x0.7243400216 0.5525655458 x0.7253180146 0.5546171844 x0.7262949944 0.5566720698 x0.7272729874 0.5587433429 x0.7282500267 0.5608267262 x0.7292280197 0.5629178779 x0.7302049994 0.5650212632 x0.7311829925 0.5671414142 x0.7321599722 0.5692650508 x0.7331380248 0.5714056124 x0.7341150045 0.573554223 x0.7350929976 0.5757199537 x0.7360699773 0.5778938621 x0.7370479703 0.5800850885 x0.7380250096 0.5822846235 x0.7390030026 0.5844970879 x0.7399799824 0.5867225657 x0.7409579754 0.5889611414 x0.7419350147 0.5912129002 x0.7429130077 0.593477928 0.5957563112 x0.7448679805 0.5980481369 x0.7458459735 0.6003534929 x0.7468230128 0.6026724677 x0.7478010058 0.6050051503 x0.7487779856 0.6073516305 x0.7497559786 0.6097119988 x0.7507330179 0.6120863461 x0.7517110109 0.6144747644 x0.7526879907 0.6168821898 x0.7536659837 0.6192990471 x0.754643023 0.6217351367 x0.755621016 0.624180809 x0.7565979958 0.6266508625 x0.7575759888 0.6291257509 x0.7585530281 0.6316252916 x0.7595310211 0.6341347631 x0.7605080009 0.6366692017 x0.7614859939 0.6392087507 x0.7624629736 0.6417735465 x0.7634410262 0.6443486334 x0.7644180059 0.6469442121 x0.765395999 0.6495553464 x0.7663729787 0.6521872613 x0.7673509717 0.6548349819 x0.768328011 0.6574986141 x0.769306004 0.6601834483 x0.7702829838 0.6628844505 x0.7712609768 0.6656017295 x0.7722390294 0.6683406424 x0.7732160091 0.6710960951 x0.7741940022 0.673868199 x0.7751709819 0.6766676928 x0.7761489749 0.6794788167 x0.7771260142 0.6823176911 x0.7781040072 0.6851684263 x0.779080987 0.6880472791 x0.78005898 0.6909382279 x0.7810360193 0.6938522194 x0.7820140123 0.6967894425 x0.7829909921 0.6997445937 x0.7839689851 0.7027233133 x0.7849460244 0.705720254 x0.7859240174 0.7087466706 x0.7869009972 0.7117860657 x0.7878789902 0.7148553335 x0.7888560295 0.7179434733 x0.7898340225 0.7210506153 x0.7908110023 0.7241882628 x0.7917889953 0.7273395638 x0.792765975 0.7305217852 x0.7937440276 0.7337236904 x0.7947210073 0.7369569888 x0.7956990004 0.7402045354 x0.7966759801 0.7434839058 x0.7976539731 0.7467895322 x0.7986310124 0.7501098558 x0.7996090055 0.7534686061 0.7568423957 x0.8015639782 0.7602491999 x0.8025419712 0.7636833318 x0.8035190105 0.7671389995 x0.8044970036 0.7706284563 x0.8054739833 0.7741337855 x0.8064519763 0.7776794837 x0.8074290156 0.7812475561 x0.8084070086 0.7848443239 x0.8093839884 0.7884700327 x0.8103619814 0.79212493 x0.8113390207 0.7958092664 x0.8123170137 0.7995232947 x0.8132939935 0.8032672705 x0.8142719865 0.8070477885 x0.8152490258 0.8108524659 x0.8162270188 0.81469427 x0.8172039986 0.8185607036 x0.8181819916 0.8224648602 x0.8191589713 0.8264006151 x0.8201370239 0.8303682436 x0.8211140037 0.8343745749 x0.8220919967 0.8384134018 x0.8230689764 0.8424850088 x0.824047029 0.8465896833 x0.8250240088 0.8507343954 x0.8260020018 0.8549128241 x0.8269789815 0.8591320125 x0.8279569745 0.8633855817 x0.8289350271 0.8676738358 x0.8299120069 0.8720039291 x0.8308899999 0.8763693935 x0.8318669796 0.8807774594 x0.8328449726 0.8852285492 x0.8338220119 0.8897161047 x0.834800005 0.894240452 x0.8357769847 0.8988160352 x0.8367549777 0.9034221239 x0.837732017 0.9080803369 x0.8387100101 0.9127840693 x0.8396869898 0.9175265747 x0.8406649828 0.9223154459 x0.8416420221 0.9271511509 x0.8426200151 0.9320341638 x0.8435969949 0.9369576076 x0.8445749879 0.9419366424 x0.8455520272 0.946964442 x0.8465300202 0.9520340288 x0.847507 0.9571608171 x0.848484993 0.9623378816 x0.8494619727 0.9675657389 x0.8504400253 0.9728449118 x0.8514170051 0.9781836101 x0.8523949981 0.9835747741 x0.8533719778 0.9890111818 x0.8543499708 0.9945166806 x0.8553270102 1.000076384 x0.8563050032 1.005690857 1.011368614 x0.8582599759 1.017110369 x0.8592380285 1.022908816 x0.8602150083 1.028764553 x0.8611930013 1.034694431 x0.862169981 1.040683004 x0.863147974 1.046739111 x0.8641250134 1.052863528 x0.8651030064 1.059057041 x0.8660799861 1.065320445 x0.8670579791 1.071654549 x0.8680350184 1.078060172 x0.8690130115 1.084538146 x0.8699899912 1.09109788 x0.8709679842 1.097731766 x0.8719450235 1.104449344 x0.8729230165 1.111242932 x0.8738999963 1.118113424 x0.8748779893 1.125070563 x0.8758550286 1.132124325 x0.8768330216 1.139249146 x0.8778100014 1.146472816 x0.8787879944 1.153778526 x0.8797649741 1.161185494 x0.8807430267 1.168685893 x0.8817200065 1.176280918 x0.8826979995 1.183981078 x0.8836749792 1.191778432 x0.8846529722 1.199674235 x0.8856300116 1.207679243 x0.8866080046 1.215794941 1.22402284 x0.8885629773 1.232364478 x0.8895409703 1.240831162 x0.8905180097 1.249405064 x0.8914960027 1.258107356 x0.8924729824 1.266929947 x0.8934509754 1.27588453 x0.8944280148 1.284973028 x0.8954060078 1.294187235 x0.8963829875 1.303549393 x0.8973609805 1.313061754 x0.8983380198 1.322716228 x0.8993160129 1.332525387 x0.9002929926 1.342481074 x0.9012709856 1.352606723 x0.9022480249 1.362894352 x0.903226018 1.37334649 x0.9042029977 1.383976583 x0.9051809907 1.394787517 x0.9061579704 1.405782238 x0.907136023 1.416963756 x0.9081130028 1.428346358 x0.9090909958 1.439933454 x0.9100679755 1.451717131 x0.9110460281 1.463735149 x0.9120230079 1.475980133 x0.9130010009 1.488444418 x0.9139779806 1.501155396 x0.9149559736 1.514105691 x0.9159340262 1.527311605 x0.916911006 1.540765771 x0.917888999 1.55449712 x0.9188659787 1.568523254 x0.9198439717 1.582825075 x0.9208210111 1.597445432 x0.9217990041 1.612352747 x0.9227759838 1.627590858 x0.9237539768 1.643153597 x0.9247310162 1.659086585 x0.9257090092 1.675358224 x0.9266859889 1.691988714 x0.9276639819 1.70903923 x0.9286410213 1.72647845 x0.9296190143 1.744314744 x0.930595994 1.762612078 x0.931573987 1.781353091 x0.9325510263 1.800547827 x0.9335290194 1.82027809 x0.9345059991 1.840484659 x0.9354839921 1.861251633 x0.9364609718 1.882548535 x0.9374390244 1.904462922 x0.9384160042 1.926965245 x0.9393939972 1.95013152 x0.9403709769 1.973948245 x0.9413490295 1.998495164 x0.9423260093 2.023776328 x0.9433040023 2.049827908 2.076720269 x0.945258975 2.104477621 x0.9462370276 2.133125128 x0.9472140074 2.162739896 x0.9481920004 2.193402943 x0.9491689801 2.225129604 x0.9501469731 2.258006521 x0.9511240125 2.292088973 x0.9521020055 2.327453279 x0.9530789852 2.364179851 x0.9540569782 2.402391219 x0.9550340176 2.44214042 x0.9560120106 2.483541616 x0.9569889903 2.526755454 x0.9579669833 2.571872009 x0.9589440227 2.619007136 x0.9599220157 2.668346667 x0.9608989954 2.720067627 x0.9618769884 2.774337306 x0.9628540277 2.831334375 x0.9638320208 2.891363417 x0.9648090005 2.954590056 x0.9657869935 3.021309886 x0.9667639732 3.091841782 x0.9677420259 3.166480674 x0.9687190056 3.245621576 x0.9696969986 3.329745739 x0.9706739783 3.419351062 x0.9716519713 3.514981323 x0.972630024 3.617373825 x0.9736070037 3.727370312 x0.9745849967 3.845781197 x0.9755619764 3.973752936 x0.976540029 4.112468285 x0.9775170088 4.263384106 x0.9784950018 4.42810532 x0.9794719815 4.608553269 x0.9804499745 4.806797778 x0.9814270139 5.025314793 x0.9824050069 5.266527809 x0.9833819866 5.533117231 x0.9843599796 5.827368228 x0.985337019 6.15116153 x0.986315012 6.505448629 x0.9872919917 6.889655899 x0.9882699847 7.302572238 x0.9892470241 7.74491689 x0.9902250171 8.218701016 x0.9912019968 8.726057527 x0.9921799898 9.269245436 x0.9931570292 9.850653928 x0.9941350222 10.47264162 x0.9951120019 11.13783736 x0.9960899949 11.84872641 x0.9970669746 12.60795853 x0.9980450273 13.41836842 x0.999022007 14.2825516 x1 15.20334573}
   PaintSpaceHDR {curve L 2.536922693e-06 x0.0009775169892 0.0001260009594 x0.00195503002 0.0002526436001 0.0003822809085 0.0005152537487 0.0006513739936 0.0007907780819 0.0009271888994 x0.007820109837 0.001066958532 x0.008797620423 0.001209876966 0.00135630928 0.001506046858 0.0016594599 0.001809746958 0.001961833332 0.002117156051 0.002276110463 x0.01661779918 0.002438447438 x0.01759530045 0.002604572568 x0.01857279986 0.002772052307 0.002935521305 x0.02052789927 0.003102164716 x0.02150540054 0.0032725567 x0.02248289995 0.003446277231 0.003623910248 x0.02443790063 0.003805009648 x0.02541540004 0.003987399861 x0.02639300004 0.004163960926 x0.02737049945 0.004344150424 x0.02834800072 0.00452769734 x0.02932550013 0.004714849405 0.00490587391 0.005100473762 0.005298715085 x0.03323559836 0.005490805022 x0.03421309963 0.005683072843 0.005878553726 0.006077907048 x0.03714570031 0.006280608475 x0.03812320158 0.00648732949 0.006697552279 0.006911481731 x0.04105570167 0.007117755711 0.007323319092 0.007532132789 0.007744697854 x0.0449657999 0.007960650139 x0.04594330117 0.008180361241 0.008403704502 0.00863107387 x0.04887590185 0.008860208094 x0.0498533994 0.009078405797 0.009299650788 0.009524737485 x0.05278589949 0.00975301303 x0.05376340076 0.009985101409 0.01022061054 0.01046005916 x0.05669600144 0.01070306357 x0.05767349899 0.01094910782 0.0111857811 0.01142064575 x0.06060609967 0.01165925805 x0.06158360094 0.01190095488 0.01214653719 0.01239531953 0.01264808234 0.0129041383 x0.06647119671 0.01316421013 0.01342690084 0.0136810476 0.01393179316 0.01418580394 0.01444299798 0.01470386889 0.01496800687 x0.0742912963 0.01523592975 x0.07526879758 0.01550738048 0.01578254625 0.01606122777 0.01634218544 0.01661243662 0.01688034087 0.01715117693 x0.08211140335 0.01742563024 0.01770343259 0.01798472926 0.01826924086 0.01855728403 0.01884914562 0.01914438978 0.01944357902 x0.0899315998 0.01974307746 x0.09090910107 0.02003005147 0.0203166306 0.02060667425 0.0208998099 0.02119653672 0.02149641886 0.02179999277 x0.09775169939 0.02210679278 x0.09872920066 0.02241735533 0.02273121104 0.0230489783 0.02337002754 0.02368909121 0.02399338409 0.02430014312 x0.1055720001 0.02461019903 x0.1065490022 0.02492379397 0.02524021268 0.02556047961 0.02588387579 0.02621071413 0.02654099092 0.0268750526 x0.1133920029 0.02721234038 x0.1143700033 0.02755300701 0.02789689973 0.02823447809 0.02856086195 0.02888944745 0.02922131866 0.02955645323 x0.1212119982 0.02989517152 x0.1221899986 0.03023689613 0.03058196604 0.0309304297 0.03128255904 0.03163762018 0.03199668229 0.0323590301 0.0327251181 0.03309229389 0.03345308825 0.03380332887 x0.132942006 0.03415552154 x0.133919999 0.03451101854 0.03486974165 0.03523171693 0.0355969891 0.03596557304 0.0363375023 0.0367128104 0.03709152341 0.03747367486 0.03785929829 0.03824838996 0.03864071891 0.03903544694 0.03942383081 0.03979982063 x0.1485829949 0.04017706215 x0.1495600045 0.04055791721 0.04094206542 0.04132936895 0.04171965644 0.04211348295 0.04251041636 0.0429112725 0.04331491143 0.04372218624 0.04413263872 0.04454683512 0.04496461526 0.04538591579 0.04580973834 0.04622767866 x0.1642230004 0.04662862793 x0.165199995 0.04702596739 0.04742604867 0.04782917723 0.04823510349 0.04864437133 0.04905661196 0.04947263375 0.04989119619 0.05031289905 0.05073813722 0.05116647482 0.05159872398 0.05203367397 0.05247215182 0.05291381478 x0.1798630059 0.0533596687 x0.1808409989 0.05380669609 0.05424026772 0.05464876816 0.0550487563 0.05544993654 0.05585402995 0.05626071244 0.05667070672 0.05708282068 0.05749785155 0.05791549012 0.05833654478 0.05875981227 0.05918604508 0.05961497501 x0.1955029964 0.06004741415 x0.1964810044 0.06048208103 0.06091985479 0.06136038527 0.06180447713 0.06225091591 0.06269986928 0.06314826757 0.06358737499 0.06400556862 0.06441851705 0.06483432651 0.0652525872 0.06567353755 0.06609680504 0.06652281433 x0.2111440003 0.06695117056 x0.2121209949 0.067382209 0.06781520694 0.06825145334 0.06869015843 0.06913170218 0.06957569718 0.07002253085 0.07047178596 0.07092347741 0.07137810439 0.0718357563 0.07229594886 0.0727590993 0.07322488725 0.07369171083 x0.2267840058 0.07415122539 x0.2277610004 0.07460078597 0.07504096627 0.07548125088 0.07592441887 0.07637026906 0.07681833953 0.07726852596 0.07772156596 0.07817737013 0.07863534242 0.07909572124 0.07955923676 0.08002466708 0.08049282432 0.08096390218 x0.2424239963 0.08143722266 x0.2434020042 0.08191301674 0.08239205927 0.08287309855 0.08335682005 0.08384317905 0.08433284611 0.08482455462 0.08531866968 0.08581421524 0.08630876988 0.08679466695 0.08727943897 0.08775585145 0.08823477477 0.08871625364 0.08920024335 0.08968703449 0.09017632157 0.09066814929 0.09116240591 0.09165894985 0.09215810895 0.09266003966 x0.2658849955 0.09316459298 x0.266862005 0.09367185086 0.09418173879 0.09469426423 0.09520931542 0.09572675824 0.09624689817 0.09676998854 0.09729576111 0.0978243798 0.09835572541 0.09888981283 0.09942628443 0.09996470809 0.10050302 0.1010366082 0.1015692949 0.1020955294 0.1026242375 0.103155233 0.1036888212 0.1042249352 0.1047637612 0.1053053141 0.1058494747 0.1063963771 0.1069459766 0.1074982285 0.108053267 0.1086110175 0.1091715097 0.1097347736 x0.2971650064 0.1103008538 x0.2981429994 0.1108696833 0.1114413291 0.1120157912 0.1125931069 0.1131732613 0.1137562618 0.1143421456 0.1149310842 0.1155231521 0.1161175296 0.1167134345 0.1173096374 0.1179028079 0.1184967086 0.1190884784 0.1196830571 0.1202804372 0.1208807901 0.1214841679 0.122090511 0.1226997152 0.1233119443 0.1239273921 0.1245457307 0.1251668632 0.1257909536 0.1264178306 0.1270477772 0.1276807636 0.1283166707 0.1289557368 x0.3284460008 0.1295978129 x0.3294230103 0.1302429289 0.1308913976 0.1315434873 0.1321984082 0.132856071 0.1335168034 0.1341808289 0.1348478347 0.1355178654 0.1361895651 0.1368615031 0.1375352442 0.1382092834 0.1388861835 0.1395656765 0.1402483284 0.1409344077 0.1416236758 0.1423164606 0.143012464 0.1437115222 0.1444141269 0.1451203376 0.1458296925 0.1465420574 0.1472578198 0.1479772627 0.1486999393 0.1494258493 0.15015544 0.1508888006 x0.3597260118 0.1516254842 x0.3607040048 0.1523652077 0.1531084478 0.1538551748 0.1546055824 0.155359745 0.1561175138 0.1568790376 0.1576438099 0.1584115177 0.1591823846 0.1599559337 0.1607331634 0.1615139246 0.162298426 0.1630868316 0.1638787687 0.1646743566 0.1654737294 0.166277051 0.1670840234 0.1678946614 0.168709293 0.1695282161 0.1703506559 0.1711762697 0.1720062941 0.1728407443 0.1736787856 0.1745200902 0.1753658056 0.1762161106 x0.3910070062 0.1770699918 x0.3919839859 0.1779273748 0.1787890345 0.1796555519 0.1805259138 0.1814000905 0.1822785139 0.1831613481 0.1840485036 0.1849401146 0.1858368069 0.1867389232 0.1876454055 0.1885562241 0.189471066 0.1903899759 0.1913132966 0.1922410131 0.1931733936 0.1941102743 0.1950516701 0.1959974617 0.1969477534 0.1979026198 0.1988615394 0.1998243779 0.2007921338 0.2017650455 0.2027427405 0.2037248909 0.20471178 0.2057033032 x0.4222869873 0.2066990733 x0.4232650101 0.2076989263 0.2087038308 0.2097142786 0.2107294351 0.2117494047 0.2127740085 0.2138031423 0.2148380429 0.2158792168 0.2169253826 0.217976734 0.2190327644 0.2200934142 0.2211592793 0.2222301364 0.2233062983 0.224387899 0.2254745364 0.2265664488 0.2276629806 0.2287638783 0.2298706323 0.2309833765 0.2321012616 0.2332245111 0.2343527526 0.2354859263 0.2366246283 0.2377687693 0.2389185429 0.2400740981 x0.4535680115 0.2412347645 x0.4545449913 0.2424005419 0.2435720116 0.2447490543 0.2459320724 0.2471211255 0.2483161986 0.2495172322 0.2507252097 0.251940459 0.2531610727 0.2543870509 0.255618751 0.2568562627 0.258100152 0.2593502998 0.2606061399 0.2618674636 0.2631346881 0.2644078732 0.2656876445 0.2669738531 0.2682658732 0.2695634067 0.2708673477 0.272177279 0.2734938562 0.2748172581 0.2761464715 0.2774815857 0.2788229883 0.2801707387 x0.4848479927 0.281525135 x0.4858259857 0.2828862667 0.2842535675 0.2856270969 0.2870083153 0.2883970737 0.2897928357 0.2911955416 0.2926053703 0.2940221429 0.2954456508 0.2968758643 0.2983130515 0.2997570336 0.3012078106 0.3026655614 0.3041303158 0.3056018651 0.3070805073 0.3085662723 0.3100590408 0.3115588129 0.3130657971 0.3145800829 0.3161012828 0.3176295459 0.3191652 0.320707947 0.3222582638 0.3238160014 0.3253811896 0.3269537985 0.3285343945 0.3301228285 0.3317189515 0.3333225846 0.3349360526 0.336559087 0.3381899595 0.3398284912 0.3414753675 0.3431304991 0.3447936475 0.3464647233 0.3481435776 0.3498305678 0.3515256047 0.353228718 x0.5317689776 0.3549399972 x0.5327469707 0.3566594124 0.3583871126 0.3601230085 0.3618670404 0.3636189103 0.3653793633 0.3671479821 0.368925482 0.370711416 0.3725058734 0.3743089139 0.3761205971 0.3779408932 0.3797696829 0.3816072643 0.383456707 0.3853175938 0.3871874809 0.3890662193 0.3909576237 0.3928611279 0.3947738409 0.3966958523 0.3986268044 0.4005672336 0.4025169611 0.4044759572 0.4064448476 0.408423394 0.4104115069 0.4124091268 0.4144160151 0.4164323211 0.4184583426 0.4204939306 0.42253986 0.4245955646 0.4266611934 0.4287366867 0.4308218956 0.4329165518 0.4350214303 0.4371364713 0.4392626286 0.4413999021 0.4435472488 0.4457050264 0.4478797615 0.4500699937 0.4522706568 0.4544820786 0.4567065239 0.4589433074 0.4611908197 0.4634493291 0.465719223 0.4680005312 0.4702927768 0.4725963175 0.4749104381 0.4772354662 0.4795718193 0.4819194376 x0.5943300128 0.4842786491 x0.5953080058 0.4866494834 0.4890317321 0.4914255738 0.4938306808 0.4962471724 0.4986754656 0.5011153817 0.5035672784 0.5060310364 0.5085068345 0.5109945536 0.5134981871 0.5160162449 0.5185465813 0.5210890174 0.5236517787 0.5262326598 0.5288254023 0.5314311981 0.5340496898 0.5366818905 0.5393260121 0.541983366 0.5446539521 0.5473367572 0.5500331521 0.5527421236 0.555464983 0.5582001209 0.5609487295 0.563710928 0.5664870143 0.5692769289 0.572080791 0.5748980641 0.5777287483 0.5805726051 0.5834307075 0.58630234 0.589188993 0.592089355 0.5950040221 0.5979331732 0.6008890867 0.6038672328 0.6068596244 0.6098668575 0.6128925085 0.6159348488 0.6189922094 0.6220652461 0.6251520514 0.6282536387 0.6313704848 0.6345024109 0.6376511455 0.6408157349 0.6439955831 0.6471914649 0.6504019499 0.6536274552 0.6568695903 0.6601269841 x0.6568920016 0.6634015441 x0.6578689814 0.6666929126 0.6700001359 0.6733236313 0.6766628027 0.6800175905 0.6833888888 0.6867774725 0.6901925802 0.6936302185 0.6970852613 0.7005571127 0.7040600777 0.7075885534 0.7111336589 0.7146963477 0.7182762027 0.721873343 0.7254879475 0.7291204929 0.7327719927 0.7364419103 0.7401298285 0.7438359857 0.7475610971 0.7513055801 0.7550681233 0.7588490248 0.7626484036 0.766464889 0.7703003883 0.7741553783 0.7780303955 0.7819243073 0.7858380079 0.78977108 0.7937304378 0.7977126837 0.8017141819 0.8057357073 0.8098039627 0.8139035702 0.8180238008 0.8221651316 0.8263311982 0.8305199146 0.8347301483 0.8389621973 0.8432127833 0.8474847674 0.8517782688 0.856092751 0.860429585 0.8647881746 0.8691688776 0.8735714555 0.8779962659 0.8824430108 0.8869119287 0.8914039135 0.8959199786 0.9004595876 0.9050223231 0.9096075892 x0.7194529772 0.9142154455 x0.7204300165 0.918847084 0.9235014319 0.9281796813 0.9329171181 0.9376920462 0.9424915314 0.9473146796 0.9521720409 0.9570567608 0.961967051 0.9669021964 0.971862793 0.9768486023 0.9818604589 0.9868973494 0.9919602871 0.9970487356 1.002163649 1.007304668 1.012469649 1.017660379 1.022877693 1.028121591 1.033393502 1.03869319 1.04401958 1.049372435 1.054754019 1.060163498 1.065600514 1.071065187 1.076597691 1.082170486 1.087773323 1.093403816 1.099081039 1.104793787 1.110535979 1.116307497 1.122111082 1.127946258 1.133810759 1.139705777 1.145629883 1.151584148 1.157569289 1.163584471 1.169631004 1.175709605 1.181818604 1.187959552 1.194134235 1.200340748 1.206580162 1.212851048 1.219153762 1.225487828 1.231853843 1.238254309 1.244746804 1.251290679 1.257868052 1.26448071 x0.7820140123 1.271158814 x0.7829909921 1.277881622 1.284640431 1.291433334 1.298262954 1.30512774 1.312030196 1.318967342 1.32594192 1.332953334 1.340001583 1.347087622 1.354209661 1.361369848 1.368568659 1.37580359 1.383075356 1.390385151 1.397733927 1.405120969 1.412551761 1.420023084 1.427533984 1.435084701 1.443009973 1.451061606 1.459157586 1.467299581 1.475614309 1.484006643 1.492446423 1.50093329 1.509471536 1.5180583 1.526693463 1.53537786 1.544109106 1.552889228 1.561718583 1.570598841 1.579532027 1.588516951 1.597551703 1.606638789 1.615776539 1.624965668 1.634206414 1.643501163 1.653088808 1.662785053 1.672536969 1.68234539 1.692815661 1.703472257 1.714196801 1.724987507 1.735845208 1.746769905 1.757762432 1.76882565 1.779954433 1.791154027 1.802423 1.813762665 x0.8445749879 1.825176716 x0.8455520272 1.836661935 1.848219395 1.859850883 1.87155056 1.883322239 1.895169616 1.907090187 1.919647217 1.932383418 1.945206404 1.958112836 1.971706629 1.98549819 1.999385238 2.013368845 2.027457714 2.041646719 2.055932522 2.070319176 2.084803343 2.099386215 2.114071131 2.128859997 2.143750429 2.158746004 2.173844337 2.189049721 2.20475626 2.220636845 2.236630917 2.252739906 2.270178556 2.287927389 2.305817127 2.323844671 2.342010975 2.360321522 2.378771305 2.397367239 2.416102409 2.4349823 2.45401001 2.473187447 2.492512941 2.511988163 2.53161788 2.5513978 2.57264328 2.59422946 2.615995169 2.63794446 2.661077023 2.684530973 2.708194017 2.732064009 2.756148338 2.780446291 2.804958105 2.82968545 2.854629517 2.879793406 2.905181885 2.930789709 x0.907136023 2.957942963 x0.9081130028 2.985488176 3.013287067 3.041346788 3.071584225 3.102309942 3.133346319 3.16469121 3.196336985 3.228294849 3.260574102 3.293173313 3.326109886 3.359379292 3.392980576 3.426913977 3.4646492 3.503092289 3.541966915 3.581268549 3.622164488 3.663613796 3.705542326 3.747950077 3.790836811 3.834219456 3.878097773 3.922473192 3.970992804 4.020373344 4.07036972 4.120989323 4.175264835 4.23045969 4.286384583 4.343044758 4.400471687 4.458650112 4.517602921 4.577334881 4.645190239 4.714486599 4.78482151 4.856205463 4.930800438 5.00666523 5.083690643 5.161900997 5.246739388 5.33325243 5.421190739 5.51058054 5.610175133 5.711968422 5.815616608 5.921140671 6.036144257 6.153687954 6.273530006 6.395694733 6.533883572 6.675585747 6.820359707 6.968260288 x0.9696969986 7.140613556 x0.9706749916 7.317941189 7.499689579 7.685931206 7.900645256 8.122048378 8.349653244 8.583636284 8.870529175 9.168207169 9.475845337 9.793816566 10.21643162 10.65932465 11.1213665 11.6034708 12.30291367 13.04796505 13.83819389 14.67618752 16.32525444 18.17058945 20.22444344 22.51038361 26.01783752 30.08181953 34.78014755 40.21256256 43.47352219 46.98410797 50.77817154 54.87852097}}
 addUserKnob {20 _dneg_metadatatab +INVISIBLE}
 addUserKnob {1 _dneg_metadata l "DNeg Metadata" +INVISIBLE}
 _dneg_metadata "\{\}"
}
BackdropNode {
 inputs 0
 name BackdropNode16
 tile_color 0x8e4c84ff
 label "SCRIPT ORGANIZATION"
 note_font_size 100
 xpos -2764
 ypos -9051
 bdwidth 2415
 bdheight 2104
 z_order -3
}
BackdropNode {
 inputs 0
 name BDx_2
 xpos -2403
 ypos -8258
 bdwidth 1053
 bdheight 1084
}
BackdropNode {
 inputs 0
 name BackdropNode1
 tile_color 0xc63154ff
 label "PLAYING WITH POSITION DATA"
 note_font_size 100
 xpos -2767
 ypos 232
 bdwidth 6541
 bdheight 3204
}
BackdropNode {
 inputs 0
 name BackdropNode17
 tile_color 0x406b4cff
 label "INJECTING MASK INTO PIPE AND PRECOMP IT"
 note_font_size 100
 xpos -2722
 ypos -6864
 bdwidth 2423
 bdheight 1522
}
BackdropNode {
 inputs 0
 name BackdropNode18
 tile_color 0x388e8e00
 label "ONE SETUP FOR MULTIPLE ELEMENTS"
 note_font_size 100
 xpos -2738
 ypos -5245
 bdwidth 2477
 bdheight 2080
}
BackdropNode {
 inputs 0
 name BackdropNode25
 tile_color 0x8e388e00
 label "TEXTURES GENERATION"
 note_font_size 100
 xpos -2712
 ypos -3039
 bdwidth 10921
 bdheight 3093
}
BackdropNode {
 inputs 0
 name BackdropNode10
 tile_color 0x388e8e00
 label "2D modifications of POSITION PASS"
 note_font_size 42
 xpos -1977
 ypos 1247
 bdwidth 1946
 bdheight 397
 z_order 1
}
BackdropNode {
 inputs 0
 name BackdropNode2
 tile_color 0x8e4f27ff
 label "COMBINE ELEMENTS"
 note_font_size 42
 xpos -2427
 ypos -4376
 bdwidth 856
 bdheight 238
 z_order 1
}
BackdropNode {
 inputs 0
 name BackdropNode3
 tile_color 0x7171c600
 label SETUP
 note_font_size 42
 xpos -2422
 ypos -4108
 bdwidth 376
 bdheight 459
 z_order 1
}
BackdropNode {
 inputs 0
 name BackdropNode4
 tile_color 0x8e388e00
 label "injecting a mask"
 note_font_size 42
 xpos -2198
 ypos -6261
 bdwidth 668
 bdheight 286
 z_order 1
}
BackdropNode {
 inputs 0
 name BackdropNode5
 tile_color 0x8e388e00
 label "SEPARATE THE\nELEMENTS"
 note_font_size 42
 xpos -2417
 ypos -3626
 bdwidth 361
 bdheight 360
 z_order 1
}
BackdropNode {
 inputs 0
 name BackdropNode6
 tile_color 0x71c67100
 label masks
 note_font_size 42
 xpos -1962
 ypos -4590
 bdwidth 354
 bdheight 202
 z_order 1
}
BackdropNode {
 inputs 0
 name BackdropNode7
 tile_color 0x8a8e43ff
 label ELEMENTS
 note_font_size 42
 xpos -2410
 ypos -4603
 bdwidth 422
 bdheight 212
 z_order 1
}
BackdropNode {
 inputs 0
 name BackdropNode8
 tile_color 0xaaaaaa00
 label "VARIATIONS OF THE PATTERN"
 note_font_size 42
 xpos -995
 ypos -1241
 bdwidth 1054
 bdheight 492
 z_order 1
}
BackdropNode {
 inputs 0
 name BackdropNode9
 tile_color 0x6b8e4dff
 label "2 WAYS OF GENERATION THE PATTERN"
 note_font_size 42
 xpos -2050
 ypos -1232
 bdwidth 929
 bdheight 511
 z_order 1
}
StickyNote {
 inputs 0
 name StickyNote14
 label 2
 note_font_size 200
 xpos -2675
 ypos -6685
}
Camera2 {
 inputs 0
 translate {-21.79999924 -1 -10.39999962}
 rotate {0 -113.8716627 0}
 name Camera4
 xpos -201
 ypos 2197
 addUserKnob {20 DNeg}
 addUserKnob {26 _version l "" +STARTLINE +INVISIBLE T 1.0}
 addUserKnob {41 "horiz aperture" T haperture}
 addUserKnob {41 "vert aperture" T vaperture}
 addUserKnob {4 setApertureValues l "" t "Set aperture values based on registered camera sensor data. The 'read from file' knob needs to be disabled and any potential curves deleted." +STARTLINE M {"Set Aperture Values" ANNI/Delivery "Alexa 65/Full" "Alexa 65/Half Res" "Alexa MINI/4:3 Full Ana" "Alexa MINI/16:9 Full" "Alexa MINI/OpenGate" "Alexa MINI/16:9 1.78 Ana" "Alexa Mini/OpenGate" "Alexa XT/OpenGate" "Alexa XT/4:3 Full Ana" "Alexa XT/16:9 1.78" "Alexa XT/16:9 1.78 Ana" "Alexa XT/4:3 Full" "Alexa XT/Open Gate" "Alexa XT/Open Gate TC" "Alexa XT/SuperOpenGate" "Alexa XT/SuperOpenGate Cropped" "Arri 65/6k 1.3 ana" "Arri 65/6k 2.11" BF/Delivery "BOND /Anamorphic" "Blackmagic Prod 4K/4K" "Canon 5D mkIII/HD" "Canon C300/16:9" "Delivery Extractions/Arri 65 1.3 ana Working" "Delivery Extractions/Arri 65 Working" "Extractions/CFW Delivery" "Film 35mm/Cinemascope Centred" "Film 35mm/Full Aperture" "Generic/1080p HD" Generic/Anamorphic Generic/Spherical "GoPro/Generic 16:9" HERC/Alexa IMAX/8K "Internal Movie Extractions/TRAINVFX Working" "Internal Movie Extractions/Alexa XT OpenGate" "Internal Movie Extractions/Previs" "Internal Movie Extractions/Arri 65 1.3 ana Working" "Internal Movie Extractions/MLOU Delivery" "Internal Movie Extractions/MAGIC Working" "Movie Extractions/Alexa XT OpenGate" "Movie Extractions/Alexa XT 4:3 Full Ana" "Movie Extractions/Alexa MINI 4:3 Full Ana" "Movie Extractions/Alexa MINI 16:9 1.78" "Movie Extractions/Alexa XT 16:9 1.78" "Movie Extractions/Alexa MINI OpenGate" "Movie Extractions/Alexa XT 16:9 1.78 Ana" "Movie Extractions/Alexa MINI 16:9 1.78 Ana" "Movie Extractions/Phantom Flex 4k" "Movie Extractions/MAE Working 2" "Movie Extractions/TS Anamorphic 4K" "Movie Extractions/EXO Working" "Movie Extractions/Previs" "Movie Extractions/MAGIC Working" "Movie Extractions/DOTN Working" "Phantom Flex/4k" Previs/Anamorphic Previs/Spherical "Red Epic/5K" "Red Epic Dragon/6K HD" "Red Epic Dragon/5K Full" "Red Epic Dragon/5K FullFrame Scaled" "TM/Alexa MINI 4:3 Full Ana" "Working Extractions/Arri 65 6k 1.3 ana" "Working Extractions/Alexa XT 4:3 Full Ana" "Working Extractions/Alexa XT OpenGate" "Working Extractions/Alexa XT 16:9 1.78" "Working Extractions/Alexa MINI 4:3 Full Ana" "Working Extractions/Alexa MINI OpenGate" "Working Extractions/Alexa MINI 16:9 1.78" "Working Extractions/Phantom Flex 4k" "Working Extractions/Alexa XT 16:9 1.78 Ana" "Working Extractions/Alexa MINI 16:9 1.78 Ana" "Working Extractions/EXO Working" "Working Extractions/EXO Working 2" "Working Extractions/Arri 65 6k" "Working Extractions/Alexa LF 4.5k OpenGate" "Working Extractions/DOTN Working" "internal Movie Extractions/Red Epic Dragon 5k FullFrame Scaled" "internal Movie Extractions/Red Epic Dragon 5K FullFrame" "internal Movie Extractions/IMAX 6K" "internal Movie Extractions/IMAX 8K" "Alexa LF/4.5k OpenGate" "Digital SLR/Full Frame" "Digital SLR/Full Frame Portrait" "Digital SLR/APS-C" "Digital SLR/APS-C Portrait" Generic/HD LatLong/360 LatLong/180}}
 addUserKnob {26 ""}
 addUserKnob {22 makeProjector l "Make Projector..." T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeProjectorNode']).makeProjectorNode()" +STARTLINE}
 addUserKnob {22 makeLinkedProjector l "Make Linked Projector..." -STARTLINE T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeProjectorNode']).makeLinkedProjectorNode()"}
 addUserKnob {26 ""}
 addUserKnob {7 hshake l "hero horiz shake" R -1 1}
 addUserKnob {7 vshake l "hero vert shake" R -1 1}
 addUserKnob {7 shakeroll l "hero shake roll" R -180 180}
 addUserKnob {7 ahshake l "ambient horiz shake" R -1 1}
 addUserKnob {7 avshake l "ambient vert shake" R -1 1}
 addUserKnob {7 ashakeroll l "ambient shake roll" R -180 180}
 addUserKnob {26 ""}
 addUserKnob {22 makeShakeCamera l "Make Shake Camera" T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeAmbientHeroShakeCamera']).makeAmbientHeroShakeCamera()" +STARTLINE}
 addUserKnob {22 makeShakeTransform l "Make Shake Transform" -STARTLINE T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeAmbientHeroShakeTransform']).makeAmbientHeroShakeTransform()"}
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 addUserKnob {1 leaf_label l Leaf}
 addUserKnob {1 ivy_version l Version}
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
Group {
 inputs 0
 name AOVCodex
 autolabel "__import__(\"dnnuke.nodes.codex_utils\", fromlist=\[\"autolabel_codex_group\"]).autolabel_codex_group()"
 tile_color 0x242424ff
 label CG_co_grd_m_1005_lighting_guy_L010_BEAUTY_v001
 note_font_color 0xffffffff
 xpos -2213
 ypos 832
 postage_stamp true
 addUserKnob {20 AOVCodex}
 addUserKnob {1 _class l "" +STARTLINE +INVISIBLE}
 _class AOVCodex
 addUserKnob {1 _wrapper l "" +STARTLINE +INVISIBLE}
 _wrapper "AOVCodex dnnuke.nodes.aov_codex.wrapper"
 addUserKnob {22 docButton l Documentation -STARTLINE T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocs']).openDocs(nuke.thisNode())"}
 addUserKnob {26 docdivider l "" +STARTLINE}
 addUserKnob {1 file l Beauty}
 file /jobs/TRAINVFX/co_grd_m_1005/CG/CG_co_grd_m_1005_lighting_guy_L010_BEAUTY_v001/beauty/2112x998/CG_co_grd_m_1005_lighting_guy_L010_BEAUTY_v001.####.exr
 addUserKnob {41 AOVs T Codex.aovs}
 addUserKnob {20 custom l Custom n 1}
 addUserKnob {20 custom_end l Custom n -1}
 addUserKnob {20 readknobs l "Read Knobs" n 1}
 addUserKnob {41 format T Codex.format}
 addUserKnob {41 first l "frame range" T Codex.first}
 addUserKnob {41 before l "" -STARTLINE T Codex.before}
 addUserKnob {41 last l "" -STARTLINE T Codex.last}
 addUserKnob {41 after l "" -STARTLINE T Codex.after}
 addUserKnob {41 frame_mode l frame T Codex.frame_mode}
 addUserKnob {41 frame l "" -STARTLINE T Codex.frame}
 addUserKnob {41 on_error l "missing frames" T Codex.on_error}
 addUserKnob {20 readknobsEndGroup l "Read Knobs" n -1}
 addUserKnob {20 template_tab l Template}
 addUserKnob {26 template l "script : " T CDXC_TRAINVFX_v001.nk}
 addUserKnob {26 _1 l "" +STARTLINE T " "}
 addUserKnob {22 ivy_publish l Publish... t "Publish internal nodes as a new codex template to the SHOW.<br />New AOVCodex nodes import the latest published, approved template." T "__import__('dnnuke.core.codex.publisher', fromlist=\['publish']).publish(group=nuke.thisNode())" +STARTLINE}
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 twig_dnuuid 033bf858-db94-4ebf-8f74-d56c3bfc9632
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 stalk_dnuuid 361f0d4f-fbe5-4c32-84c8-174fb2909ab2
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 leaf_dnuuid 38724fde-d6a8-4bf2-bd8e-27d932f64f34
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 twigtype cgr
 addUserKnob {1 leaf_label l Leaf}
 leaf_label main_proxy0
 addUserKnob {1 ivy_version l Version}
 ivy_version 1
 addUserKnob {43 ivy_notes l Notes}
 ivy_notes "Shot for GL"
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
 MetaPython {
  inputs 0
  python "stalk_dnuuid = nuke.thisNode()\['stalk_dnuuid'].value()\n\nthis.catalog\['stalk'].clear()\nif stalk_dnuuid:\n    codex_item = codex.CodexItem.create(stalk_dnuuid, \"Stalk\")\n    this.catalog\['stalk'].append(codex_item)\n"
  name MetaStalkCreatePy
  tile_color 0x4800ff
  label "stalk_dnuuid : \[value stalk_dnuuid]"
  selected true
  xpos -40
  ypos -9
  addUserKnob {20 StalkCreate}
  addUserKnob {1 stalk_dnuuid}
  stalk_dnuuid 361f0d4f-fbe5-4c32-84c8-174fb2909ab2
 }
 MetaPython {
  python "if len(this.catalog\[\"stalk\"]):\n    stalk_dnuuid = this.catalog\[\"stalk\"]\[0]\[\"dnuuid\"]\n    codex_array = codex.CodexArray.create(stalk_dnuuid)\n    this.catalog\['leaf'] = codex_array.filter(codex.ItemType.deep, \"0\")\n    for item in codex_array.filter(codex.ItemType.deep, \"1\"):\n        if item.get(\"dnuuid\"):\n            data_object = item.get(\"dnuuid\").as_data_object()\n            if data_object.hasAttr(\"format\") and data_object.get(\"format\") == \"id\":\n                this.catalog\['id'].append(item)\n            else:\n                this.catalog\['leaf'].append(item)\n    this.catalog\['stalk'].clear()\n"
  name MetaLeafsFromStalk
  tile_color 0x4800ff
  selected true
 }
 Codex {
  file /jobs/TRAINVFX/co_grd_m_1005/CG/CG_co_grd_m_1005_lighting_guy_L010_BEAUTY_v001/beauty/2112x998/CG_co_grd_m_1005_lighting_guy_L010_BEAUTY_v001.####.exr
  format "2112 998 0 0 2112 998 1 "
  first 1001
  last 1235
  smartGrade true
  aovs ""
  name Codex
  selected true
 }
 Output {
  name Output1
  selected true
 }
 StickyNote {
  inputs 0
  name StickyNote1
  label "<p>Codex Template Script\n/jobs/TRAINVFX/ASSET/ivy/cdxc/CDXC_TRAINVFX_v001/CDXC_TRAINVFX_v001.nk"
  note_font_size 12
  xpos 160
  ypos -9
 }
end_group
add_layer {__position_world __position_world.x __position_world.y __position_world.z}
Unpremult {
 channels __position_world
 name Unpremult1
 xpos -2213
 ypos 942
}
Dot {
 name Dot2
 xpos -2185
 ypos 998
}
set Nd5a3e80 [stack 0]
Dot {
 name Dot8
 xpos -2185
 ypos 1675
}
set Nbf07aa0 [stack 0]
push $Nd5a3e80
Dot {
 name Dot51
 label "your POSITION pass must be in POS channel \nin order to work in POINT RENDER"
 note_font_size 21
 xpos -1764
 ypos 998
}
add_layer {pos pos.red pos.green pos.blue pos.alpha}
Shuffle {
 in __position_world
 in2 rgba
 alpha alpha2
 out pos
 name Shuffle1
 xpos -1792
 ypos 1076
}
Group {
 name Point_Transform
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 xpos -1792
 ypos 1130
 addUserKnob {20 User}
 addUserKnob {26 info l "" +STARTLINE T "Point Transform v1.1\n"}
 addUserKnob {26 divider_transform l "<b><font color=#7DADF9>Transform</font><b>"}
 addUserKnob {41 translate T Axis1.translate}
 addUserKnob {41 rotate T Axis1.rotate}
 addUserKnob {41 scaling l scale T Axis1.scaling}
 addUserKnob {41 uniform_scale l "uniform scale" T Axis1.uniform_scale}
 addUserKnob {41 skew T Axis1.skew}
 addUserKnob {41 pivot T Axis1.pivot}
}
 Input {
  inputs 0
  name Transform
  xpos 381
  ypos -224
 }
 Dot {
  name Dot1
  xpos 421
  ypos -183
 }
set Nc74fcd0 [stack 0]
 Shuffle {
  in pos
  name Shuffle14
  xpos 501
  ypos -186
 }
 ColorMatrix {
  matrix {
      {{parent.Axis1.world_matrix.0} {parent.Axis1.world_matrix.1} {parent.Axis1.world_matrix.2}}
      {{parent.Axis1.world_matrix.4} {parent.Axis1.world_matrix.5} {parent.Axis1.world_matrix.6}}
      {{parent.Axis1.world_matrix.8} {parent.Axis1.world_matrix.9} {parent.Axis1.world_matrix.10}}
    }
  name ColorMatrix1
  xpos 501
  ypos -98
 }
 Grade {
  add {{parent.Axis1.world_matrix.3} {parent.Axis1.world_matrix.7} {parent.Axis1.world_matrix.11} 0}
  black_clamp false
  name Grade5
  xpos 501
  ypos -62
 }
 Shuffle {
  out pos
  name Shuffle13
  xpos 501
  ypos 30
 }
push $Nc74fcd0
 Merge2 {
  inputs 2
  operation copy
  bbox B
  Achannels pos
  Bchannels pos
  output pos
  name Merge1
  xpos 389
  ypos 30
 }
 Output {
  name Output1
  xpos 389
  ypos 130
 }
 Input {
  inputs 0
  name InputAxis
  xpos 629
  ypos -199
  number 1
 }
 Axis2 {
  translate {-127.3 -16 -38.3}
  name Axis1
  xpos 639
  ypos -110
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  addUserKnob {1 leaf_label l Leaf}
  addUserKnob {1 ivy_version l Version}
  addUserKnob {43 ivy_notes l Notes}
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
end_group
Dot {
 name Dot3
 xpos -1764
 ypos 1182
}
set Nc142440 [stack 0]
Dot {
 name Dot9
 xpos -922
 ypos 1182
}
set Ndaadbd0 [stack 0]
Dot {
 name Dot10
 xpos -295
 ypos 1182
}
Dot {
 name Dot4
 xpos -295
 ypos 1420
}
set Nd569280 [stack 0]
Mask3DV2 {
 name Mask3DV2_4
 note_font "Bitstream Vera Sans"
 xpos -451
 ypos 1497
 in __position_world
 out rgba.alpha
 unpremultiply false
 matteShape Cube
 center {127.2569733 {curve x1001 27.515973 x1051 0.515973} 38.48317719}
 radius 10
 transform 1
 scaling {10 1 {scaling.x}}
 falloff 0.5
 _class Mask3D
}
push $Nd569280
Group {
 name Point_Twist
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 xpos -199
 ypos 1497
 addUserKnob {20 User}
 addUserKnob {26 _info l "" +STARTLINE T "Point Twist v1.0\n\nApply a twisting force."}
 addUserKnob {26 _infoTwist l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {4 RotationAxis l "Rotation Axis" M {X Y Z "" ""}}
 RotationAxis Y
 addUserKnob {7 Rotation R 0 10}
 Rotation 2
 addUserKnob {7 Offset}
 Offset {{frame/10}}
 addUserKnob {13 RotationCenter l "Rotation Center"}
}
 Input {
  inputs 0
  name InputAxis
  xpos 629
  ypos -189
  number 1
 }
 Axis2 {
  name Axis1
  xpos 639
  ypos -109
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  addUserKnob {1 leaf_label l Leaf}
  addUserKnob {1 ivy_version l Version}
  addUserKnob {43 ivy_notes l Notes}
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Input {
  inputs 0
  name Twist
  xpos 389
  ypos -222
 }
 Dot {
  name Dot1
  xpos 423
  ypos -182
 }
set Nb0e22a0 [stack 0]
 Shuffle {
  in pos
  name Shuffle14
  xpos 501
  ypos -186
 }
 BlinkScript {
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/PointRender_Twist.cpp
  recompileCount 2
  KernelDescription "2 \"SaturationKernel\" iterate pixelWise f188ea1ef896243f2e7261f7fd3683ffbcb38ca12f3ad0b74de8e8b7c4adbbf0 2 \"src\" Read Point \"dst\" Write Point 5 \"Rotation\" Float 1 AADgQA== \"Offset\" Float 1 AAAAAA== \"AxisCenter\" Float 3 AAAAPwAAAD8AAAA/AAAAAA== \"RotationAxis\" Int 1 AAAAAA== \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== 5 \"inputRot\" 1 1 \"pOffset\" 1 1 \"AxisCenter\" 3 1 \"pRotateAxis\" 1 1 \"rm\" 16 1 0"
  kernelSource "kernel SaturationKernel : ImageComputationKernel<ePixelWise>\r\n\{\r\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\r\n  Image<eWrite> dst; // the output image\r\n\r\n  param:\r\n    float inputRot; // This parameter is made available to the user.\r\n    float pOffset;\r\n    float3 AxisCenter;\r\n    int pRotateAxis;\r\n    float4x4 rm;\r\n\r\n  void define() \{\r\n    defineParam(inputRot, \"Rotation\", 7.0f);\r\n    defineParam(pOffset, \"Offset\", 0.0f);\r\n    defineParam(AxisCenter, \"AxisCenter\", float3(0.5f,0.5f,0.5f));\r\n    defineParam(pRotateAxis, \"RotationAxis\", 0);\r\n    defineParam(rm, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\r\n                                                    0.0f,1.0f,0.0f,0.0f,\r\n                                                    0.0f,0.0f,1.0f,0.0f,\r\n                                                    0.0f,0.0f,0.0f,1.0f));    \r\n  \}\r\n\r\n  void process() \{\r\n    // Read the input image\r\n    float percent = inputRot / (2*PI) ;\r\n    float4 sample = src();\r\n    float3 Input = float3(sample.x,sample.y,sample.z);\r\n    float4x4 rotMatrix = \{1.0f,0.0f,0.0f,0.0f, 0.0f,1.0f,0.0f,0.0f, 0.0f,0.0f,1.0f,0.0f, 0.0f,0.0f,0.0f,1.0f\};\r\n    rotMatrix.setElements(rm\[0]\[0],rm\[0]\[1],rm\[0]\[2],rm\[0]\[3],rm\[1]\[0],rm\[1]\[1],rm\[1]\[2],rm\[1]\[3],rm\[2]\[0],rm\[2]\[1],rm\[2]\[2],rm\[2]\[3],rm\[3]\[0],rm\[3]\[1],rm\[3]\[2],rm\[3]\[3]);\r\n    rotMatrix.translate(float4(-AxisCenter.x,-AxisCenter.y,-AxisCenter.z,1.0f));\r\n    if (pRotateAxis == 1) \{\r\n      rotMatrix.rotateY((sample.y-.5+pOffset)*-inputRot); //\r\n    \}\r\n    else if (pRotateAxis == 2) \{\r\n      rotMatrix.rotateZ((sample.z-.5+pOffset)*-inputRot); //\r\n    \}\r\n    else \{\r\n      rotMatrix.rotateX((sample.x-.5+pOffset)*-inputRot); //\r\n    \}\r\n\r\n    rotMatrix.translate(float4(AxisCenter.x,AxisCenter.y,AxisCenter.z,-1.0f));\r\n    sample.w = 1.0f;\r\n    float4 rotation = rotMatrix*sample;\r\n\r\n    dst() = float4(rotation.x, rotation.y, rotation.z, sample.w);\r\n  \}\r\n\};\r\n\r\n\r\n"
  rebuild ""
  SaturationKernel_Rotation {{parent.Rotation}}
  SaturationKernel_Offset {{parent.Offset}}
  SaturationKernel_AxisCenter {{parent.RotationCenter} {parent.RotationCenter} {parent.RotationCenter}}
  SaturationKernel_RotationAxis {{parent.RotationAxis}}
  group_SaturationKernel_cam_Matrix 1
  SaturationKernel_cam_Matrix {
      {{parent.Axis1.world_matrix} {parent.Axis1.world_matrix} {parent.Axis1.world_matrix} {parent.Axis1.world_matrix}}
      {{parent.Axis1.world_matrix} {parent.Axis1.world_matrix} {parent.Axis1.world_matrix} {parent.Axis1.world_matrix}}
      {{parent.Axis1.world_matrix} {parent.Axis1.world_matrix} {parent.Axis1.world_matrix} {parent.Axis1.world_matrix}}
      {{parent.Axis1.world_matrix} {parent.Axis1.world_matrix} {parent.Axis1.world_matrix} {parent.Axis1.world_matrix}}
    }
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos 501
  ypos -96
 }
 Shuffle {
  out pos
  name Shuffle13
  xpos 501
  ypos 34
 }
push $Nb0e22a0
 Merge2 {
  inputs 2
  operation copy
  bbox B
  Achannels pos
  Bchannels pos
  output pos
  name Merge1
  xpos 389
  ypos 30
 }
 Output {
  name Output1
  xpos 389
  ypos 130
 }
end_group
push $Nd569280
Dissolve {
 inputs 2+1
 which 1
 name Dissolve1
 xpos -323
 ypos 1491
}
ShuffleCopy {
 inputs 2
 in2 pos
 red red
 green green
 blue blue
 out2 __position_world
 name ShuffleCopy3
 xpos -323
 ypos 1672
}
Group {
 inputs 2
 name Point_Render2
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 xpos -323
 ypos 2218
 addUserKnob {20 User l "Point Render" t dd}
 addUserKnob {26 info_header l "" +STARTLINE T "Point Render v1.2"}
 addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {4 RenderMode l "Render Mode" t "Some generators support multiple render modes other than just point rendering. This should be considered a experimental feature, but can be used to great effect.\n\nIn the Render Settings tab you can find more controls relating to Wire and Facet rendering modes.\n\nNote that Facet Render can be slow when really close to a object. " M {"Point Render" "Wire Render" "Facet Render (experimental)" "" "" ""}}
 addUserKnob {7 FocalLength l "Focal Length" t "The point render does not take the focal length from the input camera, so if you want to match it to a camera you should link the focal length from the camera to this." +INVISIBLE R 0 200}
 FocalLength 40
 addUserKnob {7 horizontalApeture l "Horiz Apeture" +INVISIBLE R 0 100}
 horizontalApeture 24.576
 addUserKnob {14 overscan l Overscan R 0 100}
 addUserKnob {7 AlphaMultiplier l Exposure t "This is a general exposure modifier that lets you adjust the overall brightness of the render." R 0 2}
 AlphaMultiplier 1
 addUserKnob {6 OutputZdepth l "Output Z-depth" t "Will output a Z-depth channel. This will cause reduced rendering performence." +STARTLINE}
 addUserKnob {6 UseOcclusionMap l "Use Occlusion Map" t "Enable the Occlusion map input. This lets you use a depth map as a holdout.\n\nNote:\nThe Red channal should contain the depth (absolute distance, not 1/depth)\nThe Alpha channal must be 1 for the areas that you want to holdout." +STARTLINE}
 addUserKnob {4 occ_method l "" t "Real Depth - input RGB should be the distance to the camera, and A should be the alpha (White occlude, Black ingore).\n\n1/depth.z (Scanline Render) - Will use the depth.Z channal from the scanline render and convert to real depth internally. Alpha is still required." -STARTLINE M {"Real Depth" "1/depth.z (Scanline Render)" ""}}
 occ_method "1/depth.z (Scanline Render)"
 addUserKnob {26 devider_cc l "<b><font color=#7DADF9>Preview</font><b>"}
 addUserKnob {6 FastPreview l "Fast Preview" t "Reduce the number of points for a quick preview of the final render." +STARTLINE}
 addUserKnob {6 HighlightCompression l "Hilight Compression" t "Compresses the highlights to make it easier to see bright details." +STARTLINE}
 addUserKnob {7 HighlightCeiling l "Highlight Ceiling" t "Adjust the cealing for the highlight compression." R 1 10}
 HighlightCeiling 1.15
 addUserKnob {7 Compression t "The compression amount." -STARTLINE R 0 5}
 Compression 1
 addUserKnob {26 devider_format l "<b><font color=#7DADF9>Format</font><b>"}
 addUserKnob {41 format l "output format" T Settings_Format.format}
 addUserKnob {20 WireRender l "Render Settings"}
 addUserKnob {26 devider_wirerender l "<b><font color=#7DADF9>Wire Rendering</font><b>"}
 addUserKnob {4 wire_type l "Connection Mode" t "*Normal\nConnect lines between the local neigbours of the 2d position map\n\n*Nearest\nConnect lines to the nearest points (in 3D space). This mode is limited to 100x100 points for performence reasons!" M {Normal Nearest "" "" "" "" "" "" "" ""}}
 addUserKnob {26 text l "Normal Mode Wires" T " "}
 addUserKnob {6 connect_x l x t "Connect wires in the (uv) X axis." -STARTLINE}
 connect_x true
 addUserKnob {6 connect_xy l xy t "Connect wires in the (uv) XY axis." -STARTLINE}
 connect_xy true
 addUserKnob {6 connect_y l y t "Connect wires in the (uv) Y axis." -STARTLINE}
 connect_y true
 addUserKnob {6 connect_aux l aux t "If you input a vector map into the Aux input for this node, and enable this option, you will get a wire from each point along that vector." -STARTLINE}
 addUserKnob {7 wire_maxdistance l "Max Distance" t "The maximum distance that the wires connect." R 0 10}
 wire_maxdistance 6
 addUserKnob {7 wire_Threshold l "Distance Threshold" t "Control the max distance threshold" R 0 2}
 wire_Threshold 0.5
 addUserKnob {3 wire_connections l "Max Connections" t "The maximum number of connections (Not Yet Implemented)"}
 wire_connections 4
 addUserKnob {7 maxSamples l "Max Line Samples" t "The maximum length of a line. Once a line is longer than this, it will start break up. \nThis can also be used as a creative effect if you set it low, try setting it to 10 in wire mode to get dotted lines" R 0 10000}
 maxSamples 10000
 addUserKnob {7 lineoffset l "Line Offset" t "Expand or contract the lines."}
 lineoffset 1
 addUserKnob {7 inGain l "In Gain" t "Gain the brightness of the in-point of the lines"}
 inGain 1
 addUserKnob {7 outGain l "Out Gain" t "Gain the brightness of the out-point of the lines" -STARTLINE}
 outGain 1
 addUserKnob {26 devider_facet l "<b><font color=#7DADF9>Facet Rendering</font><b>"}
 addUserKnob {4 renderMode l "Render Mode" t "Pick the desidered render mode." M {Diffuse "Local ST" Normal "Facing Ratio" UV ST "View Normal" "World Position" "" ""}}
 addUserKnob {6 facet_flatShading l "Flat Shading" t "Flat shading" +STARTLINE}
 addUserKnob {6 facet_depth l "Depth Buffer" t "Enable depth sorting to avoid additive surfaces." -STARTLINE}
 addUserKnob {6 facet_front l "Front Face" t "Render front facing facets" +STARTLINE}
 facet_front true
 addUserKnob {6 facet_backface l "Back Face" t "Render backfacing faces" -STARTLINE}
 facet_backface true
 addUserKnob {26 _1 l "<b><font color=#7DADF9>Other</font><b>"}
 addUserKnob {6 CloseX l "Close X" t "On spheres or round objects this closes the loop" +STARTLINE}
 addUserKnob {6 CloseY l "Close Y" t "On spheres or round objects this closes the loop" -STARTLINE}
 addUserKnob {20 Fog_1 l Fog}
 addUserKnob {26 Devider_Fog l "<b><font color=#7DADF9>Fog</font><b>"}
 addUserKnob {6 Fog t "Fog reduces the brightness of poins far from the camera." +STARTLINE}
 addUserKnob {7 FogNear l "Fog Near" R 0 200}
 FogNear 1
 addUserKnob {7 FogFar l "Fog Far" R 0 200}
 FogFar 150
 addUserKnob {7 FogExponent l "Fog Exponent" R 0 8}
 FogExponent 8
 addUserKnob {20 DepthOfField l "Depth of Field"}
 addUserKnob {26 devider_dof l "<b><font color=#7DADF9>Depth Of Field</font><b>"}
 addUserKnob {6 dof_enable l Enable +STARTLINE}
 addUserKnob {7 dof_focaldepth l "Focal Depth" R 0 40}
 dof_focaldepth 24.1
 addUserKnob {7 dof_dof l "Depth of Field" R 0 10}
 dof_dof 1
 addUserKnob {7 dof_maxSize l "Max Size"}
 dof_maxSize 0.6
 addUserKnob {7 dof_Aspect l "Aspect Ratio"}
 dof_Aspect 1
 addUserKnob {7 dof_bias l Bias R -3 3}
 dof_bias -0.2
 addUserKnob {4 Dof_Quality l Quality M {Low Medium High Extreme}}
 addUserKnob {20 MotionBlur}
 addUserKnob {26 devider_MotionBlur l "<b><font color=#7DADF9>Motion Blur</font><b>"}
 addUserKnob {6 mb_enable l Enable +STARTLINE}
 addUserKnob {6 Fast l "Fast (Interpolated)" -STARTLINE}
 Fast true
 addUserKnob {3 Samples}
 Samples 4
 addUserKnob {7 Shutter R 0 2}
 Shutter 0.5
 addUserKnob {4 pulldown l "Shutter Offset" M {Centered Start End ""}}
 addUserKnob {20 preview_3d l "3D Preview"}
 addUserKnob {6 Enable3DPreview l "Enable 3D Preview" t "Display a preview of the points in the Nuke 3D view." +STARTLINE}
 Enable3DPreview true
 addUserKnob {41 pointSize l "point size" T PreviewNode.pointSize}
 addUserKnob {41 detail l "point detail" T PreviewNode.detail}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x388e8e00
  label "Output Format Manager"
  note_font_size 22
  xpos -1079
  ypos 117
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode10
  tile_color 0x388e8e00
  label "AUX Input"
  note_font_size 22
  xpos -385
  ypos 178
  bdwidth 207
  bdheight 178
 }
 BackdropNode {
  inputs 0
  name BackdropNode11
  tile_color 0x388e8e00
  label "Point Render"
  note_font_size 22
  xpos -96
  ypos 99
  bdwidth 203
  bdheight 131
 }
 BackdropNode {
  inputs 0
  name BackdropNode12
  tile_color 0x388e8e00
  label "Normal Generator\nFor Vertex Normals"
  note_font_size 22
  xpos -616
  ypos 243
  bdwidth 191
  bdheight 122
 }
 BackdropNode {
  inputs 0
  name BackdropNode13
  tile_color 0x388e8e00
  label "Ensure output format"
  note_font_size 22
  xpos -622
  ypos -41
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode14
  tile_color 0x388e8e00
  label "Motion Blur"
  note_font_size 22
  xpos -85
  ypos 255
  bdwidth 264
  bdheight 96
 }
 BackdropNode {
  inputs 0
  name BackdropNode15
  tile_color 0x388e8e00
  label "Soft Preview"
  note_font_size 22
  xpos -83
  ypos 601
  bdwidth 191
  bdheight 94
 }
 BackdropNode {
  inputs 0
  name BackdropNode16
  tile_color 0x388e8e00
  label "Final format"
  note_font_size 22
  xpos -84
  ypos 482
  bdwidth 192
  bdheight 95
 }
 BackdropNode {
  inputs 0
  name BackdropNode17
  tile_color 0x388e8e00
  label "No Clue =)"
  note_font_size 22
  xpos -385
  ypos -41
  bdwidth 160
  bdheight 87
 }
 BackdropNode {
  inputs 0
  name BackdropNode18
  tile_color 0x388e8e00
  label "Z-Depth Shuffle"
  note_font_size 22
  xpos -85
  ypos 367
  bdwidth 264
  bdheight 96
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0x388e8e00
  label Motionblur
  note_font_size 22
  xpos -672
  ypos -781
  bdwidth 258
  bdheight 246
 }
 BackdropNode {
  inputs 0
  name BackdropNode3
  tile_color 0x388e8e00
  label "Fast Preview"
  note_font_size 22
  xpos -669
  ypos -971
  bdwidth 254
  bdheight 138
 }
 BackdropNode {
  inputs 0
  name BackdropNode4
  tile_color 0x388e8e00
  label "Nearest Wire Mode Clamp"
  note_font_size 22
  xpos -666
  ypos -1184
  bdwidth 253
  bdheight 111
 }
 BackdropNode {
  inputs 0
  name BackdropNode5
  tile_color 0x388e8e00
  label Occlusion
  note_font_size 22
  xpos 208
  ypos 27
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode6
  tile_color 0x388e8e00
  label "Input Camera Container"
  note_font_size 22
  xpos -1357
  ypos 121
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode7
  tile_color 0x388e8e00
  label "3D Preview"
  note_font_size 22
  xpos -88
  ypos -45
  bdwidth 207
  bdheight 102
 }
 BackdropNode {
  inputs 0
  name BackdropNode8
  tile_color 0x388e8e00
  label "Input Format Manager"
  note_font_size 22
  xpos -526
  ypos -459
  bdwidth 208
  bdheight 97
 }
 BackdropNode {
  inputs 0
  name BackdropNode9
  tile_color 0x388e8e00
  label FOG
  note_font_size 22
  xpos -602
  ypos -253
  bdwidth 370
  bdheight 152
 }
 Input {
  inputs 0
  name InputPointData
  xpos -584
  ypos -1321
 }
 Dot {
  name Dot4
  xpos -550
  ypos -1234
 }
set N16abaa00 [stack 0]
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize fill
  filter Impulse
  black_outside true
  name Reformat5
  xpos -584
  ypos -906
  disable {{!parent.FastPreview==1}}
 }
 Grade {
  white 10
  name Grade2
  xpos -584
  ypos -874
  disable {{!parent.FastPreview}}
 }
 Dot {
  name Dot2
  xpos -550
  ypos -712
 }
set N16adf990 [stack 0]
 Group {
  name FrameHold3
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -501
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame+1}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot6
  xpos -467
  ypos -659
 }
set N16aff8e0 [stack 0]
push $N16adf990
 Group {
  name FrameHold2
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -660
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot5
  xpos -626
  ypos -659
 }
set N16b1f770 [stack 0]
 Dissolve {
  inputs 2
  which {{frame-floor(frame)}}
  name Dissolve1
  xpos -582
  ypos -666
  disable {{1-parent.mb_enable}}
 }
set N16b24380 [stack 0]
push $N16adf990
 Switch {
  inputs 2
  which {{parent.Fast}}
  name Switch2
  xpos -584
  ypos -567
 }
 Dot {
  name DataFetch
  label "data fetch\t"
  note_font_color 0xff21ff
  xpos -550
  ypos -513
  addUserKnob {20 User}
  addUserKnob {3 n_particles l "Number of Particles"}
  addUserKnob {3 gentype l "Type Of Generator"}
  addUserKnob {26 info l "" -STARTLINE T "0 = unknown, 1 = Card, 2 = Sphere, 3 = Grid"}
 }
set N16b37730 [stack 0]
 Dot {
  name Dot3
  xpos -635
  ypos -513
 }
 Dot {
  name Dot1
  xpos -635
  ypos 863
 }
 Reformat {
  inputs 0
  format "1920 1080 0 0 1920 1080 1 HD_1080"
  resize distort
  center false
  black_outside true
  name Settings_Format
  xpos -992
  ypos 209
 }
 AdjBBox {
  numpixels {{parent.overscan} {parent.overscan}}
  name AdjBBox2
  xpos -992
  ypos 241
 }
 Input {
  inputs 0
  name InputOcclusion
  xpos 238
  ypos 75
  number 2
 }
 Expression {
  expr0 depth.Z>0?1/depth.Z:0
  name Expression2
  xpos 238
  ypos 104
  disable {{!parent.occ_method}}
 }
 Constant {
  inputs 0
  channels rgb
  color 1
  format {{{parent.Settings_Format.format}}}
  name Empty
  xpos 371
  ypos 139
 }
 Switch {
  inputs 2
  which {{parent.UseOcclusionMap}}
  name Switch1
  xpos 238
  ypos 163
 }
 AdjBBox {
  numpixels {{parent.overscan} {parent.overscan}}
  name AdjBBox1
  xpos 118
  ypos 163
 }
set N16b82e00 [stack 0]
 Input {
  inputs 0
  name Aux
  xpos -324
  ypos 214
  number 3
 }
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter Impulse
  black_outside true
  name Reformat2
  xpos -324
  ypos 238
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop1
  xpos -324
  ypos 462
 }
push $N16b37730
 Shuffle {
  in pos
  name Shuffle1
  xpos -584
  ypos -192
 }
set N16ba92b0 [stack 0]
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter Impulse
  black_outside true
  name Reformat4
  xpos -584
  ypos 18
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop2
  xpos -584
  ypos 48
 }
 Dot {
  name Dot8
  xpos -550
  ypos 166
 }
set N16bd34f0 [stack 0]
 Group {
  name Point_Normal2
  tile_color 0x434343ff
  note_font_color 0x55ffffff
  xpos -584
  ypos 498
  disable {{!(renderMode==2&&RenderMode==2)}}
  addUserKnob {20 User}
  addUserKnob {26 info l "" +STARTLINE T "Point Normal v1.0"}
  addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
  addUserKnob {26 info_1 l "" +STARTLINE T "well, not much to do here =)"}
 }
  Input {
   inputs 0
   name Input1
   xpos 389
   ypos 207
  }
  Shuffle {
   in pos
   name Shuffle1
   xpos 389
   ypos 294
  }
  BlinkScript {
   kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/BasicLight.cpp
   recompileCount 69
   ProgramGroup 1
   KernelDescription "2 \"PointRender3D\" iterate pixelWise d5452fe7b684561fcfa5182d0c789025a037cc4fe4474c24e065e3fa53fcd8ce 2 \"ppos\" Read Random \"dst\" Write Point 9 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"Zoom\" Float 1 AACAPw== \"half Lambert\" Bool 1 AQ== \"light Mode\" Int 1 AAAAAA== \"light_position\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"light_color\" Float 3 AACAPwAAgD8AAIA/AAAAAA== 9 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"zoom\" 1 1 \"halfLambert\" 1 1 \"lightMode\" 1 1 \"lightPos\" 3 1 \"lightcolor\" 3 1 10 \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"namount\" Float 1 1 AAAAAA=="
   kernelSource "inline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}\n\ninline float saturate(float _in)\n\{\n    return max(0.0f,min(1.0f,_in));\n\}\n\ninline float3 reflect(float3 incidence,float3 normal)\n\{\n  return incidence - 2.f * dot(incidence, normal) * normal;\n\}\n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n    \n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    if (fabs(pScreen.x) > canvasWidth || fabs(pScreen.y) > canvasHeight) \n         return false; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eWrite> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    bool halfLambert;\n    int lightMode;\n    float3 lightPos;\n    float3 lightcolor;\n\n\n  local: //Local variables\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n    float namount; //dither amount\n\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(halfLambert, \"half Lambert\", true);\n    defineParam(lightMode, \"light Mode\", 0);\n    defineParam(lightPos,      \"light_position\", float3(0,0,0));  \n    defineParam(lightcolor,      \"light_color\", float3(1.0,1.0,1.0)); \n  \}\n\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n    namount = 0.0001; //dither amount\n  \}\n\n\n\nfloat3 Reconsile3D(float3 _PointPos)\{\n    vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n    int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    return tRaster;\n\}\n\n\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nfloat3 facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos;\n    float4 V0_Sample,V1_Sample,V2_Sample;\n    float3 normal0,normal1,normal2;\n\n    //for area calculation\n    float area;\n    float3 V0,V1,V2;\n    float3 output = float3(0.0f);\n  if (insideX) \{\n    V2_Sample = ppos(pos.x+1,pos.y);\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(pos.x+1,pos.y-1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n            float3 Normal = CalculateVertexNormals(_vWorld,V2_wPos,V1_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          //write output\n          output +=  float3(Normal.x,Normal.y,Normal.z);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,pos.y+1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n          float3 Normal = CalculateVertexNormals(_vWorld,V1_wPos,V2_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          output += float3(Normal.x,Normal.y,Normal.z);\n\n        \}\n      \}\n    \}\n  \}\n  return output;\n\}\n\n\n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 hitNormal = cross((V1 - V0),(V2 - V0)); \n        return hitNormal;\n\}\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float3 output = float3(0.0f);\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float3 point_pos = float3(_sample.x,_sample.y,_sample.z);\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n      dst() = float4(0.0f);\n      output+=facet_render(pos,float3(_sample.x,_sample.y,_sample.z))*2.0f;\n      _sample = ppos(pos.x-1,pos.y); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x-1,pos.y+1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y+1),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x,pos.y-1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x,pos.y-1),float3(_sample.x,_sample.y,_sample.z));\n\n      output = normalize(output);\n      float3 normal = -output;\n\n      \n\n\n      dst() = float4(normal.x,normal.y,normal.z,1.0f);\n    \}\n  \} //----> process\n\};\n"
   rebuild ""
   "PointRender3D_half Lambert" false
   PointRender3D_light_position {{parent.Axis1.translate} {parent.Axis1.translate} {parent.Axis1.translate}}
   PointRender3D_light_color {0 0 0}
   rebuild_finalise ""
   name BlinkScript1
   xpos 389
   ypos 344
  }
  Grade {
   multiply 0.5
   add 0.5
   black_clamp false
   name Grade1
   xpos 389
   ypos 376
   disable true
  }
  Output {
   name Output1
   xpos 389
   ypos 459
  }
  Axis2 {
   inputs 0
   translate {0.5 0.5 0.5}
   name Axis1
   xpos 661
   ypos 318
   addUserKnob {20 Ivy}
   addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
   addUserKnob {26 divider4 l "" +STARTLINE}
   addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
   _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
   addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
   addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
   addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
   _expressions {{curve}}
   addUserKnob {26 divider0 l "" +STARTLINE}
   addUserKnob {20 dbinfo l "DB Info" n 1}
   dbinfo 0
   addUserKnob {1 twig_dnuuid l "Twig Id"}
   addUserKnob {1 stalk_dnuuid l "Stalk Id"}
   addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
   addUserKnob {1 leaf_dnuuid l "Leaf Id"}
   addUserKnob {26 divider1 l "" +STARTLINE}
   addUserKnob {1 twigtype l "Twig Type"}
   addUserKnob {1 leaf_label l Leaf}
   addUserKnob {1 ivy_version l Version}
   addUserKnob {43 ivy_notes l Notes}
   addUserKnob {26 divider2 l "" +STARTLINE}
   addUserKnob {1 build_label l "Build Label"}
   addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
  }
 end_group
 Switch {
  inputs 2
  which {{parent.connect_aux}}
  name Switch3
  xpos -324
  ypos 498
 }
set N16c4ace0 [stack 0]
push $N16ba92b0
 Expression {
  temp_name0 xd
  temp_expr0 red-Camera1.world_matrix.3
  temp_name1 yd
  temp_expr1 green-Camera1.world_matrix.7
  temp_name2 zd
  temp_expr2 blue-Camera1.world_matrix.11
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  expr3 Distance
  name Expression1
  xpos -456
  ypos -192
 }
 Grade {
  channels rgba
  blackpoint {{parent.FogFar}}
  whitepoint {{parent.FogNear}}
  gamma {{1/(parent.FogExponent+0.000000001)}}
  white_clamp true
  name Grade1
  xpos -456
  ypos -168
 }
push $N16b37730
 Dot {
  name Dot7
  xpos -307
  ypos -513
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge1
  xpos -341
  ypos -168
  disable {{!parent.Fog}}
 }
 Shuffle {
  name Shuffle3
  xpos -341
  ypos 8
 }
set N16c86e80 [stack 0]
 Shuffle {
  red white
  green white
  blue white
  name Shuffle2
  xpos -28
  ypos 76
 }
push $N16bd34f0
 BlinkScript {
  inputs 4
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Render/3D_PointRender_v18.cpp
  recompileCount 806
  ProgramGroup 1
  KernelDescription "2 \"PointRender3D\" iterate pixelWise b6c79b641c58390f32c944e2b5792a8702107f9cfc926636430288e7e0e1b392 5 \"ppos\" Read Random \"src\" Read Random \"normals\" Read Random \"occlusion\" Read Random \"dst\" Write Random 50 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"vertexformat\" Int 2 CgAAAAoAAAA= \"Zoom\" Float 1 AACAPw== \"Filtering Method\" Int 1 AQAAAA== \"_alphaMultiplier\" Float 1 AACAPw== \"_pointRender\" Bool 1 AQ== \"_wireRender\" Bool 1 AQ== \"_facetRender\" Bool 1 AQ== \"_maxLDistance\" Float 1 AACAPw== \"_maxLConnections\" Int 1 AQAAAA== \"_maxPlexType\" Int 1 AAAAAA== \"_plexLinedefXY\" Bool 1 AA== \"_plexLinedefX\" Bool 1 AA== \"_plexLinedefY\" Bool 1 AA== \"_plexLinedefXtoY\" Bool 1 AA== \"_plexLinedefAUX\" Bool 1 AA== \"_plexConnectX\" Bool 1 AA== \"_plexConnectY\" Bool 1 AA== \"_L_gamma\" Float 1 AACAPw== \"Enable Depth of Field\" Bool 1 AA== \"samples\" Int 1 AwAAAA== \"rings\" Int 1 BQAAAA== \"focalDepth\" Float 1 AACAPw== \"_depthOfField\" Float 1 AACAQA== \"_depthMult\" Float 1 zczMPQ== \"_maxDofSize\" Float 1 AAAAQQ== \"dof_aspect\" Float 1 AACAPw== \"dof_threshold\" Float 1 AACAPw== \"dof_gain\" Float 1 AAAAAA== \"dof_bias\" Float 1 AAAAwA== \"dof_fringe\" Float 1 AAAAAA== \"_flatshading\" Bool 1 AQ== \"_backfacing\" Bool 1 AQ== \"_frontfacing\" Bool 1 AQ== \"_vertexMode\" Int 1 AAAAAA== \"_depthBuffer\" Bool 1 AQ== \"_texoffset\" Float 2 AAAAPwAAAD8= \"_pointSize\" Int 1 AQAAAA== \"_gaussigma\" Float 1 AACAPw== \"_depthOcclusion\" Bool 1 AQ== \"depthMultiplier\" Float 1 AACAPw== \"_maxLineSteps\" Float 1 AAB6RQ== \"_lineOffset\" Float 1 AACAPw== \"_lineInMultiplier\" Float 1 AACAPw== \"_lineOutMultiplier\" Float 1 AACAPw== \"_overscan\" Float 2 AAAAAAAAAAA= \"isDepth\" Bool 1 AA== 50 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"Vformat\" 2 1 \"zoom\" 1 1 \"_filtering\" 1 1 \"_alphaMultiplier\" 1 1 \"_pointRender\" 1 1 \"_wireRender\" 1 1 \"_facetRender\" 1 1 \"_maxPlexDistance\" 1 1 \"_maxPlexConnections\" 1 1 \"_maxPlexType\" 1 1 \"_plexLinedefXY\" 1 1 \"_plexLinedefX\" 1 1 \"_plexLinedefY\" 1 1 \"_plexLinedefXtoY\" 1 1 \"_plexLinedefAUX\" 1 1 \"_plexConnectX\" 1 1 \"_plexConnectY\" 1 1 \"_plex_gamma\" 1 1 \"_dof_enable\" 1 1 \"_dof_samples\" 1 1 \"_dof_rings\" 1 1 \"focalDepth\" 1 1 \"_depthOfField\" 1 1 \"_depthMult\" 1 1 \"_maxDofSize\" 1 1 \"dof_aspect\" 1 1 \"dof_threshold\" 1 1 \"dof_gain\" 1 1 \"dof_bias\" 1 1 \"dof_fringe\" 1 1 \"_flatshading\" 1 1 \"_backfacing\" 1 1 \"_frontfacing\" 1 1 \"_vertexMode\" 1 1 \"_depthBuffer\" 1 1 \"_texoffset\" 2 1 \"_pointSize\" 1 1 \"_gaussigma\" 1 1 \"_depthOcclusion\" 1 1 \"depthMultiplier\" 1 1 \"_maxLineSteps\" 1 1 \"_lineOffset\" 1 1 \"_lineInMultiplier\" 1 1 \"_lineOutMultiplier\" 1 1 \"_overscan\" 2 1 \"isDepth\" 1 1 10 \"max_line_connections\" Int 1 1 AAAAAA== \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "//Some basic generic functions.\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float3 Cross(float3 A,float3 B)\n\{\n    return float3(A.y*B.z - A.z*B.y,A.z*B.x - A.x*B.z,A.x*B.y - A.y*B.x);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}     \n\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\ninline float mix(float _X,float _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}                                                                                              \n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n\n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight,\n    float2 overscan\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f-overscan.x || pRaster.x > imageWidth+overscan.x || \n       pRaster.y < 0.0f-overscan.y || pRaster.y > imageHeight+overscan.y || pRaster.z < 0.0f) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eRead, eAccessRandom, eEdgeClamped> src;     //The texture map\n  Image<eRead, eAccessRandom, eEdgeClamped> normals;     //The texture map  \n  Image<eRead, eAccessRandom, eEdgeClamped> occlusion;     //The texture map \n  Image<eWrite, eAccessRandom> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat,Vformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    int _filtering;        //Filter method\n    float _alphaMultiplier; //Additive multiplier\n    bool _pointRender,_wireRender,_facetRender;\n    float _maxPlexDistance; //Additive multiplier\n    int _maxPlexConnections;\n    int _maxPlexType; // 0==Grid, -1==Nearest\n    bool _plexLinedefXY,_plexLinedefX,_plexLinedefY,_plexLinedefXtoY,_plexLinedefAUX; // Define what connections NOT to include\n    bool _plexConnectX,_plexConnectY; //Connect from the edge of x to 0, or edge of y to 0, usually for spheres\n    float _plex_gamma; //The threshold making shorter paths bright and longer paths dark\n    bool _dof_enable; // Enable DOF\n    int _dof_samples; // How many samples per DOF ring\n    int _dof_rings; // How many rings \n    float focalDepth,_depthOfField,_depthMult,_maxDofSize; //DOF Settings\n    float dof_aspect; //Pixel aspect ratio\n    float dof_threshold;\n    float dof_gain;\n    float dof_bias; //bokeh edge bias\n    float dof_fringe; //bokeh chromatic aberration/fringing\n    bool _flatshading,_backfacing,_frontfacing; //Vertex rendering settings\n    int _vertexMode;  //The rendering output mode, (think AOV)\n    bool _depthBuffer; //Non-additive, only render front most pixel\n    float2 _texoffset;\n    int _pointSize;\n    float _gaussigma;\n    bool _depthOcclusion;\n    float depthMultiplier;\n    float _maxLineSteps; //cap the line length to avoid process lock\n    float _lineOffset; //Alow you to shrink or extend the lines\n    float _lineInMultiplier,_lineOutMultiplier; //Control the brightness of the wires at the tips.\n    float2 _overscan; //This will allow you to render some extra outside the bounds of the image.\n    bool isDepth; //This will allow you to render some extra outside the bounds of the image.\n\n  local: //Local variables\n    int max_line_connections;\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(Vformat,      \"vertexformat\", int2(10,10));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(_filtering, \"Filtering Method\", 1); \n    defineParam(_alphaMultiplier, \"_alphaMultiplier\", 1.0f);     \n    defineParam(_pointRender, \"_pointRender\", true);  \n    defineParam(_wireRender, \"_wireRender\", true);\n    defineParam(_facetRender, \"_facetRender\", true);\n    defineParam(_maxPlexDistance, \"_maxLDistance\", 1.0f);    \n    defineParam(_maxPlexConnections, \"_maxLConnections\", 1);    \n    defineParam(_maxPlexType, \"_maxPlexType\", 0); \n    defineParam(_plexLinedefXY, \"_plexLinedefXY\", false);      \n    defineParam(_plexLinedefXtoY, \"_plexLinedefXtoY\", false); //NYI\n    defineParam(_plexLinedefAUX, \"_plexLinedefAUX\", false); \n    defineParam(_plexLinedefX, \"_plexLinedefX\", false);  \n    defineParam(_plexLinedefY, \"_plexLinedefY\", false);  \n    defineParam(_plexConnectX, \"_plexConnectX\", false);      \n    defineParam(_plexConnectY, \"_plexConnectY\", false);   \n    defineParam(_plex_gamma, \"_L_gamma\", 1.0f);\n    //DOF SETTINGS   \n    defineParam(_dof_enable, \"Enable Depth of Field\", false);   \n    defineParam(_dof_samples, \"samples\", 3);    \n    defineParam(_dof_rings, \"rings\", 5);   \n    defineParam(focalDepth, \"focalDepth\", 1.0f);  \n    defineParam(_depthOfField, \"_depthOfField\", 4.0f);  \n    defineParam(_depthMult, \"_depthMult\", 0.1f);  \n    defineParam(_maxDofSize, \"_maxDofSize\", 8.0f);  \n    defineParam(dof_aspect, \"dof_aspect\", 1.0f);  \n    defineParam(dof_threshold, \"dof_threshold\", 1.0f);  \n    defineParam(dof_gain, \"dof_gain\", 0.0f);  \n    defineParam(dof_bias, \"dof_bias\", -2.0f);  \n    defineParam(dof_fringe, \"dof_fringe\", 0.0f); \n    //SHADING SETTINGS \n    defineParam(_flatshading, \"_flatshading\", true);  \n    defineParam(_vertexMode, \"_vertexMode\", 0);  \n    defineParam(_backfacing, \"_backfacing\", true);    \n    defineParam(_frontfacing, \"_frontfacing\", true);        \n    defineParam(_depthBuffer, \"_depthBuffer\", true);  \n    defineParam(_texoffset, \"_texoffset\", float2(0.5f,0.5f)); \n    defineParam(_pointSize, \"_pointSize\", 1); \n    defineParam(_gaussigma, \"_gaussigma\", 1.0f); \n    defineParam(_depthOcclusion, \"_depthOcclusion\", true); \n    defineParam(depthMultiplier, \"depthMultiplier\", 1.0f); \n    defineParam(_maxLineSteps, \"_maxLineSteps\", 4000.0f); \n    defineParam(_lineOffset, \"_lineOffset\", 1.0f); \n    defineParam(_lineInMultiplier, \"_lineInMultiplier\", 1.0f);   \n    defineParam(_lineOutMultiplier, \"_lineOutMultiplier\", 1.0f);     \n    defineParam(_overscan, \"_overscan\",float2(0.0f,0.0f));    \n\n  \}\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    max_line_connections = 80;\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n  \}\n\n  //Convert a 3d point position into a 2d raster position.\n  float3 Reconsile3D(float3 _PointPos)\{\n      vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      return tRaster;\n  \}\n\n//------------------------------\n//-------DRAW FUNCTIONS---------\n//------------------------------\n  //Write pixels to output.\n  void writepixel(float posx,float posy, float4 color,int index,float weight=1.0f)\n  \{ \n      if (_depthOcclusion)\{\n        float4 depthSample = occlusion(posx,posy);\n        if (depthSample.x<=vRaster.z && depthSample.w>0.0f)\{\n\n          float depth = (vRaster.z-depthSample.x);\n          color = color*(1.0f-depthSample.w);\n          color = color / (((depth*depth)*depthMultiplier)+1.0f);\n          //return;\n        \}\n      \}\n      float4 finalOutput; //This is used to store the final output\n      float4 dstSample; //This is used to store a sample of the destination\n      if ( dst.bounds.inside( posx, posy ) ) \{ //Test if the pixel written to is inside the output image. \n        if (_depthBuffer) \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          if ((dstSample.w>color.w)||dstSample.w==0.0f) \{\n            dst(posx,posy) = color;\n          \}\n        \}\n        else \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          finalOutput = dstSample + (color*_alphaMultiplier*weight);\n          finalOutput.w = dstSample.w + ((color.w*_alphaMultiplier*weight));\n\n          finalOutput.w = (dstSample.w + ((color.w*_alphaMultiplier*weight)))-(dstSample.w * ((color.w*_alphaMultiplier*weight)));\n\n          dst(posx,posy) = finalOutput;\n        \}\n      \} \n  \}\n\n  //Calculate a Bilinear Plot\n  void bilinear_Plot(float2 temppos,float4 color,int index)\n  \{\n    float2 p;\n    p.x=Frac(temppos.x);\n    p.y=Frac(temppos.y);\n    float weights\[] = \{(1.0f-p.x)*(1.0f-p.y), p.x*(1.0f-p.y), (1.0f-p.x)*p.y, p.x*p.y\};\n    int2 _position = int2(floor(temppos.x)-0,floor(temppos.y)-0); \n    writepixel(_position.x,_position.y,color,index,weights\[0]);\n    writepixel(_position.x+1,_position.y,color,index,weights\[1]);\n    writepixel(_position.x,_position.y+1,color,index,weights\[2]);\n    writepixel(_position.x+1,_position.y+1,color,index,weights\[3]);\n  \}\n\n  //NYI, unused!\n  void gaussian(float2 temppos,float4 color,int index)\{\n    float in_x = temppos.x;\n    float in_y = temppos.y;\n    int kernelSize = (_pointSize+1)*2;\n    int subsize = (kernelSize /2)-1;\n    float gKernel\[64]\[64];\n    float sigma = _gaussigma;\n    float intSigma = float(_pointSize);\n    float r, s = intSigma * sigma * sigma;\n\n    float sum = 0.0f;\n\n    // generate 5x5 kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            r = float(sqrt(x*x + y*y));\n            gKernel\[x + subsize]\[y + subsize] = (exp(-(r*r)/s))/(3.141592654f * s);\n            sum += gKernel\[x + subsize]\[y + subsize];\n        \}\n    \}\n\n    // normalize the Kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            gKernel\[x + subsize]\[y + subsize] /= sum;\n            writepixel(in_x+x,in_y+y,color,index,gKernel\[x + subsize]\[y + subsize]);\n        \}\n    \}\n  \}\n\n//-------------------------------------\n// DrawLine\n// ----------\n// Draw a line between two points, \n// x,y being 2d screenspace pos and z being depth.\n//-------------------------------------\n  void DrawLine(float3 origin, float3 endpoint,float4 _colorA,float4 _colorB) \{\n    float4 _color;\n    float3 delta = origin-endpoint;\n    float3 curPoint = origin;\n    float mag = sqrt(delta.x*delta.x+delta.y*delta.y);\n    mag = min(mag,_maxLineSteps); //Lets not go crazy, we cap it at 10.000 to avoid insane unwated processing time \n    for( float a = 0; a < mag*_lineOffset; a = a + 1.0f )\{\n      curPoint -= (delta/mag);\n      _color = (_colorA*(1.0f-(a/mag*1.0f)))+(_colorB*(a/mag*1.00f));\n      if (_dof_enable)\{\n        Bokeh(curPoint,_color);\n      \}\n      else \{\n        if (_depthBuffer && isDepth) \{_color = float4(1.0f,1.0f,1.0f,curPoint.z);\} //Added\n        bilinear_Plot(float2(curPoint.x,curPoint.y),_color,1);\n      \}\n      \n    \}\n  \}\n\n//-------------------------------------\n// Point_Render\n//-------------------------------------\nvoid point_render(int2 pos, float3 screen_pos)\{\n  float4 color = src(pos.x,pos.y);\n\n  if (_filtering == 1)\{\n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        if (_depthBuffer) \{color.w = screen_pos.z;\} //Added\n        bilinear_Plot(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  /*\n  //THIS PART NEEDS TO BE RE-WRITTEN.\n  else if (_filtering == 2)\{ \n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        gaussian(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  */\n  else \{\n      int2 _position = int2(floor(screen_pos.x),floor(screen_pos.y)); \n      if (_depthBuffer) \{color.w = screen_pos.z;\}\n      writepixel(_position.x,_position.y, color,1,1.0f); //OutputSample\n  \}\n\n\}\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nvoid facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x+1,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos,V0_N,V1_N,V2_N;\n    float2 V0_ST,V1_ST,V2_ST;\n    float4 V1_Sample,V2_Sample;\n    float4 _tn;\n    float3 normal0,normal1,normal2;\n    float2 UV_Format = float2(Vformat.x,Vformat.y);\n\n\n    int2 P0 = int2(pos.x-1,pos.y-1);\n    int2 P1 = int2(pos.x+1,pos.y+1);\n    if (_plexConnectX && pos.x == int(Vformat.x))\{\n      insideX == true;\n      P1 = int2(0.0f,pos.y+1);\n    \}\n    if (_plexConnectY && pos.y == int(Vformat.y))\{\n      insideYtop == true;\n      P1 = int2(pos.x+1,0);\n    \} \n\n    if (_plexConnectY && pos.y == 0)\{\n      insideY == true;\n      P0 = int2(pos.x-1,int(UV_Format.y));\n    \} \n\n    if (!_flatshading) \{\n      _tn = normals(pos.x,pos.y);\n      V0_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n    V0_ST = float2(pos.x,pos.y)/UV_Format;\n\n  if (insideX) \{\n    V2_Sample = ppos(P1.x,pos.y);\n    V2_ST = float2(P1.x,pos.y)/UV_Format;\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (!_flatshading) \{\n      _tn = normals(P1.x,pos.y);\n      V2_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n        \n\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(P1.x,P0.y);\n        V1_ST = float2(P1.x,P0.y)/UV_Format;\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(P1.x,P0.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}\n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V2_Pos,V1_Pos,_vWorld,V2_wPos,V1_wPos,V0_N,V2_N,V1_N,V0_ST,V2_ST,V1_ST);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,P1.y);\n        V1_ST = float2(pos.x,P1.y)/UV_Format;        \n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(pos.x,P1.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}        \n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V1_Pos,V2_Pos,_vWorld,V1_wPos,V2_wPos,V0_N,V1_N,V2_N,V0_ST,V1_ST,V2_ST);\n        \}\n      \}\n    \}\n  \}\n\}\n\n\n\n//This function will calculate if pixel C is inside the triangle\nfloat edgeFunction(float3 a, float3 b, float3 c) \n\{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n\} \n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat Distance(float3 _a,float3 _b)\n\{\n          float xd = _a.x - _b.x;\n          float yd = _a.y - _b.y;\n          float zd = _a.z - _b.z;\n          return sqrt(xd*xd + yd*yd + zd*zd);\n\}\n\nvoid DrawTriangle(float3 V0, float3 V1, float3 V2,float3 WP0, float3 WP1, float3 WP2,float3 N0, float3 N1, float3 N2, float2 st0,float2 st1,float2 st2) \{\n\n  // Precompute reciprocal of vertex z-coordinate \n  V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n\n  float2 st0n = st0 * V0.z;\n  float2 st1n = st1 * V1.z; \n  float2 st2n = st2 * V2.z; //Normal version of ST\n\n  bool inside; \n  float X0 = Fmin(V0.x,V1.x,V2.x)-1.0f;\n  float X1 = Fmax(V0.x,V1.x,V2.x)+1.0f;\n  float Y0 = Fmin(V0.y,V1.y,V2.y)-1.0f;\n  float Y1 = Fmax(V0.y,V1.y,V2.y)+1.0f;\n  float area = edgeFunction(V2, V1, V0);\n\n\n  float2 sampos = float2(st0.x*float(Vformat.x),st0.y*float(Vformat.y));\n  float4 text0 = src(sampos.x,sampos.y);\n  sampos = float2(st1.x*float(Vformat.x),st1.y*float(Vformat.y));\n  float4 text1 = src(sampos.x,sampos.y);\n  sampos = float2(st2.x*float(Vformat.x),st2.y*float(Vformat.y));  //Why do we have to do this? =(\n  float4 text2 = src(sampos.x,sampos.y);\n  sampos = float2(min(min(st0.x,st1.x),st2.x)*float(Vformat.x),min(min(st0.y,st1.y),st2.y)*float(Vformat.y));\n  float4 text3 = src(sampos.x,sampos.y);\n\n\n  for( int x = X0; x < X1 ; x++) \{\n    for( int y = Y0; y < Y1 ; y++) \{\n      float3 pixelSample(x + _texoffset.x, y + _texoffset.y,0.0f); \n\n      //This is the part where we test if the current pixel is inside the triangle\n      //We check both for front facing and back faing options\n      float w0 = edgeFunction(V1, V0, pixelSample); //Front Facing\n      float w1 = edgeFunction(V2, V1, pixelSample); \n      float w2 = edgeFunction(V0, V2, pixelSample); \n      float w3 = edgeFunction(V0, V1, pixelSample); //Back Facing\n      float w4 = edgeFunction(V1, V2, pixelSample); \n      float w5 = edgeFunction(V2, V0, pixelSample);\n\n      //writepixel(x,y, float4(w1),1,1.0f);\n      if ((w0 >= 0 && w1 >= 0 && w2 >= 0 && _frontfacing) || (w3 >= 0 && w4 >= 0 && w5 >= 0 && _backfacing)) \{ //The curent pixel is inside the triangle\n\n       // calculate vectors from point f to vertices p1, p2 and p3:\n       float3 f1 = V0-pixelSample;\n       float3 f2 = V1-pixelSample;\n       float3 f3 = V2-pixelSample;\n       // calculate the areas and factors (order of parameters doesn't matter):\n       float a = length(cross(V0-V1,V0-V2 )); // main triangle area a\n       area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n        w0 /= area; \n        w1 /= area; \n        w2 /= area; \n\n        w3 /= area; \n        w4 /= area; \n        w5 /= area; \n\n       float a1 = length(cross(f2, f3)) / a; // p1's triangle area / a\n       float a2 = length(cross(f3, f1)) / a; // p2's triangle area / a \n       float a3 = length(cross(f1, f2)) / a; // p3's triangle area / a\n       float a_magnitude = a1+a2+a3;\n       a1 = a1/a_magnitude;\n       a2 = a2/a_magnitude;\n       a3 = a3/a_magnitude;\n       float z = 1.0f / (V0.z * a1 + V1.z * a2 + V2.z * a3); \n\n\n        // find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):\n        float2 uv = st0 * a1 + st1 * a2 + st2 * a3;\n        float2 st = st0 * w0 + st1 * w1 + st2 * w2; \n        st *= z;      \n\n\n        //Calculate normals. Eighter we have flat shading, else we calculate a normal per pixel\n        float3 normalB;\n        if (_flatshading) \{\n          normalB = CalculateSurfaceNormals(WP0,WP1,WP2);\n\n        \}\n        else \{\n          float3 c0 = N2/float3(V0.z); \n          float3 c1 = N0/float3(V1.z); \n          float3 c2 = N1/float3(V2.z);  \n\n          normalB.x = w0 * c0.x + w1 * c1.x + w2 * c2.x; \n          normalB.y = w0 * c0.y + w1 * c1.y + w2 * c2.y; \n          normalB.z = w0 * c0.z + w1 * c1.z + w2 * c2.z; \n\n          normalB.x *= z, normalB.y *= z, normalB.z *= z; \n        \}\n        normalB = normalize(normalB);\n\n        //CALCULATE THE OBJECT TEXTURE COORDINATES\n        float zn = 1.0f / (V0.z * w0 + V1.z * w1 + V2.z * w2); \n        st = st0n * w0 + st1n * w1 + st2n * w2; \n        st *= zn;   \n        //--END \n\n        float3 Wpos = WP0*a1 + WP1*a2 + WP2*a3; //World Position.\n        float3 ViewNormal = normalize(float3(cameraToWorld\[3]\[0],cameraToWorld\[3]\[1],cameraToWorld\[3]\[2])-Wpos);\n\n        float nDotView =  dot(normalB,ViewNormal);\n        nDotView = 1.0f-fabs(nDotView); //make sure that the view normal ramps back around when doing backface\n        float4 tempout;\n\n        //Flatshading or regular?\n        if (!_flatshading) \{\n          tempout = text0 * a1 + text1 * a2 + text2 * a3; \n        \}\n        else\{\n          tempout = text3;\n        \}\n\n        //Additional Render Modes\n        if (_vertexMode == 1)\{\n          tempout = float4(a1,a2,a3,1.0f);\n        \}\n        else if (_vertexMode == 2)\{\n          tempout = float4(normalB.x,normalB.y,normalB.z,1.0f);\n        \}\n        else if (_vertexMode == 3)\{\n          tempout = float4(nDotView,nDotView,nDotView,1.0f);\n        \}\n        else if (_vertexMode == 4)\{\n          tempout = float4(uv.x,uv.y,0.0f,1.0f);\n        \}       \n        else if (_vertexMode == 5)\{\n          tempout = float4(st.x,st.y,0.0f,1.0f);\n        \}               \n        else if (_vertexMode == 6)\{\n          tempout = float4(ViewNormal.x,ViewNormal.y,ViewNormal.z,1.0f);\n        \}             \n        else if (_vertexMode == 7)\{\n          tempout = float4(Wpos.x,Wpos.y,Wpos.z,1.0f);\n        \}   \n\n        if (_depthBuffer)\{\n          writepixel(x,y, float4(tempout.x,tempout.y,tempout.z,z),1,1.0f);  \n        \}\n        else \{\n          if (_dof_enable)\{\n            Bokeh(float3(x,y,z),float4(tempout.x,tempout.y,tempout.z,z));\n          \}\n          else \{\n            bilinear_Plot(float2(x,y),float4(tempout.x,tempout.y,tempout.z,z),1);\n          \}\n        \}\n\n      \}  \n\n    \}\n  \}\n\}\n\n//-------------------------------------\n// Wire_Render\n//-------------------------------------\nvoid wire_render(int2 pos) \{\n  float4 temp = float4(0.0f,0.0f,0.0f,FLT_MAX);\n  float4 wire_ref_sample;\n  int2 tempXY = int2(0,0);\n  float4 plexlist\[11] = \{temp,temp,temp,temp,temp,temp,temp,temp,temp,temp,temp\}; \n  int2 plexlistXY\[11] = \{tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY\};\n  int plex_count = 0; //We use this to figure how many points that should connect.\n  float plex_dist;\n  float3 plex_position,plex_position_b;\n  float4 temp_pos, temp_pos_b; //Temporary Position Containers\n  if (_maxPlexType == -1) \{ //Used for random connection types\n    for( int x = 0; x < max_line_connections ; x++)\{ //THIS 80 NUMBER IS THE LIMIT TO AVOID TOO SLOW PROCESSING!\n      for( int y = 0; y < max_line_connections ; y++)\{\n        wire_ref_sample = ppos(x,y);\n        if (wire_ref_sample.w != 0.0f && pos.x!=x && pos.y != y) \{ \n          plex_position = float3(wire_ref_sample.x,wire_ref_sample.y,wire_ref_sample.z)*(zoom);\n          float xd = plex_position.x - vWorld.x;\n          float yd = plex_position.y - vWorld.y;\n          float zd = plex_position.z - vWorld.z;\n          float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n          if (plex_dist<_maxPlexDistance)\{\n            plex_count = min(10,plex_count+1); //Add one to the count\n            for( int h = 0; h < plex_count+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n              if (plex_dist < plexlist\[h].w) \{                  \n                for( int i = plex_count+1; i > h ; i--) \{\n                  plexlist\[i] = plexlist\[i-1];\n                  plexlistXY\[i] = plexlistXY\[i-1];\n                \}\n                plexlist\[h] = float4(plex_position.x,plex_position.y,plex_position.z,plex_dist);\n                plexlistXY\[h] = int2(x,y);\n                break;        \n              \}\n            \}\n          \} \n        \}\n      \}\n    \}\n  \}\n  else\{ //Used for standard connection types\n    float4 temp_pos;\n    bool insideX = !(Vformat.x < pos.x+1);\n    bool insideY = !(Vformat.y < pos.y+1);\n\n\n    if (!_plexLinedefAUX)\{\n      temp_pos = normals(pos.x,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,vWorld+plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideX && !_plexLinedefX) \{\n      temp_pos = ppos(pos.x+1,pos.y );\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && !_plexLinedefX) \{\n      temp_pos = ppos(0,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideY && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\}                          \n    \}\n    else if ( _plexConnectY  && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,0);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    //_plexConnect\n    if ( insideX && insideY && !_plexLinedefXY) \{              \n      temp_pos = ppos(pos.x+1,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && _plexConnectY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && insideY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectY && insideX && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n  \}   \n\n  //now that all the connections have been sorted by distance then we connect the dots.\n  for( int x = 0; x < min(_maxPlexConnections,plex_count) ; x++)\{\n    plex_position = float3(plexlist\[x].x,plexlist\[x].y,plexlist\[x].z);\n    plex_dist = plexlist\[x].w;\n\n\n    float plex_distribution = 1.0f-((plexlist\[x].w-plexlist\[0].w)/((plexlist\[min(_maxPlexConnections,plex_count)].w-plexlist\[0].w)+0.00001f)); //Where does it lie between the best and the worst distance?\n    //plexlistXY\n\n    float4 plex_col = float4(pow(1.0f-(plex_dist/_maxPlexDistance),1.0f/_plex_gamma))*float4(plex_distribution); //This one is quite cool aswell, but does leave the center ones a bit too focused \n    float4 plex_colorA = src(pos.x,pos.y);\n    float4 plex_colorB = src( plexlistXY\[x].x,plexlistXY\[x].y);\n    plex_col *= 0.1f;\n\n    computePixelCoordinates(plex_position, pRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n    if (dst.bounds.inside(int(vRaster.x),int(vRaster.y)) || dst.bounds.inside(int(pRaster.x),int(pRaster.y)))\{\n        DrawLine(vRaster,pRaster,(plex_colorA*plex_col)*_lineInMultiplier,(plex_colorB*plex_col)*_lineOutMultiplier);\n    \}\n  \}\n\}\n\nvoid wire_connection(float3 p_source,float3 p_target, float4 (&p_plexlist)\[11], int2 (&p_plexlistXY)\[11],int &p_plexcount,int2 position) \{\n  float xd = p_target.x - p_source.x;\n  float yd = p_target.y - p_source.y;\n  float zd = p_target.z - p_source.z;\n  float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n  if (plex_dist<_maxPlexDistance)\{\n    p_plexcount = min(11,p_plexcount+1); //Add one to the count\n    for( int h = 0; h < p_plexcount+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n      if (plex_dist < p_plexlist\[h].w) \{                  \n        for( int i = p_plexcount+1; i > h ; i--) \{\n          p_plexlist\[i] = p_plexlist\[i-1];\n          p_plexlistXY\[i] = p_plexlistXY\[i-1];\n        \}\n        p_plexlist\[h] = float4(p_target.x,p_target.y,p_target.z,plex_dist);\n        p_plexlistXY\[h] = int2(position.x,position.y);\n        break;        \n      \}\n    \}  \n  \}\n\}\n//-------END OF WIRE RENDER FUNCTIONS---------\n\n\n\n\n//-------------------------------\n//-------BOKEH FUNCTIONS---------\n//thanks to: http://devlog-martinsh.blogspot.dk/2011/11/glsl-depth-of-field-with-bokeh-v21.html\nfloat2 rand(float2 coord) //generating noise/pattern texture for dithering\n\{\n  float noiseX = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.25)+(Frac(coord.y*(WHformat\[1]/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.75)+(Frac(coord.y*(WHformat\[1]/2.0))*0.25))*2.0-1.0;\n  noiseX = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f))) * 43758.5453f),0.0f,1.0f)*2.0f-1.0f;\n  noiseY = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f)*2.0f)) * 43758.5453f),0.0f,1.0f)*2.0-1.0f;\n  return float2(noiseX,noiseY);\n\}\n//-------------------------------------\n// Bokeh\n//-------------------------------------\nvoid Bokeh(float3 pos,float4 color)\{\n  float blur = 0.0;\n  blur = clamp((fabs(pos.z - focalDepth)/_depthOfField)*100.0f,-_maxDofSize,_maxDofSize);\n  \n  float w = (1.0/WHformat.x)*blur;//+noise.x;\n  float h = (1.0/(WHformat.x*dof_aspect))*blur;//+noise.y;\n  float3 v3_col = float3(color.x,color.y,color.z);\n  int ringsamples;\n  float s = 1.0;  \n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples; \n    for (int j = 0 ; j < ringsamples ; j += 1)  \n    \{ \n      s += (1.0f*mix(1.0f,(float(i))/(float(_dof_rings)),dof_bias)*1.0f); //No need to do this in the loop\n    \}\n  \}\n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples;\n     \n    for (int j = 0 ; j < ringsamples ; j += 1)   \n    \{\n      float step = PI*2.0 / float(ringsamples);\n      float pw = (cos(float(j)*step)*(float(i)/_dof_rings));\n      float ph = (sin(float(j)*step)*(float(i)/_dof_rings));\n      float p = 1.0;\n\n      float posx = pos.x+((pw*w)*blur);\n      float posy = pos.y+((ph*h)*blur);\n\n\n      float3 lumcoeff = float3(0.299,0.587,0.114);\n      float lum = dot(v3_col, lumcoeff);\n      float thresh = max((lum-dof_threshold)*dof_gain, 0.0f);\n      v3_col+mix(float3(0.0),v3_col,thresh*blur);\n\n      float3 col = (v3_col*mix(1.0,(float(i))/(float(_dof_rings)),dof_bias)*p)/s; \n      bilinear_Plot(float2(posx,posy),float4(col.x,col.y,col.z,color.w/(_dof_rings*_dof_rings)),1);\n    \}\n  \}\n\}\n//-------END OF BOKEH FUNCTIONS---------\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float2 posf = float2(pos.x,pos.y);\n\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n\n      //Convert worldspace coordinates to screenspcace coordinates.\n      vWorld = float3(_sample.x,_sample.y,_sample.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, vRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      if (ret) \{ //Only create points that are visible on screen\n        if (_pointRender)\{\n          point_render(pos,vRaster);\n        \}\n      \} //Pointrender over\n\n      if (_wireRender && _maxPlexConnections>=1) \{\n        if (max(pos.x,pos.y)<=max_line_connections || (_maxPlexType==0))\{ // Don't process more wires than allowed in nearest mode.\n          wire_render(pos);\n        \}\n      \} //WireRender over\n\n      if (_facetRender) \{\n        facet_render(pos,float3(_sample.x,_sample.y,_sample.z));\n      \}  //FacetRender over\n      \n    \}\n  \} //----> process\n\};\n"
  useGPUIfAvailable false
  rebuild ""
  PointRender3D_cam_Matrix {
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
    }
  PointRender3D_focallength {{parent.Camera1.focal}}
  PointRender3D_hapeture {{parent.Camera1.haperture}}
  PointRender3D_format {{!proxy?Settings_Format.width:Settings_Format.width*proxy_scale} {!proxy?Settings_Format.height:Settings_Format.height*proxy_scale}}
  PointRender3D_vertexformat {{parent.InputFormat.box.r-1} {parent.InputFormat.box.t-1}}
  PointRender3D__alphaMultiplier {{parent.AlphaMultiplier}}
  PointRender3D__pointRender {{parent.RenderMode==0}}
  PointRender3D__wireRender {{parent.RenderMode==1}}
  PointRender3D__facetRender {{parent.RenderMode==2}}
  PointRender3D__maxLDistance {{parent.wire_maxdistance}}
  PointRender3D__maxLConnections {{parent.wire_connections}}
  PointRender3D__maxPlexType {{-parent.wire_type}}
  PointRender3D__plexLinedefXY {{!parent.connect_xy}}
  PointRender3D__plexLinedefX {{!parent.connect_x}}
  PointRender3D__plexLinedefY {{!parent.connect_y}}
  PointRender3D__plexLinedefAUX {{!connect_aux}}
  PointRender3D__plexConnectX {{parent.CloseX}}
  PointRender3D__plexConnectY {{parent.CloseY}}
  PointRender3D__L_gamma {{parent.wire_Threshold}}
  "PointRender3D_Enable Depth of Field" {{parent.dof_enable}}
  PointRender3D_samples {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_rings {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_focalDepth {{parent.dof_focaldepth}}
  PointRender3D__depthOfField {{parent.dof_dof}}
  PointRender3D__depthMult 0
  PointRender3D__maxDofSize {{parent.dof_maxSize*400}}
  PointRender3D_dof_aspect {{parent.dof_Aspect}}
  PointRender3D_dof_bias {{parent.dof_bias}}
  PointRender3D__flatshading {{parent.facet_flatShading}}
  PointRender3D__backfacing {{parent.facet_backface}}
  PointRender3D__frontfacing {{parent.facet_front}}
  PointRender3D__vertexMode {{parent.renderMode}}
  PointRender3D__texoffset {-0.5 0.5}
  PointRender3D__pointSize 0
  PointRender3D__depthOcclusion {{parent.UseOcclusionMap}}
  PointRender3D__maxLineSteps {{parent.maxSamples}}
  PointRender3D__lineOffset {{parent.lineoffset}}
  PointRender3D__lineInMultiplier {{parent.inGain}}
  PointRender3D__lineOutMultiplier {{parent.outGain}}
  PointRender3D__overscan {{parent.overscan} {parent.overscan}}
  PointRender3D_isDepth true
  format "1280 720 0 0 1280 720 1 HD_720"
  rebuild_finalise ""
  name BlinkScriptZdepth
  label Zdepth
  xpos -28
  ypos 100
 }
 Dot {
  name Dot10
  xpos 97
  ypos 112
 }
 TimeBlur {
  divisions {{parent.Samples}}
  shutter {{parent.Shutter}}
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur1
  xpos 63
  ypos 300
  disable {{1-parent.mb_enable x89 0}}
 }
 Expression {
  expr3 a!=0?a/r:0
  name Expression3
  selected true
  xpos 63
  ypos 324
 }
 Dot {
  name Dot9
  xpos 97
  ypos 414
 }
push $N16b82e00
push $N16c4ace0
push $N16c86e80
push $N16bd34f0
 BlinkScript {
  inputs 4
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Render/3D_PointRender_v17.cpp
  recompileCount 803
  ProgramGroup 1
  KernelDescription "2 \"PointRender3D\" iterate pixelWise 0c100cf8a634aa2c2e18f544ec8abfd6d5d138cc25ae8f7d7127230910c2e91f 5 \"ppos\" Read Random \"src\" Read Random \"normals\" Read Random \"occlusion\" Read Random \"dst\" Write Random 49 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"vertexformat\" Int 2 CgAAAAoAAAA= \"Zoom\" Float 1 AACAPw== \"Filtering Method\" Int 1 AQAAAA== \"_alphaMultiplier\" Float 1 AACAPw== \"_pointRender\" Bool 1 AQ== \"_wireRender\" Bool 1 AQ== \"_facetRender\" Bool 1 AQ== \"_maxLDistance\" Float 1 AACAPw== \"_maxLConnections\" Int 1 AQAAAA== \"_maxPlexType\" Int 1 AAAAAA== \"_plexLinedefXY\" Bool 1 AA== \"_plexLinedefX\" Bool 1 AA== \"_plexLinedefY\" Bool 1 AA== \"_plexLinedefXtoY\" Bool 1 AA== \"_plexLinedefAUX\" Bool 1 AA== \"_plexConnectX\" Bool 1 AA== \"_plexConnectY\" Bool 1 AA== \"_L_gamma\" Float 1 AACAPw== \"Enable Depth of Field\" Bool 1 AA== \"samples\" Int 1 AwAAAA== \"rings\" Int 1 BQAAAA== \"focalDepth\" Float 1 AACAPw== \"_depthOfField\" Float 1 AACAQA== \"_depthMult\" Float 1 zczMPQ== \"_maxDofSize\" Float 1 AAAAQQ== \"dof_aspect\" Float 1 AACAPw== \"dof_threshold\" Float 1 AACAPw== \"dof_gain\" Float 1 AAAAAA== \"dof_bias\" Float 1 AAAAwA== \"dof_fringe\" Float 1 AAAAAA== \"_flatshading\" Bool 1 AQ== \"_backfacing\" Bool 1 AQ== \"_frontfacing\" Bool 1 AQ== \"_vertexMode\" Int 1 AAAAAA== \"_depthBuffer\" Bool 1 AQ== \"_texoffset\" Float 2 AAAAPwAAAD8= \"_pointSize\" Int 1 AQAAAA== \"_gaussigma\" Float 1 AACAPw== \"_depthOcclusion\" Bool 1 AQ== \"depthMultiplier\" Float 1 AACAPw== \"_maxLineSteps\" Float 1 AAB6RQ== \"_lineOffset\" Float 1 AACAPw== \"_lineInMultiplier\" Float 1 AACAPw== \"_lineOutMultiplier\" Float 1 AACAPw== \"_overscan\" Float 2 AAAAAAAAAAA= 49 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"Vformat\" 2 1 \"zoom\" 1 1 \"_filtering\" 1 1 \"_alphaMultiplier\" 1 1 \"_pointRender\" 1 1 \"_wireRender\" 1 1 \"_facetRender\" 1 1 \"_maxPlexDistance\" 1 1 \"_maxPlexConnections\" 1 1 \"_maxPlexType\" 1 1 \"_plexLinedefXY\" 1 1 \"_plexLinedefX\" 1 1 \"_plexLinedefY\" 1 1 \"_plexLinedefXtoY\" 1 1 \"_plexLinedefAUX\" 1 1 \"_plexConnectX\" 1 1 \"_plexConnectY\" 1 1 \"_plex_gamma\" 1 1 \"_dof_enable\" 1 1 \"_dof_samples\" 1 1 \"_dof_rings\" 1 1 \"focalDepth\" 1 1 \"_depthOfField\" 1 1 \"_depthMult\" 1 1 \"_maxDofSize\" 1 1 \"dof_aspect\" 1 1 \"dof_threshold\" 1 1 \"dof_gain\" 1 1 \"dof_bias\" 1 1 \"dof_fringe\" 1 1 \"_flatshading\" 1 1 \"_backfacing\" 1 1 \"_frontfacing\" 1 1 \"_vertexMode\" 1 1 \"_depthBuffer\" 1 1 \"_texoffset\" 2 1 \"_pointSize\" 1 1 \"_gaussigma\" 1 1 \"_depthOcclusion\" 1 1 \"depthMultiplier\" 1 1 \"_maxLineSteps\" 1 1 \"_lineOffset\" 1 1 \"_lineInMultiplier\" 1 1 \"_lineOutMultiplier\" 1 1 \"_overscan\" 2 1 10 \"max_line_connections\" Int 1 1 AAAAAA== \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "//Some basic generic functions.\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float3 Cross(float3 A,float3 B)\n\{\n    return float3(A.y*B.z - A.z*B.y,A.z*B.x - A.x*B.z,A.x*B.y - A.y*B.x);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}     \n\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\ninline float mix(float _X,float _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}                                                                                              \n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n\n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight,\n    float2 overscan\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f-overscan.x || pRaster.x > imageWidth+overscan.x || \n       pRaster.y < 0.0f-overscan.y || pRaster.y > imageHeight+overscan.y || pRaster.z < 0.0f) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eRead, eAccessRandom, eEdgeClamped> src;     //The texture map\n  Image<eRead, eAccessRandom, eEdgeClamped> normals;     //The texture map  \n  Image<eRead, eAccessRandom, eEdgeClamped> occlusion;     //The texture map \n  Image<eWrite, eAccessRandom> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat,Vformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    int _filtering;        //Filter method\n    float _alphaMultiplier; //Additive multiplier\n    bool _pointRender,_wireRender,_facetRender;\n    float _maxPlexDistance; //Additive multiplier\n    int _maxPlexConnections;\n    int _maxPlexType; // 0==Grid, -1==Nearest\n    bool _plexLinedefXY,_plexLinedefX,_plexLinedefY,_plexLinedefXtoY,_plexLinedefAUX; // Define what connections NOT to include\n    bool _plexConnectX,_plexConnectY; //Connect from the edge of x to 0, or edge of y to 0, usually for spheres\n    float _plex_gamma; //The threshold making shorter paths bright and longer paths dark\n    bool _dof_enable; // Enable DOF\n    int _dof_samples; // How many samples per DOF ring\n    int _dof_rings; // How many rings \n    float focalDepth,_depthOfField,_depthMult,_maxDofSize; //DOF Settings\n    float dof_aspect; //Pixel aspect ratio\n    float dof_threshold;\n    float dof_gain;\n    float dof_bias; //bokeh edge bias\n    float dof_fringe; //bokeh chromatic aberration/fringing\n    bool _flatshading,_backfacing,_frontfacing; //Vertex rendering settings\n    int _vertexMode;  //The rendering output mode, (think AOV)\n    bool _depthBuffer; //Non-additive, only render front most pixel\n    float2 _texoffset;\n    int _pointSize;\n    float _gaussigma;\n    bool _depthOcclusion;\n    float depthMultiplier;\n    float _maxLineSteps; //cap the line length to avoid process lock\n    float _lineOffset; //Alow you to shrink or extend the lines\n    float _lineInMultiplier,_lineOutMultiplier; //Control the brightness of the wires at the tips.\n    float2 _overscan; //This will allow you to render some extra outside the bounds of the image.\n\n  local: //Local variables\n    int max_line_connections;\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(Vformat,      \"vertexformat\", int2(10,10));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(_filtering, \"Filtering Method\", 1); \n    defineParam(_alphaMultiplier, \"_alphaMultiplier\", 1.0f);     \n    defineParam(_pointRender, \"_pointRender\", true);  \n    defineParam(_wireRender, \"_wireRender\", true);\n    defineParam(_facetRender, \"_facetRender\", true);\n    defineParam(_maxPlexDistance, \"_maxLDistance\", 1.0f);    \n    defineParam(_maxPlexConnections, \"_maxLConnections\", 1);    \n    defineParam(_maxPlexType, \"_maxPlexType\", 0); \n    defineParam(_plexLinedefXY, \"_plexLinedefXY\", false);      \n    defineParam(_plexLinedefXtoY, \"_plexLinedefXtoY\", false); //NYI\n    defineParam(_plexLinedefAUX, \"_plexLinedefAUX\", false); \n    defineParam(_plexLinedefX, \"_plexLinedefX\", false);  \n    defineParam(_plexLinedefY, \"_plexLinedefY\", false);  \n    defineParam(_plexConnectX, \"_plexConnectX\", false);      \n    defineParam(_plexConnectY, \"_plexConnectY\", false);   \n    defineParam(_plex_gamma, \"_L_gamma\", 1.0f);\n    //DOF SETTINGS   \n    defineParam(_dof_enable, \"Enable Depth of Field\", false);   \n    defineParam(_dof_samples, \"samples\", 3);    \n    defineParam(_dof_rings, \"rings\", 5);   \n    defineParam(focalDepth, \"focalDepth\", 1.0f);  \n    defineParam(_depthOfField, \"_depthOfField\", 4.0f);  \n    defineParam(_depthMult, \"_depthMult\", 0.1f);  \n    defineParam(_maxDofSize, \"_maxDofSize\", 8.0f);  \n    defineParam(dof_aspect, \"dof_aspect\", 1.0f);  \n    defineParam(dof_threshold, \"dof_threshold\", 1.0f);  \n    defineParam(dof_gain, \"dof_gain\", 0.0f);  \n    defineParam(dof_bias, \"dof_bias\", -2.0f);  \n    defineParam(dof_fringe, \"dof_fringe\", 0.0f); \n    //SHADING SETTINGS \n    defineParam(_flatshading, \"_flatshading\", true);  \n    defineParam(_vertexMode, \"_vertexMode\", 0);  \n    defineParam(_backfacing, \"_backfacing\", true);    \n    defineParam(_frontfacing, \"_frontfacing\", true);        \n    defineParam(_depthBuffer, \"_depthBuffer\", true);  \n    defineParam(_texoffset, \"_texoffset\", float2(0.5f,0.5f)); \n    defineParam(_pointSize, \"_pointSize\", 1); \n    defineParam(_gaussigma, \"_gaussigma\", 1.0f); \n    defineParam(_depthOcclusion, \"_depthOcclusion\", true); \n    defineParam(depthMultiplier, \"depthMultiplier\", 1.0f); \n    defineParam(_maxLineSteps, \"_maxLineSteps\", 4000.0f); \n    defineParam(_lineOffset, \"_lineOffset\", 1.0f); \n    defineParam(_lineInMultiplier, \"_lineInMultiplier\", 1.0f);   \n    defineParam(_lineOutMultiplier, \"_lineOutMultiplier\", 1.0f);     \n    defineParam(_overscan, \"_overscan\",float2(0.0f,0.0f));    \n\n  \}\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    max_line_connections = 80;\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n  \}\n\n  //Convert a 3d point position into a 2d raster position.\n  float3 Reconsile3D(float3 _PointPos)\{\n      vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      return tRaster;\n  \}\n\n//------------------------------\n//-------DRAW FUNCTIONS---------\n//------------------------------\n  //Write pixels to output.\n  void writepixel(float posx,float posy, float4 color,int index,float weight=1.0f)\n  \{ \n      if (_depthOcclusion)\{\n        float4 depthSample = occlusion(posx,posy);\n        if (depthSample.x<=vRaster.z && depthSample.w>0.0f)\{\n\n          float depth = (vRaster.z-depthSample.x);\n          color = color*(1.0f-depthSample.w);\n          color = color / (((depth*depth)*depthMultiplier)+1.0f);\n          //return;\n        \}\n      \}\n      float4 finalOutput; //This is used to store the final output\n      float4 dstSample; //This is used to store a sample of the destination\n      if ( dst.bounds.inside( posx, posy ) ) \{ //Test if the pixel written to is inside the output image. \n        if (_depthBuffer) \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          if ((dstSample.w>color.w)||dstSample.w==0.0f) \{\n            dst(posx,posy) = color;\n          \}\n        \}\n        else \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          finalOutput = dstSample + (color*_alphaMultiplier*weight);\n          finalOutput.w = dstSample.w + ((color.w*_alphaMultiplier*weight));\n\n          finalOutput.w = (dstSample.w + ((color.w*_alphaMultiplier*weight)))-(dstSample.w * ((color.w*_alphaMultiplier*weight)));\n\n          dst(posx,posy) = finalOutput;\n        \}\n      \} \n  \}\n\n  //Calculate a Bilinear Plot\n  void bilinear_Plot(float2 temppos,float4 color,int index)\n  \{\n    float2 p;\n    p.x=Frac(temppos.x);\n    p.y=Frac(temppos.y);\n    float weights\[] = \{(1.0f-p.x)*(1.0f-p.y), p.x*(1.0f-p.y), (1.0f-p.x)*p.y, p.x*p.y\};\n    int2 _position = int2(floor(temppos.x)-0,floor(temppos.y)-0); \n    writepixel(_position.x,_position.y,color,index,weights\[0]);\n    writepixel(_position.x+1,_position.y,color,index,weights\[1]);\n    writepixel(_position.x,_position.y+1,color,index,weights\[2]);\n    writepixel(_position.x+1,_position.y+1,color,index,weights\[3]);\n  \}\n\n  //NYI, unused!\n  void gaussian(float2 temppos,float4 color,int index)\{\n    float in_x = temppos.x;\n    float in_y = temppos.y;\n    int kernelSize = (_pointSize+1)*2;\n    int subsize = (kernelSize /2)-1;\n    float gKernel\[64]\[64];\n    float sigma = _gaussigma;\n    float intSigma = float(_pointSize);\n    float r, s = intSigma * sigma * sigma;\n\n    float sum = 0.0f;\n\n    // generate 5x5 kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            r = float(sqrt(x*x + y*y));\n            gKernel\[x + subsize]\[y + subsize] = (exp(-(r*r)/s))/(3.141592654f * s);\n            sum += gKernel\[x + subsize]\[y + subsize];\n        \}\n    \}\n\n    // normalize the Kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            gKernel\[x + subsize]\[y + subsize] /= sum;\n            writepixel(in_x+x,in_y+y,color,index,gKernel\[x + subsize]\[y + subsize]);\n        \}\n    \}\n  \}\n\n//-------------------------------------\n// DrawLine\n// ----------\n// Draw a line between two points, \n// x,y being 2d screenspace pos and z being depth.\n//-------------------------------------\n  void DrawLine(float3 origin, float3 endpoint,float4 _colorA,float4 _colorB) \{\n    float4 _color;\n    float3 delta = origin-endpoint;\n    float3 curPoint = origin;\n    float mag = sqrt(delta.x*delta.x+delta.y*delta.y);\n    mag = min(mag,_maxLineSteps); //Lets not go crazy, we cap it at 10.000 to avoid insane unwated processing time \n    for( float a = 0; a < mag*_lineOffset; a = a + 1.0f )\{\n      curPoint -= (delta/mag);\n      _color = (_colorA*(1.0f-(a/mag*1.0f)))+(_colorB*(a/mag*1.00f));\n      if (_dof_enable)\{\n        Bokeh(curPoint,_color);\n      \}\n      else \{\n        bilinear_Plot(float2(curPoint.x,curPoint.y),_color,1);\n      \}\n      \n    \}\n  \}\n\n//-------------------------------------\n// Point_Render\n//-------------------------------------\nvoid point_render(int2 pos, float3 screen_pos)\{\n  float4 color = src(pos.x,pos.y);\n\n  if (_filtering == 1)\{\n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        if (_depthBuffer) \{color.w = screen_pos.z;\} //Added\n        bilinear_Plot(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  /*\n  //THIS PART NEEDS TO BE RE-WRITTEN.\n  else if (_filtering == 2)\{ \n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        gaussian(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  */\n  else \{\n      int2 _position = int2(floor(screen_pos.x),floor(screen_pos.y)); \n      if (_depthBuffer) \{color.w = screen_pos.z;\}\n      writepixel(_position.x,_position.y, color,1,1.0f); //OutputSample\n  \}\n\n\}\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nvoid facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x+1,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos,V0_N,V1_N,V2_N;\n    float2 V0_ST,V1_ST,V2_ST;\n    float4 V1_Sample,V2_Sample;\n    float4 _tn;\n    float3 normal0,normal1,normal2;\n    float2 UV_Format = float2(Vformat.x,Vformat.y);\n\n\n    int2 P0 = int2(pos.x-1,pos.y-1);\n    int2 P1 = int2(pos.x+1,pos.y+1);\n    if (_plexConnectX && pos.x == int(Vformat.x))\{\n      insideX == true;\n      P1 = int2(0.0f,pos.y+1);\n    \}\n    if (_plexConnectY && pos.y == int(Vformat.y))\{\n      insideYtop == true;\n      P1 = int2(pos.x+1,0);\n    \} \n\n    if (_plexConnectY && pos.y == 0)\{\n      insideY == true;\n      P0 = int2(pos.x-1,int(UV_Format.y));\n    \} \n\n    if (!_flatshading) \{\n      _tn = normals(pos.x,pos.y);\n      V0_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n    V0_ST = float2(pos.x,pos.y)/UV_Format;\n\n  if (insideX) \{\n    V2_Sample = ppos(P1.x,pos.y);\n    V2_ST = float2(P1.x,pos.y)/UV_Format;\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (!_flatshading) \{\n      _tn = normals(P1.x,pos.y);\n      V2_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n        \n\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(P1.x,P0.y);\n        V1_ST = float2(P1.x,P0.y)/UV_Format;\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(P1.x,P0.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}\n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V2_Pos,V1_Pos,_vWorld,V2_wPos,V1_wPos,V0_N,V2_N,V1_N,V0_ST,V2_ST,V1_ST);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,P1.y);\n        V1_ST = float2(pos.x,P1.y)/UV_Format;        \n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(pos.x,P1.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}        \n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V1_Pos,V2_Pos,_vWorld,V1_wPos,V2_wPos,V0_N,V1_N,V2_N,V0_ST,V1_ST,V2_ST);\n        \}\n      \}\n    \}\n  \}\n\}\n\n\n\n//This function will calculate if pixel C is inside the triangle\nfloat edgeFunction(float3 a, float3 b, float3 c) \n\{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n\} \n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat Distance(float3 _a,float3 _b)\n\{\n          float xd = _a.x - _b.x;\n          float yd = _a.y - _b.y;\n          float zd = _a.z - _b.z;\n          return sqrt(xd*xd + yd*yd + zd*zd);\n\}\n\nvoid DrawTriangle(float3 V0, float3 V1, float3 V2,float3 WP0, float3 WP1, float3 WP2,float3 N0, float3 N1, float3 N2, float2 st0,float2 st1,float2 st2) \{\n\n  // Precompute reciprocal of vertex z-coordinate \n  V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n\n  float2 st0n = st0 * V0.z;\n  float2 st1n = st1 * V1.z; \n  float2 st2n = st2 * V2.z; //Normal version of ST\n\n  bool inside; \n  float X0 = Fmin(V0.x,V1.x,V2.x)-1.0f;\n  float X1 = Fmax(V0.x,V1.x,V2.x)+1.0f;\n  float Y0 = Fmin(V0.y,V1.y,V2.y)-1.0f;\n  float Y1 = Fmax(V0.y,V1.y,V2.y)+1.0f;\n  float area = edgeFunction(V2, V1, V0);\n\n\n  float2 sampos = float2(st0.x*float(Vformat.x),st0.y*float(Vformat.y));\n  float4 text0 = src(sampos.x,sampos.y);\n  sampos = float2(st1.x*float(Vformat.x),st1.y*float(Vformat.y));\n  float4 text1 = src(sampos.x,sampos.y);\n  sampos = float2(st2.x*float(Vformat.x),st2.y*float(Vformat.y));  //Why do we have to do this? =(\n  float4 text2 = src(sampos.x,sampos.y);\n  sampos = float2(min(min(st0.x,st1.x),st2.x)*float(Vformat.x),min(min(st0.y,st1.y),st2.y)*float(Vformat.y));\n  float4 text3 = src(sampos.x,sampos.y);\n\n\n  for( int x = X0; x < X1 ; x++) \{\n    for( int y = Y0; y < Y1 ; y++) \{\n      float3 pixelSample(x + _texoffset.x, y + _texoffset.y,0.0f); \n\n      //This is the part where we test if the current pixel is inside the triangle\n      //We check both for front facing and back faing options\n      float w0 = edgeFunction(V1, V0, pixelSample); //Front Facing\n      float w1 = edgeFunction(V2, V1, pixelSample); \n      float w2 = edgeFunction(V0, V2, pixelSample); \n      float w3 = edgeFunction(V0, V1, pixelSample); //Back Facing\n      float w4 = edgeFunction(V1, V2, pixelSample); \n      float w5 = edgeFunction(V2, V0, pixelSample);\n\n      //writepixel(x,y, float4(w1),1,1.0f);\n      if ((w0 >= 0 && w1 >= 0 && w2 >= 0 && _frontfacing) || (w3 >= 0 && w4 >= 0 && w5 >= 0 && _backfacing)) \{ //The curent pixel is inside the triangle\n\n       // calculate vectors from point f to vertices p1, p2 and p3:\n       float3 f1 = V0-pixelSample;\n       float3 f2 = V1-pixelSample;\n       float3 f3 = V2-pixelSample;\n       // calculate the areas and factors (order of parameters doesn't matter):\n       float a = length(cross(V0-V1,V0-V2 )); // main triangle area a\n       area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n        w0 /= area; \n        w1 /= area; \n        w2 /= area; \n\n        w3 /= area; \n        w4 /= area; \n        w5 /= area; \n\n       float a1 = length(cross(f2, f3)) / a; // p1's triangle area / a\n       float a2 = length(cross(f3, f1)) / a; // p2's triangle area / a \n       float a3 = length(cross(f1, f2)) / a; // p3's triangle area / a\n       float a_magnitude = a1+a2+a3;\n       a1 = a1/a_magnitude;\n       a2 = a2/a_magnitude;\n       a3 = a3/a_magnitude;\n       float z = 1.0f / (V0.z * a1 + V1.z * a2 + V2.z * a3); \n\n\n        // find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):\n        float2 uv = st0 * a1 + st1 * a2 + st2 * a3;\n        float2 st = st0 * w0 + st1 * w1 + st2 * w2; \n        st *= z;      \n\n\n        //Calculate normals. Eighter we have flat shading, else we calculate a normal per pixel\n        float3 normalB;\n        if (_flatshading) \{\n          normalB = CalculateSurfaceNormals(WP0,WP1,WP2);\n\n        \}\n        else \{\n          float3 c0 = N2/float3(V0.z); \n          float3 c1 = N0/float3(V1.z); \n          float3 c2 = N1/float3(V2.z);  \n\n          normalB.x = w0 * c0.x + w1 * c1.x + w2 * c2.x; \n          normalB.y = w0 * c0.y + w1 * c1.y + w2 * c2.y; \n          normalB.z = w0 * c0.z + w1 * c1.z + w2 * c2.z; \n\n          normalB.x *= z, normalB.y *= z, normalB.z *= z; \n        \}\n        normalB = normalize(normalB);\n\n        //CALCULATE THE OBJECT TEXTURE COORDINATES\n        float zn = 1.0f / (V0.z * w0 + V1.z * w1 + V2.z * w2); \n        st = st0n * w0 + st1n * w1 + st2n * w2; \n        st *= zn;   \n        //--END \n\n        float3 Wpos = WP0*a1 + WP1*a2 + WP2*a3; //World Position.\n        float3 ViewNormal = normalize(float3(cameraToWorld\[3]\[0],cameraToWorld\[3]\[1],cameraToWorld\[3]\[2])-Wpos);\n\n        float nDotView =  dot(normalB,ViewNormal);\n        nDotView = 1.0f-fabs(nDotView); //make sure that the view normal ramps back around when doing backface\n        float4 tempout;\n\n        //Flatshading or regular?\n        if (!_flatshading) \{\n          tempout = text0 * a1 + text1 * a2 + text2 * a3; \n        \}\n        else\{\n          tempout = text3;\n        \}\n\n        //Additional Render Modes\n        if (_vertexMode == 1)\{\n          tempout = float4(a1,a2,a3,1.0f);\n        \}\n        else if (_vertexMode == 2)\{\n          tempout = float4(normalB.x,normalB.y,normalB.z,1.0f);\n        \}\n        else if (_vertexMode == 3)\{\n          tempout = float4(nDotView,nDotView,nDotView,1.0f);\n        \}\n        else if (_vertexMode == 4)\{\n          tempout = float4(uv.x,uv.y,0.0f,1.0f);\n        \}       \n        else if (_vertexMode == 5)\{\n          tempout = float4(st.x,st.y,0.0f,1.0f);\n        \}               \n        else if (_vertexMode == 6)\{\n          tempout = float4(ViewNormal.x,ViewNormal.y,ViewNormal.z,1.0f);\n        \}             \n        else if (_vertexMode == 7)\{\n          tempout = float4(Wpos.x,Wpos.y,Wpos.z,1.0f);\n        \}   \n\n        if (_depthBuffer)\{\n          writepixel(x,y, float4(tempout.x,tempout.y,tempout.z,z),1,1.0f);  \n        \}\n        else \{\n          if (_dof_enable)\{\n            Bokeh(float3(x,y,z),float4(tempout.x,tempout.y,tempout.z,z));\n          \}\n          else \{\n            bilinear_Plot(float2(x,y),float4(tempout.x,tempout.y,tempout.z,z),1);\n          \}\n        \}\n\n      \}  \n\n    \}\n  \}\n\}\n\n//-------------------------------------\n// Wire_Render\n//-------------------------------------\nvoid wire_render(int2 pos) \{\n  float4 temp = float4(0.0f,0.0f,0.0f,FLT_MAX);\n  float4 wire_ref_sample;\n  int2 tempXY = int2(0,0);\n  float4 plexlist\[11] = \{temp,temp,temp,temp,temp,temp,temp,temp,temp,temp,temp\}; \n  int2 plexlistXY\[11] = \{tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY\};\n  int plex_count = 0; //We use this to figure how many points that should connect.\n  float plex_dist;\n  float3 plex_position,plex_position_b;\n  float4 temp_pos, temp_pos_b; //Temporary Position Containers\n  if (_maxPlexType == -1) \{ //Used for random connection types\n    for( int x = 0; x < max_line_connections ; x++)\{ //THIS 80 NUMBER IS THE LIMIT TO AVOID TOO SLOW PROCESSING!\n      for( int y = 0; y < max_line_connections ; y++)\{\n        wire_ref_sample = ppos(x,y);\n        if (wire_ref_sample.w != 0.0f && pos.x!=x && pos.y != y) \{ \n          plex_position = float3(wire_ref_sample.x,wire_ref_sample.y,wire_ref_sample.z)*(zoom);\n          float xd = plex_position.x - vWorld.x;\n          float yd = plex_position.y - vWorld.y;\n          float zd = plex_position.z - vWorld.z;\n          float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n          if (plex_dist<_maxPlexDistance)\{\n            plex_count = min(10,plex_count+1); //Add one to the count\n            for( int h = 0; h < plex_count+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n              if (plex_dist < plexlist\[h].w) \{                  \n                for( int i = plex_count+1; i > h ; i--) \{\n                  plexlist\[i] = plexlist\[i-1];\n                  plexlistXY\[i] = plexlistXY\[i-1];\n                \}\n                plexlist\[h] = float4(plex_position.x,plex_position.y,plex_position.z,plex_dist);\n                plexlistXY\[h] = int2(x,y);\n                break;        \n              \}\n            \}\n          \} \n        \}\n      \}\n    \}\n  \}\n  else\{ //Used for standard connection types\n    float4 temp_pos;\n    bool insideX = !(Vformat.x < pos.x+1);\n    bool insideY = !(Vformat.y < pos.y+1);\n\n\n    if (!_plexLinedefAUX)\{\n      temp_pos = normals(pos.x,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,vWorld+plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideX && !_plexLinedefX) \{\n      temp_pos = ppos(pos.x+1,pos.y );\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && !_plexLinedefX) \{\n      temp_pos = ppos(0,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideY && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\}                          \n    \}\n    else if ( _plexConnectY  && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,0);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    //_plexConnect\n    if ( insideX && insideY && !_plexLinedefXY) \{              \n      temp_pos = ppos(pos.x+1,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && _plexConnectY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && insideY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectY && insideX && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n  \}   \n\n  //now that all the connections have been sorted by distance then we connect the dots.\n  for( int x = 0; x < min(_maxPlexConnections,plex_count) ; x++)\{\n    plex_position = float3(plexlist\[x].x,plexlist\[x].y,plexlist\[x].z);\n    plex_dist = plexlist\[x].w;\n\n\n    float plex_distribution = 1.0f-((plexlist\[x].w-plexlist\[0].w)/((plexlist\[min(_maxPlexConnections,plex_count)].w-plexlist\[0].w)+0.00001f)); //Where does it lie between the best and the worst distance?\n    //plexlistXY\n\n    float4 plex_col = float4(pow(1.0f-(plex_dist/_maxPlexDistance),1.0f/_plex_gamma))*float4(plex_distribution); //This one is quite cool aswell, but does leave the center ones a bit too focused \n    float4 plex_colorA = src(pos.x,pos.y);\n    float4 plex_colorB = src( plexlistXY\[x].x,plexlistXY\[x].y);\n    plex_col *= 0.1f;\n\n    computePixelCoordinates(plex_position, pRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n    if (dst.bounds.inside(int(vRaster.x),int(vRaster.y)) || dst.bounds.inside(int(pRaster.x),int(pRaster.y)))\{\n        DrawLine(vRaster,pRaster,(plex_colorA*plex_col)*_lineInMultiplier,(plex_colorB*plex_col)*_lineOutMultiplier);\n    \}\n  \}\n\}\n\nvoid wire_connection(float3 p_source,float3 p_target, float4 (&p_plexlist)\[11], int2 (&p_plexlistXY)\[11],int &p_plexcount,int2 position) \{\n  float xd = p_target.x - p_source.x;\n  float yd = p_target.y - p_source.y;\n  float zd = p_target.z - p_source.z;\n  float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n  if (plex_dist<_maxPlexDistance)\{\n    p_plexcount = min(11,p_plexcount+1); //Add one to the count\n    for( int h = 0; h < p_plexcount+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n      if (plex_dist < p_plexlist\[h].w) \{                  \n        for( int i = p_plexcount+1; i > h ; i--) \{\n          p_plexlist\[i] = p_plexlist\[i-1];\n          p_plexlistXY\[i] = p_plexlistXY\[i-1];\n        \}\n        p_plexlist\[h] = float4(p_target.x,p_target.y,p_target.z,plex_dist);\n        p_plexlistXY\[h] = int2(position.x,position.y);\n        break;        \n      \}\n    \}  \n  \}\n\}\n//-------END OF WIRE RENDER FUNCTIONS---------\n\n\n\n\n//-------------------------------\n//-------BOKEH FUNCTIONS---------\n//thanks to: http://devlog-martinsh.blogspot.dk/2011/11/glsl-depth-of-field-with-bokeh-v21.html\nfloat2 rand(float2 coord) //generating noise/pattern texture for dithering\n\{\n  float noiseX = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.25)+(Frac(coord.y*(WHformat\[1]/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.75)+(Frac(coord.y*(WHformat\[1]/2.0))*0.25))*2.0-1.0;\n  noiseX = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f))) * 43758.5453f),0.0f,1.0f)*2.0f-1.0f;\n  noiseY = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f)*2.0f)) * 43758.5453f),0.0f,1.0f)*2.0-1.0f;\n  return float2(noiseX,noiseY);\n\}\n//-------------------------------------\n// Bokeh\n//-------------------------------------\nvoid Bokeh(float3 pos,float4 color)\{\n  float blur = 0.0;\n  blur = clamp((fabs(pos.z - focalDepth)/_depthOfField)*100.0f,-_maxDofSize,_maxDofSize);\n  \n  float w = (1.0/WHformat.x)*blur;//+noise.x;\n  float h = (1.0/(WHformat.x*dof_aspect))*blur;//+noise.y;\n  float3 v3_col = float3(color.x,color.y,color.z);\n  int ringsamples;\n  float s = 1.0;  \n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples; \n    for (int j = 0 ; j < ringsamples ; j += 1)  \n    \{ \n      s += (1.0f*mix(1.0f,(float(i))/(float(_dof_rings)),dof_bias)*1.0f); //No need to do this in the loop\n    \}\n  \}\n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples;\n     \n    for (int j = 0 ; j < ringsamples ; j += 1)   \n    \{\n      float step = PI*2.0 / float(ringsamples);\n      float pw = (cos(float(j)*step)*(float(i)/_dof_rings));\n      float ph = (sin(float(j)*step)*(float(i)/_dof_rings));\n      float p = 1.0;\n\n      float posx = pos.x+((pw*w)*blur);\n      float posy = pos.y+((ph*h)*blur);\n\n\n      float3 lumcoeff = float3(0.299,0.587,0.114);\n      float lum = dot(v3_col, lumcoeff);\n      float thresh = max((lum-dof_threshold)*dof_gain, 0.0f);\n      v3_col+mix(float3(0.0),v3_col,thresh*blur);\n\n      float3 col = (v3_col*mix(1.0,(float(i))/(float(_dof_rings)),dof_bias)*p)/s; \n      bilinear_Plot(float2(posx,posy),float4(col.x,col.y,col.z,color.w/(_dof_rings*_dof_rings)),1);\n    \}\n  \}\n\}\n//-------END OF BOKEH FUNCTIONS---------\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float2 posf = float2(pos.x,pos.y);\n\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n\n      //Convert worldspace coordinates to screenspcace coordinates.\n      vWorld = float3(_sample.x,_sample.y,_sample.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, vRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      if (ret) \{ //Only create points that are visible on screen\n        if (_pointRender)\{\n          point_render(pos,vRaster);\n        \}\n      \} //Pointrender over\n\n      if (_wireRender && _maxPlexConnections>=1) \{\n        if (max(pos.x,pos.y)<=max_line_connections || (_maxPlexType==0))\{ // Don't process more wires than allowed in nearest mode.\n          wire_render(pos);\n        \}\n      \} //WireRender over\n\n      if (_facetRender) \{\n        facet_render(pos,float3(_sample.x,_sample.y,_sample.z));\n      \}  //FacetRender over\n      \n    \}\n  \} //----> process\n\};\n"
  useGPUIfAvailable false
  rebuild ""
  PointRender3D_cam_Matrix {
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
    }
  PointRender3D_focallength {{parent.Camera1.focal}}
  PointRender3D_hapeture {{parent.Camera1.haperture}}
  PointRender3D_format {{!proxy?Settings_Format.width:Settings_Format.width*proxy_scale} {!proxy?Settings_Format.height:Settings_Format.height*proxy_scale}}
  PointRender3D_vertexformat {{parent.InputFormat.box.r-1} {parent.InputFormat.box.t-1}}
  PointRender3D__alphaMultiplier {{parent.AlphaMultiplier}}
  PointRender3D__pointRender {{parent.RenderMode==0}}
  PointRender3D__wireRender {{parent.RenderMode==1}}
  PointRender3D__facetRender {{parent.RenderMode==2}}
  PointRender3D__maxLDistance {{parent.wire_maxdistance}}
  PointRender3D__maxLConnections {{parent.wire_connections}}
  PointRender3D__maxPlexType {{-parent.wire_type}}
  PointRender3D__plexLinedefXY {{!parent.connect_xy}}
  PointRender3D__plexLinedefX {{!parent.connect_x}}
  PointRender3D__plexLinedefY {{!parent.connect_y}}
  PointRender3D__plexLinedefAUX {{!connect_aux}}
  PointRender3D__plexConnectX {{parent.CloseX}}
  PointRender3D__plexConnectY {{parent.CloseY}}
  PointRender3D__L_gamma {{parent.wire_Threshold}}
  "PointRender3D_Enable Depth of Field" {{parent.dof_enable}}
  PointRender3D_samples {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_rings {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_focalDepth {{parent.dof_focaldepth}}
  PointRender3D__depthOfField {{parent.dof_dof}}
  PointRender3D__depthMult 0
  PointRender3D__maxDofSize {{parent.dof_maxSize*400}}
  PointRender3D_dof_aspect {{parent.dof_Aspect}}
  PointRender3D_dof_bias {{parent.dof_bias}}
  PointRender3D__flatshading {{parent.facet_flatShading}}
  PointRender3D__backfacing {{parent.facet_backface}}
  PointRender3D__frontfacing {{parent.facet_front}}
  PointRender3D__vertexMode {{parent.renderMode}}
  PointRender3D__depthBuffer {{parent.facet_depth}}
  PointRender3D__texoffset {-0.5 0.5}
  PointRender3D__pointSize 0
  PointRender3D__depthOcclusion {{parent.UseOcclusionMap}}
  PointRender3D__maxLineSteps {{parent.maxSamples}}
  PointRender3D__lineOffset {{parent.lineoffset}}
  PointRender3D__lineInMultiplier {{parent.inGain}}
  PointRender3D__lineOutMultiplier {{parent.outGain}}
  PointRender3D__overscan {{parent.overscan} {parent.overscan}}
  format "1280 720 0 0 1280 720 1 HD_720"
  rebuild_finalise ""
  name BlinkScript1
  xpos -27
  ypos 159
 }
set N16d3fce0 [stack 0]
 TimeBlur {
  divisions {{parent.Samples}}
  shutter {{parent.Shutter}}
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur
  xpos -27
  ypos 301
  disable {{1-parent.mb_enable x89 0}}
 }
 ShuffleCopy {
  inputs 2
  alpha alpha2
  black alpha
  out2 depth
  name ShuffleCopy2
  xpos -27
  ypos 411
  disable {{!parent.OutputZdepth}}
 }
 CopyBBox {
  inputs 2
  name CopyBBox1
  xpos -27
  ypos 521
 }
 Reformat {
  format {{{Settings_Format.format}}}
  resize none
  center false
  pbb {{max(parent.overscan.w,parent.overscan.h)!=0}}
  name Reformat1
  xpos -27
  ypos 545
 }
 Group {
  name SoftLook
  xpos -27
  ypos 647
  disable {{!parent.HighlightCompression}}
  addUserKnob {20 User}
  addUserKnob {26 ""}
  addUserKnob {7 Add R 0 4}
  Add {{parent.HighlightCeiling}}
  addUserKnob {7 Offset R 0 4}
  Offset {{parent.Compression}}
 }
  Input {
   inputs 0
   name Input1
   xpos -248
   ypos 500
  }
set N16ddc4f0 [stack 0]
  Expression {
   expr0 r/(r+parent.Offset)*parent.Add
   expr1 g/(g+parent.Offset)*parent.Add
   expr2 b/(b+parent.Offset)*parent.Add
   expr3 a/(a+parent.Offset)*parent.Add
   name Expression1
   xpos -339
   ypos 576
  }
push $N16ddc4f0
  ShuffleCopy {
   inputs 2
   red red
   green green
   blue blue
   alpha alpha2
   name ShuffleCopy1
   xpos -248
   ypos 576
  }
  Output {
   name Output1
   xpos -248
   ypos 651
  }
 end_group
 ShuffleCopy {
  inputs 2
  in pos
  red red
  green green
  blue blue
  out pos
  name ShuffleCopy1
  xpos -27
  ypos 860
  disable true
 }
 Output {
  name Output1
  xpos -27
  ypos 897
 }
push $N16c86e80
 PositionToPoints2 {
  display textured
  render_mode textured
  P_channel pos
  detail 0.25
  pointSize 0.6
  name PreviewNode
  xpos -22
  ypos 8
  disable {{!parent.Enable3DPreview}}
 }
push $N16abaa00
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize none
  filter Impulse
  black_outside true
  name Reformat3
  xpos -633
  ypos -1109
  disable {{!wire_type==1}}
 }
push $N16aff8e0
push $N16b1f770
push $N16b24380
 Merge2 {
  inputs 2
  operation min
  Achannels {-pos.red -pos.green -pos.blue pos.alpha}
  Bchannels {-pos.red -pos.green -pos.blue pos.alpha}
  output {-pos.red -pos.green -pos.blue pos.alpha}
  name Merge4
  xpos -582
  ypos -634
 }
 Merge2 {
  inputs 2
  operation min
  Achannels {-pos.red -pos.green -pos.blue pos.alpha}
  Bchannels {-pos.red -pos.green -pos.blue pos.alpha}
  output {-pos.red -pos.green -pos.blue pos.alpha}
  name Merge5
  xpos -582
  ypos -602
 }
push $N16b37730
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -456
  ypos -402
 }
push $N16d3fce0
 Viewer {
  frame 36
  frame_range 1-100
  name Viewer1
  xpos -27
  ypos 325
 }
 Input {
  inputs 0
  name InputCamera
  xpos -1271
  ypos 89
  number 1
 }
 Camera {
  useMatrix true
  matrix {
      {1 0 0 0}
      {0 {1/Settings_Format.actual_format.pixel_aspect} 0 0}
      {0 0 1 0}
      {0 0 0 1}
    }
  projection_mode {{"\[value the_cam]projection_mode"}}
  focal {{"\[value \[value the_cam]focal]"}}
  haperture {{"\[value \[value the_cam]haperture]"}}
  vaperture {{"\[value \[value the_cam]vaperture]"}}
  near {{"\[value \[value the_cam]near]"}}
  far {{"\[value \[value the_cam]far]"}}
  win_translate {{"\[lindex \[value \[value the_cam]win_translate] 0]"} {"\[lindex \[value \[value the_cam]win_translate] 1]"}}
  win_scale {{"\[lindex \[value \[value the_cam]win_scale] 0]"} {"\[lindex \[value \[value the_cam]win_scale] 1]"}}
  winroll {{"\[value \[value the_cam]winroll]"}}
  focal_point {{"\[value \[value the_cam]focal_point]"}}
  fstop {{"\[value \[value the_cam]fstop]"}}
  name Camera1
  help "DummyCam by Adrian Pueyo\n\nCamera that apart from the matrices also grabs all the \"Projection\" values from the upstream camera that it's connected to. Turns into a default Camera if not Camera connected.\n\nCan also be used inside of groups and gizmos, as many levels deep as you want :D\n\nAll using live and super fast TCL.\n\nadrianpueyo.com, 2019"
  onCreate "n = nuke.thisNode()\nfor k in \[\"projection_mode\",\"focal\",\"haperture\",\"vaperture\",\"near\",\"far\",\"win_translate\",\"win_scale\",\"winroll\",\"focal_point\",\"fstop\"]:\n    n\[k].setFlag(0x0000000010000000)"
  label "(thanks to Adrian Pueyo and Ernest Dios)"
  xpos -1261
  ypos 198
  addUserKnob {20 DummyCam l Defaults}
  addUserKnob {43 the_cam +INVISIBLE}
  the_cam "\[\nset the_knob \"focal\"\nset knob_index 0\nset starting_point \"this.input0\"\nset default \"this\"\nset default \[append default \".d_\"]\n\n# If cam has no inputs, return the default...\nif \{\[exists \$starting_point]\} \{\n    set x \[node \$starting_point]\n\} \{ \n    return \$default\n\}\n\nset finished 0\nwhile \{\$finished != 1\} \{\n\n    # First look for a Cam or Input or topnode.\n    while \{\[class \$x] != \"Camera2\" && \[class \$x] != \"Camera\" && \[class \$x] != \"Input\" && \$x != \[topnode \$x]\} \{\n        set x \[node \$x.input0]\n    \}\n\n    # Then, check if node is a cam (and return), and otherwise, if it's an input, see if the parent exists and move to it.\n    if \{\[class \$x]==\"Camera2\"||\[class \$x]==\"Camera\"\} \{\n        set x \[append x \".\"]\n        return \$x\n    \} \{ \n        if \{\[class \$x]==\"Input\"\} \{ \n            set inp \"\$x.parent.input\"\n            set inputNum \[value \$x.number]\n            set inp \[append inp \$inputNum]\n            if \{\[exists \$inp]\} \{\n                set x \[node \$inp]\n            \} \{ \n                set finished 1\n            \}\n        \} \{ \n            set finished 1\n        \}\n    \}\n\}\nreturn \$default\n]"
  addUserKnob {4 d_projection_mode l projection M {perspective orthographic uv spherical ""}}
  addUserKnob {7 d_focal l focal R 0 100}
  d_focal 50
  addUserKnob {7 d_haperture l "horiz aperture" R 0 50}
  d_haperture 24.576
  addUserKnob {7 d_vaperture l "vert aperture" R 0 50}
  d_vaperture 18.672
  addUserKnob {7 d_near l near R 0 10}
  d_near 0.1
  addUserKnob {7 d_far l far R 0 10000}
  d_far 10000
  addUserKnob {12 d_win_translate l "window translate"}
  addUserKnob {12 d_win_scale l "window scale"}
  d_win_scale {1 1}
  addUserKnob {7 d_winroll l "window roll" R 0 45}
  addUserKnob {7 d_focal_point l "focal distance" R 0 10}
  d_focal_point 2
  addUserKnob {7 d_fstop l fstop R 0 30}
  d_fstop 16
  addUserKnob {26 text l " " T "<span style=\"color:#666\"><br/><b>DummyCam v1.0</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2019</span>"}
 }
end_group
push $Ndaadbd0
Dot {
 name Dot1
 xpos -922
 ypos 1365
}
set N16e9e580 [stack 0]
Dot {
 name Dot16
 xpos -1051
 ypos 1365
}
set N16ea2de0 [stack 0]
Mask3DV2 {
 name Mask3DV2_1
 note_font "Bitstream Vera Sans"
 xpos -1079
 ypos 1439
 in __position_world
 out rgba.alpha
 unpremultiply false
 matteShape Cube
 center {127.2569733 {curve x1001 27.515973 x1049 15.09597298} 38.48317719}
 radius 2
 transform 1
 scaling {10 1 {scaling.x i}}
 falloffType Cubic
 falloff 0.3
 _class Mask3D
}
Camera2 {
 inputs 0
 translate {-21.79999924 -1 -10.39999962}
 rotate {0 -113.8716627 0}
 name Camera3
 xpos -830
 ypos 2206
 addUserKnob {20 DNeg}
 addUserKnob {26 _version l "" +STARTLINE +INVISIBLE T 1.0}
 addUserKnob {41 "horiz aperture" T haperture}
 addUserKnob {41 "vert aperture" T vaperture}
 addUserKnob {4 setApertureValues l "" t "Set aperture values based on registered camera sensor data. The 'read from file' knob needs to be disabled and any potential curves deleted." +STARTLINE M {"Set Aperture Values" ANNI/Delivery "Alexa 65/Full" "Alexa 65/Half Res" "Alexa MINI/4:3 Full Ana" "Alexa MINI/16:9 Full" "Alexa MINI/OpenGate" "Alexa MINI/16:9 1.78 Ana" "Alexa Mini/OpenGate" "Alexa XT/OpenGate" "Alexa XT/4:3 Full Ana" "Alexa XT/16:9 1.78" "Alexa XT/16:9 1.78 Ana" "Alexa XT/4:3 Full" "Alexa XT/Open Gate" "Alexa XT/Open Gate TC" "Alexa XT/SuperOpenGate" "Alexa XT/SuperOpenGate Cropped" "Arri 65/6k 1.3 ana" "Arri 65/6k 2.11" BF/Delivery "BOND /Anamorphic" "Blackmagic Prod 4K/4K" "Canon 5D mkIII/HD" "Canon C300/16:9" "Delivery Extractions/Arri 65 1.3 ana Working" "Delivery Extractions/Arri 65 Working" "Extractions/CFW Delivery" "Film 35mm/Cinemascope Centred" "Film 35mm/Full Aperture" "Generic/1080p HD" Generic/Anamorphic Generic/Spherical "GoPro/Generic 16:9" HERC/Alexa IMAX/8K "Internal Movie Extractions/TRAINVFX Working" "Internal Movie Extractions/Alexa XT OpenGate" "Internal Movie Extractions/Previs" "Internal Movie Extractions/Arri 65 1.3 ana Working" "Internal Movie Extractions/MLOU Delivery" "Internal Movie Extractions/MAGIC Working" "Movie Extractions/Alexa XT OpenGate" "Movie Extractions/Alexa XT 4:3 Full Ana" "Movie Extractions/Alexa MINI 4:3 Full Ana" "Movie Extractions/Alexa MINI 16:9 1.78" "Movie Extractions/Alexa XT 16:9 1.78" "Movie Extractions/Alexa MINI OpenGate" "Movie Extractions/Alexa XT 16:9 1.78 Ana" "Movie Extractions/Alexa MINI 16:9 1.78 Ana" "Movie Extractions/Phantom Flex 4k" "Movie Extractions/MAE Working 2" "Movie Extractions/TS Anamorphic 4K" "Movie Extractions/EXO Working" "Movie Extractions/Previs" "Movie Extractions/MAGIC Working" "Movie Extractions/DOTN Working" "Phantom Flex/4k" Previs/Anamorphic Previs/Spherical "Red Epic/5K" "Red Epic Dragon/6K HD" "Red Epic Dragon/5K Full" "Red Epic Dragon/5K FullFrame Scaled" "TM/Alexa MINI 4:3 Full Ana" "Working Extractions/Arri 65 6k 1.3 ana" "Working Extractions/Alexa XT 4:3 Full Ana" "Working Extractions/Alexa XT OpenGate" "Working Extractions/Alexa XT 16:9 1.78" "Working Extractions/Alexa MINI 4:3 Full Ana" "Working Extractions/Alexa MINI OpenGate" "Working Extractions/Alexa MINI 16:9 1.78" "Working Extractions/Phantom Flex 4k" "Working Extractions/Alexa XT 16:9 1.78 Ana" "Working Extractions/Alexa MINI 16:9 1.78 Ana" "Working Extractions/EXO Working" "Working Extractions/EXO Working 2" "Working Extractions/Arri 65 6k" "Working Extractions/Alexa LF 4.5k OpenGate" "Working Extractions/DOTN Working" "internal Movie Extractions/Red Epic Dragon 5k FullFrame Scaled" "internal Movie Extractions/Red Epic Dragon 5K FullFrame" "internal Movie Extractions/IMAX 6K" "internal Movie Extractions/IMAX 8K" "Alexa LF/4.5k OpenGate" "Digital SLR/Full Frame" "Digital SLR/Full Frame Portrait" "Digital SLR/APS-C" "Digital SLR/APS-C Portrait" Generic/HD LatLong/360 LatLong/180}}
 addUserKnob {26 ""}
 addUserKnob {22 makeProjector l "Make Projector..." T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeProjectorNode']).makeProjectorNode()" +STARTLINE}
 addUserKnob {22 makeLinkedProjector l "Make Linked Projector..." -STARTLINE T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeProjectorNode']).makeLinkedProjectorNode()"}
 addUserKnob {26 ""}
 addUserKnob {7 hshake l "hero horiz shake" R -1 1}
 addUserKnob {7 vshake l "hero vert shake" R -1 1}
 addUserKnob {7 shakeroll l "hero shake roll" R -180 180}
 addUserKnob {7 ahshake l "ambient horiz shake" R -1 1}
 addUserKnob {7 avshake l "ambient vert shake" R -1 1}
 addUserKnob {7 ashakeroll l "ambient shake roll" R -180 180}
 addUserKnob {26 ""}
 addUserKnob {22 makeShakeCamera l "Make Shake Camera" T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeAmbientHeroShakeCamera']).makeAmbientHeroShakeCamera()" +STARTLINE}
 addUserKnob {22 makeShakeTransform l "Make Shake Transform" -STARTLINE T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeAmbientHeroShakeTransform']).makeAmbientHeroShakeTransform()"}
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 addUserKnob {1 leaf_label l Leaf}
 addUserKnob {1 ivy_version l Version}
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
push $Nbf07aa0
Dot {
 name Dot11
 xpos -2185
 ypos 1762
}
set N170e0b10 [stack 0]
push $N16e9e580
Mask3DV2 {
 name Mask3DV2_2
 note_font "Bitstream Vera Sans"
 xpos -1042
 ypos 1499
 in __position_world
 out rgba.alpha
 unpremultiply false
 center {127.0503082 16.05179977 37.94075394}
 radius {{curve*0.4 x1001 0 x1047 5 s0}}
 transform 1
 scaling {1 1 {scaling.x}}
 falloffType Cubic
 falloff 0.5
 _class Mask3D
}
push $N16ea2de0
Dot {
 name Dot12
 xpos -1170
 ypos 1365
}
set N172f16e0 [stack 0]
add_layer {__subsurface __subsurface.red __subsurface.green __subsurface.blue}
Shuffle {
 in __subsurface
 name Shuffle2
 xpos -1198
 ypos 1423
}
Keyer {
 operation "luminance key"
 range {0 0.01 1 1}
 name Keyer1
 xpos -1198
 ypos 1459
}
RotoPaint {
 cliptype none
 curves {{{v x3f99999a}
  {f 0}
  {n
   {layer Root
    {f 2097152}
    {t x44840000 x43f98000}
    {a pt1x 0 pt1y 0 pt2x 0 pt2y 0 pt3x 0 pt3y 0 pt4x 0 pt4y 0 ptex00 0 ptex01 0 ptex02 0 ptex03 0 ptex10 0 ptex11 0 ptex12 0 ptex13 0 ptex20 0 ptex21 0 ptex22 0 ptex23 0 ptex30 0 ptex31 0 ptex32 0 ptex33 0 ptof1x 0 ptof1y 0 ptof2x 0 ptof2y 0 ptof3x 0 ptof3y 0 ptof4x 0 ptof4y 0 pterr 0 ptrefset 0 ptmot x40800000 ptref 0}
    {curvegroup Ellipse1 512 bezier
     {{cc
       {f 8192}
       {px x447a4000
        {xc312e860 0}
        {x44e85fff x4400c000}
        {x4312e860 0}
        {0 xc2bdfc68}
        {x4504d000 x442bc000}
        {0 x42bdfc68}
        {x4312e860 0}
        {x44e85fff x4456c000}
        {xc312e860 0}
        {0 x42bdfc68}
        {x44c71fff x442bc000}
        {0 xc2bdfc68}}}
      {cc
       {f 8192}
       {px x447a4000
        {xc312e860 0}
        {0 xc247fff8}
        {x4312e860 0}
        {0 xc2bdfc68}
        {x42480000 0}
        {0 x42bdfc68}
        {x4312e860 0}
        {0 x42480000}
        {xc312e860 0}
        {0 x42bdfc68}
        {xc2480000 0}
        {0 xc2bdfc68}}}}
     {tx x447a4000 x44e86000 x442bc000}
     {a osw x41200000 osf 0 str 1 spx x44840000 spy x43f98000 sb 1 ltn x447a4000 ltm x447a4000 tt x40e00000}}}}}}
 toolbox {selectAll {
  { selectAll str 1 ssx 1 ssy 1 sf 1 }
  { createBezier str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createBezierCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createBSpline str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createEllipse str 1 ssx 1 ssy 1 sf 1 sb 1 tt 7 }
  { createRectangle str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createRectangleCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { brush str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { eraser src 2 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { clone src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { reveal src 3 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { dodge src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { burn src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { blur src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { sharpen src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { smear src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
} }
 toolbar_brush_hardness 0.200000003
 toolbar_source_transform_scale {1 1}
 toolbar_source_transform_center {1056 499}
 colorOverlay {0 0 0 0}
 lifetime_type "all frames"
 lifetime_start 1001
 lifetime_end 1001
 motionblur_shutter_offset_type centred
 source_black_outside true
 name RotoPaint2
 xpos -1198
 ypos 1495
}
push $N172f16e0
Dot {
 name Dot14
 xpos -1292
 ypos 1365
}
set N1737e740 [stack 0]
add_layer {__position_reference __position_reference.x __position_reference.y __position_reference.z}
Noise3D {
 name Noise3D2
 xpos -1320
 ypos 1425
 in __position_reference
 to0 rgba.alpha
 unpremultiply false
 type fBm
 axis y
 octaves 7
 lucanarity 2
 gain 0.8
 offset {20.42 0 20.42}
 uniform_scale 2
}
Grade {
 channels alpha
 white {{curve x1001 0 x1025 1}}
 name Grade1
 xpos -1320
 ypos 1449
}
FilterErode {
 size {{curve x1001 0 s0 x1050 -25}}
 filter gaussian
 name FilterErode1
 xpos -1320
 ypos 1485
 disable true
}
push $N1737e740
Dot {
 name Dot13
 xpos -1402
 ypos 1365
}
Noise3D {
 name Noise3D1
 xpos -1430
 ypos 1427
 in __position_reference
 to0 rgba.alpha
 unpremultiply false
 type fBm
 axis y
 octaves 7
 lucanarity 2
 gain 0.8
 offset {{frame/50} 0 0}
 uniform_scale 0.1
}
Dot {
 name Dot15
 xpos -1402
 ypos 1568
}
ChannelMerge {
 inputs 2
 operation divide
 name ChannelMerge3
 xpos -1320
 ypos 1559
}
ChannelMerge {
 inputs 2
 operation multiply
 name ChannelMerge1
 xpos -1198
 ypos 1559
}
ChannelMerge {
 inputs 2
 operation multiply
 name ChannelMerge4
 xpos -1080
 ypos 1559
}
push $N16e9e580
Group {
 name Point_RadialForce
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 xpos -809
 ypos 1571
 addUserKnob {20 User}
 addUserKnob {26 info l "" +STARTLINE T "Point Radial Force v1.1\n\nApply a radial force from the center."}
 addUserKnob {26 _infoGeneral l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {4 Axis l "Force Axis" t "Define what axis to apply the force in." M {X Y Z Radial "" "" "" ""}}
 Axis Y
 addUserKnob {4 LimitType l "  Limit Type" t "Regular - will clamp the points to the edge of the distance modifier\n\nPoint Force - will act as a \"mirror\" pushing points away from the edge of the distance modifier (soften will not work in this mode)" -STARTLINE M {Regular "Point Force" "" "" "" "" ""}}
 addUserKnob {6 inverse l Inverse -STARTLINE}
 inverse true
 addUserKnob {7 Edge l Distance R 0 2}
 Edge {{curve*6 C x1001 0 x1025 3.5}}
 addUserKnob {7 Soften R 0 2}
 Soften 70
 addUserKnob {13 Position l "Radial Center" t "This defines the center of the \"Radial\" force type."}
 Position {0 0.2 0.1}
}
 Input {
  inputs 0
  name Input1
  xpos 389
  ypos -222
 }
 Dot {
  name Dot1
  xpos 423
  ypos -182
 }
set N17531790 [stack 0]
 Shuffle {
  in pos
  name Shuffle14
  xpos 501
  ypos -186
 }
 BlinkScript {
  recompileCount 2
  ProgramGroup 1
  KernelDescription "2 \"SaturationKernel\" iterate pixelWise 19300d5c883d0b869ec939055d5220c5072151e83a11f9f7685ee892074552b0 2 \"src\" Read Point \"dst\" Write Point 7 \"pFrom\" Float 1 AACAPw== \"pTo\" Float 1 AAAAPw== \"pMirror\" Float 1 AACAvw== \"pSphereCenter\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"pLimitAxis\" Int 1 AAAAAA== \"LimitType\" Int 1 AAAAAA== \"pInverse\" Bool 1 AA== 7 \"pFrom\" 1 1 \"pTo\" 1 1 \"pMirror\" 1 1 \"pSphereCenter\" 3 1 \"pLimitAxis\" 1 1 \"pLimitType\" 1 1 \"pInverse\" 1 1 0"
  kernelSource "kernel SaturationKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    float pFrom,pTo,pMirror;\n    float3 pSphereCenter;\n    int pLimitAxis;\n    int pLimitType;\n    bool pInverse;\n\n  void define() \{\n    defineParam(pFrom, \"pFrom\", 1.0f);\n    defineParam(pTo, \"pTo\", 0.5f);\n    defineParam(pMirror, \"pMirror\", -1.0f);   \n    defineParam(pSphereCenter, \"pSphereCenter\", float3(0.0f,0.0f,0.0f));        \n    defineParam(pLimitAxis, \"pLimitAxis\", 0); //0=x, 1=y, 2=z, 3=sphere.\n    defineParam(pLimitType, \"LimitType\", 0);\n    defineParam(pInverse, \"pInverse\", false);\n\n  \}\n\n  float Sigmond(float p_value,float p_from,float p_to) \{\n    float preSort,calc,postSort;\n    preSort = (p_value-p_from)*(1/(p_to));\n    calc = 2.0f / (1.0f + exp(-2.0f * preSort)) - 1.0f;\n    postSort = (calc * ((p_to)))+p_from;\n    return postSort;\n  \}\n\n  void process() \{\n    float4 input = src();\n    float inputValue = 0.0f;\n    float spherelen = 0.0f;\n\n    if (pLimitAxis == 0) \{\n        inputValue = input.x;\n    \}\n    else if (pLimitAxis == 1) \{\n        inputValue = input.y;\n    \}\n    else if (pLimitAxis == 2) \{\n        inputValue = input.z;\n    \}\n\n\n    else if (pLimitAxis == 3)\n    \{\n        inputValue = length(float3(float3(input.x,input.y,input.z) - pSphereCenter));\n        spherelen = inputValue;\n    \}\n\n    if (inputValue > pFrom && !pInverse)\{\n        if (pLimitType==0) \{\n           inputValue = pFrom;\n        \}\n        else if (pLimitType==1) \{\n            inputValue = Sigmond(inputValue,pFrom,pTo);\n        \}\n        else if (pLimitType==2) \{       \n            inputValue = pFrom-(inputValue-pFrom);\n        \}\n        else if (pLimitType==3 && pMirror<pFrom) \{     \n            while (inputValue > pFrom)\{\n                inputValue = pMirror+(inputValue-pFrom);\n            \}\n        \}\n        else \{\n            inputValue = inputValue;\n        \}\n    \}\n    else if (inputValue < pFrom && pInverse)\{\n        if (pLimitType==0) \{\n           inputValue = pFrom;\n        \}\n        else if (pLimitType==1) \{\n            inputValue = Sigmond(inputValue,pFrom,-pTo);\n        \}\n        else if (pLimitType==2) \{       \n            inputValue = pFrom-(inputValue-pFrom);\n        \}\n        else if (pLimitType==3 && -pMirror>pFrom) \{     \n            while (inputValue < pFrom)\{\n                inputValue = -pMirror+(inputValue-pFrom);\n            \}\n        \}\n        else \{\n            inputValue = inputValue;\n        \}\n    \}\n\n\n    if (pLimitAxis == 0) \{\n        input.x = inputValue;\n    \}\n    if (pLimitAxis == 1) \{\n        input.y = inputValue;\n    \}\n    if (pLimitAxis == 2) \{\n        input.z = inputValue;\n    \}\n    else if (pLimitAxis == 3 && spherelen!=0.0f)\n    \{\n        float3 tempoutput = float3(input.x,input.y,input.z)-pSphereCenter;\n        tempoutput = tempoutput * (inputValue/spherelen);\n        tempoutput += pSphereCenter;\n        input = float4(tempoutput.x,tempoutput.y,tempoutput.z,input.w);\n    \}\n\n\n    dst() = float4(input.x,input.y,input.z,input.w);\n  \}\n\};\n"
  useGPUIfAvailable false
  vectorize false
  rebuild ""
  SaturationKernel_pFrom {{parent.Edge}}
  SaturationKernel_pTo {{parent.Soften}}
  SaturationKernel_pMirror -1.04
  SaturationKernel_pSphereCenter {{parent.Position} {parent.Position} {parent.Position}}
  SaturationKernel_pLimitAxis {{parent.Axis}}
  SaturationKernel_LimitType {{parent.LimitType+1}}
  SaturationKernel_pInverse {{parent.inverse}}
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos 501
  ypos -77
 }
 Shuffle {
  out pos
  name Shuffle13
  xpos 501
  ypos 34
 }
push $N17531790
 Merge2 {
  inputs 2
  operation copy
  bbox B
  Achannels pos
  Bchannels pos
  output pos
  name Merge1
  xpos 389
  ypos 30
 }
 Output {
  name Output1
  xpos 389
  ypos 130
 }
end_group
push $N16e9e580
Dissolve {
 inputs 2+1
 which 1
 name Dissolve2
 xpos -950
 ypos 1565
}
ShuffleCopy {
 inputs 2
 in2 pos
 red red
 green green
 blue blue
 out2 __position_world
 name ShuffleCopy2
 xpos -950
 ypos 1759
}
Group {
 inputs 2
 name Point_Render1
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 xpos -950
 ypos 2227
 addUserKnob {20 User l "Point Render" t dd}
 addUserKnob {26 info_header l "" +STARTLINE T "Point Render v1.2"}
 addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {4 RenderMode l "Render Mode" t "Some generators support multiple render modes other than just point rendering. This should be considered a experimental feature, but can be used to great effect.\n\nIn the Render Settings tab you can find more controls relating to Wire and Facet rendering modes.\n\nNote that Facet Render can be slow when really close to a object. " M {"Point Render" "Wire Render" "Facet Render (experimental)" "" "" ""}}
 addUserKnob {7 FocalLength l "Focal Length" t "The point render does not take the focal length from the input camera, so if you want to match it to a camera you should link the focal length from the camera to this." +INVISIBLE R 0 200}
 FocalLength 40
 addUserKnob {7 horizontalApeture l "Horiz Apeture" +INVISIBLE R 0 100}
 horizontalApeture 24.576
 addUserKnob {14 overscan l Overscan R 0 100}
 addUserKnob {7 AlphaMultiplier l Exposure t "This is a general exposure modifier that lets you adjust the overall brightness of the render." R 0 2}
 AlphaMultiplier 1
 addUserKnob {6 OutputZdepth l "Output Z-depth" t "Will output a Z-depth channel. This will cause reduced rendering performence." +STARTLINE}
 addUserKnob {6 UseOcclusionMap l "Use Occlusion Map" t "Enable the Occlusion map input. This lets you use a depth map as a holdout.\n\nNote:\nThe Red channal should contain the depth (absolute distance, not 1/depth)\nThe Alpha channal must be 1 for the areas that you want to holdout." +STARTLINE}
 addUserKnob {4 occ_method l "" t "Real Depth - input RGB should be the distance to the camera, and A should be the alpha (White occlude, Black ingore).\n\n1/depth.z (Scanline Render) - Will use the depth.Z channal from the scanline render and convert to real depth internally. Alpha is still required." -STARTLINE M {"Real Depth" "1/depth.z (Scanline Render)" ""}}
 occ_method "1/depth.z (Scanline Render)"
 addUserKnob {26 devider_cc l "<b><font color=#7DADF9>Preview</font><b>"}
 addUserKnob {6 FastPreview l "Fast Preview" t "Reduce the number of points for a quick preview of the final render." +STARTLINE}
 addUserKnob {6 HighlightCompression l "Hilight Compression" t "Compresses the highlights to make it easier to see bright details." +STARTLINE}
 addUserKnob {7 HighlightCeiling l "Highlight Ceiling" t "Adjust the cealing for the highlight compression." R 1 10}
 HighlightCeiling 1.15
 addUserKnob {7 Compression t "The compression amount." -STARTLINE R 0 5}
 Compression 1
 addUserKnob {26 devider_format l "<b><font color=#7DADF9>Format</font><b>"}
 addUserKnob {41 format l "output format" T Settings_Format.format}
 addUserKnob {20 WireRender l "Render Settings"}
 addUserKnob {26 devider_wirerender l "<b><font color=#7DADF9>Wire Rendering</font><b>"}
 addUserKnob {4 wire_type l "Connection Mode" t "*Normal\nConnect lines between the local neigbours of the 2d position map\n\n*Nearest\nConnect lines to the nearest points (in 3D space). This mode is limited to 100x100 points for performence reasons!" M {Normal Nearest "" "" "" "" "" "" "" ""}}
 addUserKnob {26 text l "Normal Mode Wires" T " "}
 addUserKnob {6 connect_x l x t "Connect wires in the (uv) X axis." -STARTLINE}
 connect_x true
 addUserKnob {6 connect_xy l xy t "Connect wires in the (uv) XY axis." -STARTLINE}
 connect_xy true
 addUserKnob {6 connect_y l y t "Connect wires in the (uv) Y axis." -STARTLINE}
 connect_y true
 addUserKnob {6 connect_aux l aux t "If you input a vector map into the Aux input for this node, and enable this option, you will get a wire from each point along that vector." -STARTLINE}
 addUserKnob {7 wire_maxdistance l "Max Distance" t "The maximum distance that the wires connect." R 0 10}
 wire_maxdistance 6
 addUserKnob {7 wire_Threshold l "Distance Threshold" t "Control the max distance threshold" R 0 2}
 wire_Threshold 0.5
 addUserKnob {3 wire_connections l "Max Connections" t "The maximum number of connections (Not Yet Implemented)"}
 wire_connections 4
 addUserKnob {7 maxSamples l "Max Line Samples" t "The maximum length of a line. Once a line is longer than this, it will start break up. \nThis can also be used as a creative effect if you set it low, try setting it to 10 in wire mode to get dotted lines" R 0 10000}
 maxSamples 10000
 addUserKnob {7 lineoffset l "Line Offset" t "Expand or contract the lines."}
 lineoffset 1
 addUserKnob {7 inGain l "In Gain" t "Gain the brightness of the in-point of the lines"}
 inGain 1
 addUserKnob {7 outGain l "Out Gain" t "Gain the brightness of the out-point of the lines" -STARTLINE}
 outGain 1
 addUserKnob {26 devider_facet l "<b><font color=#7DADF9>Facet Rendering</font><b>"}
 addUserKnob {4 renderMode l "Render Mode" t "Pick the desidered render mode." M {Diffuse "Local ST" Normal "Facing Ratio" UV ST "View Normal" "World Position" "" ""}}
 addUserKnob {6 facet_flatShading l "Flat Shading" t "Flat shading" +STARTLINE}
 addUserKnob {6 facet_depth l "Depth Buffer" t "Enable depth sorting to avoid additive surfaces." -STARTLINE}
 addUserKnob {6 facet_front l "Front Face" t "Render front facing facets" +STARTLINE}
 facet_front true
 addUserKnob {6 facet_backface l "Back Face" t "Render backfacing faces" -STARTLINE}
 facet_backface true
 addUserKnob {26 _1 l "<b><font color=#7DADF9>Other</font><b>"}
 addUserKnob {6 CloseX l "Close X" t "On spheres or round objects this closes the loop" +STARTLINE}
 addUserKnob {6 CloseY l "Close Y" t "On spheres or round objects this closes the loop" -STARTLINE}
 addUserKnob {20 Fog_1 l Fog}
 addUserKnob {26 Devider_Fog l "<b><font color=#7DADF9>Fog</font><b>"}
 addUserKnob {6 Fog t "Fog reduces the brightness of poins far from the camera." +STARTLINE}
 addUserKnob {7 FogNear l "Fog Near" R 0 200}
 FogNear 1
 addUserKnob {7 FogFar l "Fog Far" R 0 200}
 FogFar 150
 addUserKnob {7 FogExponent l "Fog Exponent" R 0 8}
 FogExponent 8
 addUserKnob {20 DepthOfField l "Depth of Field"}
 addUserKnob {26 devider_dof l "<b><font color=#7DADF9>Depth Of Field</font><b>"}
 addUserKnob {6 dof_enable l Enable +STARTLINE}
 addUserKnob {7 dof_focaldepth l "Focal Depth" R 0 40}
 dof_focaldepth 24.1
 addUserKnob {7 dof_dof l "Depth of Field" R 0 10}
 dof_dof 1
 addUserKnob {7 dof_maxSize l "Max Size"}
 dof_maxSize 0.6
 addUserKnob {7 dof_Aspect l "Aspect Ratio"}
 dof_Aspect 1
 addUserKnob {7 dof_bias l Bias R -3 3}
 dof_bias -0.2
 addUserKnob {4 Dof_Quality l Quality M {Low Medium High Extreme}}
 addUserKnob {20 MotionBlur}
 addUserKnob {26 devider_MotionBlur l "<b><font color=#7DADF9>Motion Blur</font><b>"}
 addUserKnob {6 mb_enable l Enable +STARTLINE}
 addUserKnob {6 Fast l "Fast (Interpolated)" -STARTLINE}
 Fast true
 addUserKnob {3 Samples}
 Samples 4
 addUserKnob {7 Shutter R 0 2}
 Shutter 0.5
 addUserKnob {4 pulldown l "Shutter Offset" M {Centered Start End ""}}
 addUserKnob {20 preview_3d l "3D Preview"}
 addUserKnob {6 Enable3DPreview l "Enable 3D Preview" t "Display a preview of the points in the Nuke 3D view." +STARTLINE}
 addUserKnob {41 pointSize l "point size" T PreviewNode.pointSize}
 addUserKnob {41 detail l "point detail" T PreviewNode.detail}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x388e8e00
  label "Output Format Manager"
  note_font_size 22
  xpos -1079
  ypos 117
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode10
  tile_color 0x388e8e00
  label "AUX Input"
  note_font_size 22
  xpos -385
  ypos 178
  bdwidth 207
  bdheight 178
 }
 BackdropNode {
  inputs 0
  name BackdropNode11
  tile_color 0x388e8e00
  label "Point Render"
  note_font_size 22
  xpos -96
  ypos 99
  bdwidth 203
  bdheight 131
 }
 BackdropNode {
  inputs 0
  name BackdropNode12
  tile_color 0x388e8e00
  label "Normal Generator\nFor Vertex Normals"
  note_font_size 22
  xpos -616
  ypos 243
  bdwidth 191
  bdheight 122
 }
 BackdropNode {
  inputs 0
  name BackdropNode13
  tile_color 0x388e8e00
  label "Ensure output format"
  note_font_size 22
  xpos -622
  ypos -41
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode14
  tile_color 0x388e8e00
  label "Motion Blur"
  note_font_size 22
  xpos -85
  ypos 255
  bdwidth 264
  bdheight 96
 }
 BackdropNode {
  inputs 0
  name BackdropNode15
  tile_color 0x388e8e00
  label "Soft Preview"
  note_font_size 22
  xpos -83
  ypos 601
  bdwidth 191
  bdheight 94
 }
 BackdropNode {
  inputs 0
  name BackdropNode16
  tile_color 0x388e8e00
  label "Final format"
  note_font_size 22
  xpos -84
  ypos 482
  bdwidth 192
  bdheight 95
 }
 BackdropNode {
  inputs 0
  name BackdropNode17
  tile_color 0x388e8e00
  label "No Clue =)"
  note_font_size 22
  xpos -385
  ypos -41
  bdwidth 160
  bdheight 87
 }
 BackdropNode {
  inputs 0
  name BackdropNode18
  tile_color 0x388e8e00
  label "Z-Depth Shuffle"
  note_font_size 22
  xpos -85
  ypos 367
  bdwidth 264
  bdheight 96
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0x388e8e00
  label Motionblur
  note_font_size 22
  xpos -672
  ypos -781
  bdwidth 258
  bdheight 246
 }
 BackdropNode {
  inputs 0
  name BackdropNode3
  tile_color 0x388e8e00
  label "Fast Preview"
  note_font_size 22
  xpos -669
  ypos -971
  bdwidth 254
  bdheight 138
 }
 BackdropNode {
  inputs 0
  name BackdropNode4
  tile_color 0x388e8e00
  label "Nearest Wire Mode Clamp"
  note_font_size 22
  xpos -666
  ypos -1184
  bdwidth 253
  bdheight 111
 }
 BackdropNode {
  inputs 0
  name BackdropNode5
  tile_color 0x388e8e00
  label Occlusion
  note_font_size 22
  xpos 208
  ypos 27
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode6
  tile_color 0x388e8e00
  label "Input Camera Container"
  note_font_size 22
  xpos -1357
  ypos 121
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode7
  tile_color 0x388e8e00
  label "3D Preview"
  note_font_size 22
  xpos -88
  ypos -45
  bdwidth 207
  bdheight 102
 }
 BackdropNode {
  inputs 0
  name BackdropNode8
  tile_color 0x388e8e00
  label "Input Format Manager"
  note_font_size 22
  xpos -526
  ypos -459
  bdwidth 208
  bdheight 97
 }
 BackdropNode {
  inputs 0
  name BackdropNode9
  tile_color 0x388e8e00
  label FOG
  note_font_size 22
  xpos -602
  ypos -253
  bdwidth 370
  bdheight 152
 }
 Input {
  inputs 0
  name InputPointData
  xpos -584
  ypos -1321
 }
 Dot {
  name Dot4
  xpos -550
  ypos -1234
 }
set N17623280 [stack 0]
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize fill
  filter Impulse
  black_outside true
  name Reformat5
  xpos -584
  ypos -906
  disable {{!parent.FastPreview==1}}
 }
 Grade {
  white 10
  name Grade2
  xpos -584
  ypos -874
  disable {{!parent.FastPreview}}
 }
 Dot {
  name Dot2
  xpos -550
  ypos -712
 }
set N176478c0 [stack 0]
 Group {
  name FrameHold3
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -501
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame+1}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot6
  xpos -467
  ypos -659
 }
set N176678a0 [stack 0]
push $N176478c0
 Group {
  name FrameHold2
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -660
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot5
  xpos -626
  ypos -659
 }
set N17687710 [stack 0]
 Dissolve {
  inputs 2
  which {{frame-floor(frame)}}
  name Dissolve1
  xpos -582
  ypos -666
  disable {{1-parent.mb_enable}}
 }
set N1768c270 [stack 0]
push $N176478c0
 Switch {
  inputs 2
  which {{parent.Fast}}
  name Switch2
  xpos -584
  ypos -567
 }
 Dot {
  name DataFetch
  label "data fetch\t"
  note_font_color 0xff21ff
  xpos -550
  ypos -513
  addUserKnob {20 User}
  addUserKnob {3 n_particles l "Number of Particles"}
  addUserKnob {3 gentype l "Type Of Generator"}
  addUserKnob {26 info l "" -STARTLINE T "0 = unknown, 1 = Card, 2 = Sphere, 3 = Grid"}
 }
set N1769f620 [stack 0]
 Dot {
  name Dot3
  xpos -635
  ypos -513
 }
 Dot {
  name Dot1
  xpos -635
  ypos 863
 }
 Reformat {
  inputs 0
  format "1920 1080 0 0 1920 1080 1 HD_1080"
  resize distort
  center false
  black_outside true
  name Settings_Format
  xpos -992
  ypos 209
 }
 AdjBBox {
  numpixels {{parent.overscan} {parent.overscan}}
  name AdjBBox2
  xpos -992
  ypos 241
 }
 Input {
  inputs 0
  name InputOcclusion
  xpos 238
  ypos 75
  number 2
 }
 Expression {
  expr0 depth.Z>0?1/depth.Z:0
  name Expression2
  xpos 238
  ypos 104
  disable {{!parent.occ_method}}
 }
 Constant {
  inputs 0
  channels rgb
  color 1
  format {{{parent.Settings_Format.format}}}
  name Empty
  xpos 371
  ypos 139
 }
 Switch {
  inputs 2
  which {{parent.UseOcclusionMap}}
  name Switch1
  xpos 238
  ypos 163
 }
 AdjBBox {
  numpixels {{parent.overscan} {parent.overscan}}
  name AdjBBox1
  xpos 118
  ypos 163
 }
set N176e9040 [stack 0]
 Input {
  inputs 0
  name Aux
  xpos -324
  ypos 214
  number 3
 }
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter Impulse
  black_outside true
  name Reformat2
  xpos -324
  ypos 238
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop1
  xpos -324
  ypos 462
 }
push $N1769f620
 Shuffle {
  in pos
  name Shuffle1
  xpos -584
  ypos -192
 }
set N1770fae0 [stack 0]
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter Impulse
  black_outside true
  name Reformat4
  xpos -584
  ypos 18
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop2
  xpos -584
  ypos 48
 }
 Dot {
  name Dot8
  xpos -550
  ypos 166
 }
set N17739d00 [stack 0]
 Group {
  name Point_Normal2
  tile_color 0x434343ff
  note_font_color 0x55ffffff
  xpos -584
  ypos 498
  disable {{!(renderMode==2&&RenderMode==2)}}
  addUserKnob {20 User}
  addUserKnob {26 info l "" +STARTLINE T "Point Normal v1.0"}
  addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
  addUserKnob {26 info_1 l "" +STARTLINE T "well, not much to do here =)"}
 }
  Input {
   inputs 0
   name Input1
   xpos 389
   ypos 207
  }
  Shuffle {
   in pos
   name Shuffle1
   xpos 389
   ypos 294
  }
  BlinkScript {
   kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/BasicLight.cpp
   recompileCount 69
   ProgramGroup 1
   KernelDescription "2 \"PointRender3D\" iterate pixelWise d5452fe7b684561fcfa5182d0c789025a037cc4fe4474c24e065e3fa53fcd8ce 2 \"ppos\" Read Random \"dst\" Write Point 9 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"Zoom\" Float 1 AACAPw== \"half Lambert\" Bool 1 AQ== \"light Mode\" Int 1 AAAAAA== \"light_position\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"light_color\" Float 3 AACAPwAAgD8AAIA/AAAAAA== 9 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"zoom\" 1 1 \"halfLambert\" 1 1 \"lightMode\" 1 1 \"lightPos\" 3 1 \"lightcolor\" 3 1 10 \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"namount\" Float 1 1 AAAAAA=="
   kernelSource "inline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}\n\ninline float saturate(float _in)\n\{\n    return max(0.0f,min(1.0f,_in));\n\}\n\ninline float3 reflect(float3 incidence,float3 normal)\n\{\n  return incidence - 2.f * dot(incidence, normal) * normal;\n\}\n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n    \n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    if (fabs(pScreen.x) > canvasWidth || fabs(pScreen.y) > canvasHeight) \n         return false; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eWrite> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    bool halfLambert;\n    int lightMode;\n    float3 lightPos;\n    float3 lightcolor;\n\n\n  local: //Local variables\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n    float namount; //dither amount\n\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(halfLambert, \"half Lambert\", true);\n    defineParam(lightMode, \"light Mode\", 0);\n    defineParam(lightPos,      \"light_position\", float3(0,0,0));  \n    defineParam(lightcolor,      \"light_color\", float3(1.0,1.0,1.0)); \n  \}\n\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n    namount = 0.0001; //dither amount\n  \}\n\n\n\nfloat3 Reconsile3D(float3 _PointPos)\{\n    vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n    int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    return tRaster;\n\}\n\n\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nfloat3 facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos;\n    float4 V0_Sample,V1_Sample,V2_Sample;\n    float3 normal0,normal1,normal2;\n\n    //for area calculation\n    float area;\n    float3 V0,V1,V2;\n    float3 output = float3(0.0f);\n  if (insideX) \{\n    V2_Sample = ppos(pos.x+1,pos.y);\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(pos.x+1,pos.y-1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n            float3 Normal = CalculateVertexNormals(_vWorld,V2_wPos,V1_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          //write output\n          output +=  float3(Normal.x,Normal.y,Normal.z);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,pos.y+1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n          float3 Normal = CalculateVertexNormals(_vWorld,V1_wPos,V2_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          output += float3(Normal.x,Normal.y,Normal.z);\n\n        \}\n      \}\n    \}\n  \}\n  return output;\n\}\n\n\n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 hitNormal = cross((V1 - V0),(V2 - V0)); \n        return hitNormal;\n\}\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float3 output = float3(0.0f);\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float3 point_pos = float3(_sample.x,_sample.y,_sample.z);\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n      dst() = float4(0.0f);\n      output+=facet_render(pos,float3(_sample.x,_sample.y,_sample.z))*2.0f;\n      _sample = ppos(pos.x-1,pos.y); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x-1,pos.y+1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y+1),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x,pos.y-1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x,pos.y-1),float3(_sample.x,_sample.y,_sample.z));\n\n      output = normalize(output);\n      float3 normal = -output;\n\n      \n\n\n      dst() = float4(normal.x,normal.y,normal.z,1.0f);\n    \}\n  \} //----> process\n\};\n"
   rebuild ""
   "PointRender3D_half Lambert" false
   PointRender3D_light_position {{parent.Axis1.translate} {parent.Axis1.translate} {parent.Axis1.translate}}
   PointRender3D_light_color {0 0 0}
   rebuild_finalise ""
   name BlinkScript1
   xpos 389
   ypos 344
  }
  Grade {
   multiply 0.5
   add 0.5
   black_clamp false
   name Grade1
   xpos 389
   ypos 376
   disable true
  }
  Output {
   name Output1
   xpos 389
   ypos 459
  }
  Axis2 {
   inputs 0
   translate {0.5 0.5 0.5}
   name Axis1
   xpos 661
   ypos 318
   addUserKnob {20 Ivy}
   addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
   addUserKnob {26 divider4 l "" +STARTLINE}
   addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
   _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
   addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
   addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
   addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
   _expressions {{curve}}
   addUserKnob {26 divider0 l "" +STARTLINE}
   addUserKnob {20 dbinfo l "DB Info" n 1}
   dbinfo 0
   addUserKnob {1 twig_dnuuid l "Twig Id"}
   addUserKnob {1 stalk_dnuuid l "Stalk Id"}
   addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
   addUserKnob {1 leaf_dnuuid l "Leaf Id"}
   addUserKnob {26 divider1 l "" +STARTLINE}
   addUserKnob {1 twigtype l "Twig Type"}
   addUserKnob {1 leaf_label l Leaf}
   addUserKnob {1 ivy_version l Version}
   addUserKnob {43 ivy_notes l Notes}
   addUserKnob {26 divider2 l "" +STARTLINE}
   addUserKnob {1 build_label l "Build Label"}
   addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
  }
 end_group
 Switch {
  inputs 2
  which {{parent.connect_aux}}
  name Switch3
  xpos -324
  ypos 498
 }
set N177b7320 [stack 0]
push $N1770fae0
 Expression {
  temp_name0 xd
  temp_expr0 red-Camera1.world_matrix.3
  temp_name1 yd
  temp_expr1 green-Camera1.world_matrix.7
  temp_name2 zd
  temp_expr2 blue-Camera1.world_matrix.11
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  expr3 Distance
  name Expression1
  xpos -456
  ypos -192
 }
 Grade {
  channels rgba
  blackpoint {{parent.FogFar}}
  whitepoint {{parent.FogNear}}
  gamma {{1/(parent.FogExponent+0.000000001)}}
  white_clamp true
  name Grade1
  xpos -456
  ypos -168
 }
push $N1769f620
 Dot {
  name Dot7
  xpos -307
  ypos -513
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge1
  xpos -341
  ypos -168
  disable {{!parent.Fog}}
 }
 Shuffle {
  name Shuffle3
  xpos -341
  ypos 8
 }
set N177f36a0 [stack 0]
 Shuffle {
  red white
  green white
  blue white
  name Shuffle2
  xpos -28
  ypos 76
 }
push $N17739d00
 BlinkScript {
  inputs 4
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Render/3D_PointRender_v18.cpp
  recompileCount 806
  ProgramGroup 1
  KernelDescription "2 \"PointRender3D\" iterate pixelWise b6c79b641c58390f32c944e2b5792a8702107f9cfc926636430288e7e0e1b392 5 \"ppos\" Read Random \"src\" Read Random \"normals\" Read Random \"occlusion\" Read Random \"dst\" Write Random 50 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"vertexformat\" Int 2 CgAAAAoAAAA= \"Zoom\" Float 1 AACAPw== \"Filtering Method\" Int 1 AQAAAA== \"_alphaMultiplier\" Float 1 AACAPw== \"_pointRender\" Bool 1 AQ== \"_wireRender\" Bool 1 AQ== \"_facetRender\" Bool 1 AQ== \"_maxLDistance\" Float 1 AACAPw== \"_maxLConnections\" Int 1 AQAAAA== \"_maxPlexType\" Int 1 AAAAAA== \"_plexLinedefXY\" Bool 1 AA== \"_plexLinedefX\" Bool 1 AA== \"_plexLinedefY\" Bool 1 AA== \"_plexLinedefXtoY\" Bool 1 AA== \"_plexLinedefAUX\" Bool 1 AA== \"_plexConnectX\" Bool 1 AA== \"_plexConnectY\" Bool 1 AA== \"_L_gamma\" Float 1 AACAPw== \"Enable Depth of Field\" Bool 1 AA== \"samples\" Int 1 AwAAAA== \"rings\" Int 1 BQAAAA== \"focalDepth\" Float 1 AACAPw== \"_depthOfField\" Float 1 AACAQA== \"_depthMult\" Float 1 zczMPQ== \"_maxDofSize\" Float 1 AAAAQQ== \"dof_aspect\" Float 1 AACAPw== \"dof_threshold\" Float 1 AACAPw== \"dof_gain\" Float 1 AAAAAA== \"dof_bias\" Float 1 AAAAwA== \"dof_fringe\" Float 1 AAAAAA== \"_flatshading\" Bool 1 AQ== \"_backfacing\" Bool 1 AQ== \"_frontfacing\" Bool 1 AQ== \"_vertexMode\" Int 1 AAAAAA== \"_depthBuffer\" Bool 1 AQ== \"_texoffset\" Float 2 AAAAPwAAAD8= \"_pointSize\" Int 1 AQAAAA== \"_gaussigma\" Float 1 AACAPw== \"_depthOcclusion\" Bool 1 AQ== \"depthMultiplier\" Float 1 AACAPw== \"_maxLineSteps\" Float 1 AAB6RQ== \"_lineOffset\" Float 1 AACAPw== \"_lineInMultiplier\" Float 1 AACAPw== \"_lineOutMultiplier\" Float 1 AACAPw== \"_overscan\" Float 2 AAAAAAAAAAA= \"isDepth\" Bool 1 AA== 50 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"Vformat\" 2 1 \"zoom\" 1 1 \"_filtering\" 1 1 \"_alphaMultiplier\" 1 1 \"_pointRender\" 1 1 \"_wireRender\" 1 1 \"_facetRender\" 1 1 \"_maxPlexDistance\" 1 1 \"_maxPlexConnections\" 1 1 \"_maxPlexType\" 1 1 \"_plexLinedefXY\" 1 1 \"_plexLinedefX\" 1 1 \"_plexLinedefY\" 1 1 \"_plexLinedefXtoY\" 1 1 \"_plexLinedefAUX\" 1 1 \"_plexConnectX\" 1 1 \"_plexConnectY\" 1 1 \"_plex_gamma\" 1 1 \"_dof_enable\" 1 1 \"_dof_samples\" 1 1 \"_dof_rings\" 1 1 \"focalDepth\" 1 1 \"_depthOfField\" 1 1 \"_depthMult\" 1 1 \"_maxDofSize\" 1 1 \"dof_aspect\" 1 1 \"dof_threshold\" 1 1 \"dof_gain\" 1 1 \"dof_bias\" 1 1 \"dof_fringe\" 1 1 \"_flatshading\" 1 1 \"_backfacing\" 1 1 \"_frontfacing\" 1 1 \"_vertexMode\" 1 1 \"_depthBuffer\" 1 1 \"_texoffset\" 2 1 \"_pointSize\" 1 1 \"_gaussigma\" 1 1 \"_depthOcclusion\" 1 1 \"depthMultiplier\" 1 1 \"_maxLineSteps\" 1 1 \"_lineOffset\" 1 1 \"_lineInMultiplier\" 1 1 \"_lineOutMultiplier\" 1 1 \"_overscan\" 2 1 \"isDepth\" 1 1 10 \"max_line_connections\" Int 1 1 AAAAAA== \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "//Some basic generic functions.\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float3 Cross(float3 A,float3 B)\n\{\n    return float3(A.y*B.z - A.z*B.y,A.z*B.x - A.x*B.z,A.x*B.y - A.y*B.x);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}     \n\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\ninline float mix(float _X,float _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}                                                                                              \n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n\n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight,\n    float2 overscan\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f-overscan.x || pRaster.x > imageWidth+overscan.x || \n       pRaster.y < 0.0f-overscan.y || pRaster.y > imageHeight+overscan.y || pRaster.z < 0.0f) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eRead, eAccessRandom, eEdgeClamped> src;     //The texture map\n  Image<eRead, eAccessRandom, eEdgeClamped> normals;     //The texture map  \n  Image<eRead, eAccessRandom, eEdgeClamped> occlusion;     //The texture map \n  Image<eWrite, eAccessRandom> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat,Vformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    int _filtering;        //Filter method\n    float _alphaMultiplier; //Additive multiplier\n    bool _pointRender,_wireRender,_facetRender;\n    float _maxPlexDistance; //Additive multiplier\n    int _maxPlexConnections;\n    int _maxPlexType; // 0==Grid, -1==Nearest\n    bool _plexLinedefXY,_plexLinedefX,_plexLinedefY,_plexLinedefXtoY,_plexLinedefAUX; // Define what connections NOT to include\n    bool _plexConnectX,_plexConnectY; //Connect from the edge of x to 0, or edge of y to 0, usually for spheres\n    float _plex_gamma; //The threshold making shorter paths bright and longer paths dark\n    bool _dof_enable; // Enable DOF\n    int _dof_samples; // How many samples per DOF ring\n    int _dof_rings; // How many rings \n    float focalDepth,_depthOfField,_depthMult,_maxDofSize; //DOF Settings\n    float dof_aspect; //Pixel aspect ratio\n    float dof_threshold;\n    float dof_gain;\n    float dof_bias; //bokeh edge bias\n    float dof_fringe; //bokeh chromatic aberration/fringing\n    bool _flatshading,_backfacing,_frontfacing; //Vertex rendering settings\n    int _vertexMode;  //The rendering output mode, (think AOV)\n    bool _depthBuffer; //Non-additive, only render front most pixel\n    float2 _texoffset;\n    int _pointSize;\n    float _gaussigma;\n    bool _depthOcclusion;\n    float depthMultiplier;\n    float _maxLineSteps; //cap the line length to avoid process lock\n    float _lineOffset; //Alow you to shrink or extend the lines\n    float _lineInMultiplier,_lineOutMultiplier; //Control the brightness of the wires at the tips.\n    float2 _overscan; //This will allow you to render some extra outside the bounds of the image.\n    bool isDepth; //This will allow you to render some extra outside the bounds of the image.\n\n  local: //Local variables\n    int max_line_connections;\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(Vformat,      \"vertexformat\", int2(10,10));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(_filtering, \"Filtering Method\", 1); \n    defineParam(_alphaMultiplier, \"_alphaMultiplier\", 1.0f);     \n    defineParam(_pointRender, \"_pointRender\", true);  \n    defineParam(_wireRender, \"_wireRender\", true);\n    defineParam(_facetRender, \"_facetRender\", true);\n    defineParam(_maxPlexDistance, \"_maxLDistance\", 1.0f);    \n    defineParam(_maxPlexConnections, \"_maxLConnections\", 1);    \n    defineParam(_maxPlexType, \"_maxPlexType\", 0); \n    defineParam(_plexLinedefXY, \"_plexLinedefXY\", false);      \n    defineParam(_plexLinedefXtoY, \"_plexLinedefXtoY\", false); //NYI\n    defineParam(_plexLinedefAUX, \"_plexLinedefAUX\", false); \n    defineParam(_plexLinedefX, \"_plexLinedefX\", false);  \n    defineParam(_plexLinedefY, \"_plexLinedefY\", false);  \n    defineParam(_plexConnectX, \"_plexConnectX\", false);      \n    defineParam(_plexConnectY, \"_plexConnectY\", false);   \n    defineParam(_plex_gamma, \"_L_gamma\", 1.0f);\n    //DOF SETTINGS   \n    defineParam(_dof_enable, \"Enable Depth of Field\", false);   \n    defineParam(_dof_samples, \"samples\", 3);    \n    defineParam(_dof_rings, \"rings\", 5);   \n    defineParam(focalDepth, \"focalDepth\", 1.0f);  \n    defineParam(_depthOfField, \"_depthOfField\", 4.0f);  \n    defineParam(_depthMult, \"_depthMult\", 0.1f);  \n    defineParam(_maxDofSize, \"_maxDofSize\", 8.0f);  \n    defineParam(dof_aspect, \"dof_aspect\", 1.0f);  \n    defineParam(dof_threshold, \"dof_threshold\", 1.0f);  \n    defineParam(dof_gain, \"dof_gain\", 0.0f);  \n    defineParam(dof_bias, \"dof_bias\", -2.0f);  \n    defineParam(dof_fringe, \"dof_fringe\", 0.0f); \n    //SHADING SETTINGS \n    defineParam(_flatshading, \"_flatshading\", true);  \n    defineParam(_vertexMode, \"_vertexMode\", 0);  \n    defineParam(_backfacing, \"_backfacing\", true);    \n    defineParam(_frontfacing, \"_frontfacing\", true);        \n    defineParam(_depthBuffer, \"_depthBuffer\", true);  \n    defineParam(_texoffset, \"_texoffset\", float2(0.5f,0.5f)); \n    defineParam(_pointSize, \"_pointSize\", 1); \n    defineParam(_gaussigma, \"_gaussigma\", 1.0f); \n    defineParam(_depthOcclusion, \"_depthOcclusion\", true); \n    defineParam(depthMultiplier, \"depthMultiplier\", 1.0f); \n    defineParam(_maxLineSteps, \"_maxLineSteps\", 4000.0f); \n    defineParam(_lineOffset, \"_lineOffset\", 1.0f); \n    defineParam(_lineInMultiplier, \"_lineInMultiplier\", 1.0f);   \n    defineParam(_lineOutMultiplier, \"_lineOutMultiplier\", 1.0f);     \n    defineParam(_overscan, \"_overscan\",float2(0.0f,0.0f));    \n\n  \}\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    max_line_connections = 80;\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n  \}\n\n  //Convert a 3d point position into a 2d raster position.\n  float3 Reconsile3D(float3 _PointPos)\{\n      vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      return tRaster;\n  \}\n\n//------------------------------\n//-------DRAW FUNCTIONS---------\n//------------------------------\n  //Write pixels to output.\n  void writepixel(float posx,float posy, float4 color,int index,float weight=1.0f)\n  \{ \n      if (_depthOcclusion)\{\n        float4 depthSample = occlusion(posx,posy);\n        if (depthSample.x<=vRaster.z && depthSample.w>0.0f)\{\n\n          float depth = (vRaster.z-depthSample.x);\n          color = color*(1.0f-depthSample.w);\n          color = color / (((depth*depth)*depthMultiplier)+1.0f);\n          //return;\n        \}\n      \}\n      float4 finalOutput; //This is used to store the final output\n      float4 dstSample; //This is used to store a sample of the destination\n      if ( dst.bounds.inside( posx, posy ) ) \{ //Test if the pixel written to is inside the output image. \n        if (_depthBuffer) \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          if ((dstSample.w>color.w)||dstSample.w==0.0f) \{\n            dst(posx,posy) = color;\n          \}\n        \}\n        else \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          finalOutput = dstSample + (color*_alphaMultiplier*weight);\n          finalOutput.w = dstSample.w + ((color.w*_alphaMultiplier*weight));\n\n          finalOutput.w = (dstSample.w + ((color.w*_alphaMultiplier*weight)))-(dstSample.w * ((color.w*_alphaMultiplier*weight)));\n\n          dst(posx,posy) = finalOutput;\n        \}\n      \} \n  \}\n\n  //Calculate a Bilinear Plot\n  void bilinear_Plot(float2 temppos,float4 color,int index)\n  \{\n    float2 p;\n    p.x=Frac(temppos.x);\n    p.y=Frac(temppos.y);\n    float weights\[] = \{(1.0f-p.x)*(1.0f-p.y), p.x*(1.0f-p.y), (1.0f-p.x)*p.y, p.x*p.y\};\n    int2 _position = int2(floor(temppos.x)-0,floor(temppos.y)-0); \n    writepixel(_position.x,_position.y,color,index,weights\[0]);\n    writepixel(_position.x+1,_position.y,color,index,weights\[1]);\n    writepixel(_position.x,_position.y+1,color,index,weights\[2]);\n    writepixel(_position.x+1,_position.y+1,color,index,weights\[3]);\n  \}\n\n  //NYI, unused!\n  void gaussian(float2 temppos,float4 color,int index)\{\n    float in_x = temppos.x;\n    float in_y = temppos.y;\n    int kernelSize = (_pointSize+1)*2;\n    int subsize = (kernelSize /2)-1;\n    float gKernel\[64]\[64];\n    float sigma = _gaussigma;\n    float intSigma = float(_pointSize);\n    float r, s = intSigma * sigma * sigma;\n\n    float sum = 0.0f;\n\n    // generate 5x5 kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            r = float(sqrt(x*x + y*y));\n            gKernel\[x + subsize]\[y + subsize] = (exp(-(r*r)/s))/(3.141592654f * s);\n            sum += gKernel\[x + subsize]\[y + subsize];\n        \}\n    \}\n\n    // normalize the Kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            gKernel\[x + subsize]\[y + subsize] /= sum;\n            writepixel(in_x+x,in_y+y,color,index,gKernel\[x + subsize]\[y + subsize]);\n        \}\n    \}\n  \}\n\n//-------------------------------------\n// DrawLine\n// ----------\n// Draw a line between two points, \n// x,y being 2d screenspace pos and z being depth.\n//-------------------------------------\n  void DrawLine(float3 origin, float3 endpoint,float4 _colorA,float4 _colorB) \{\n    float4 _color;\n    float3 delta = origin-endpoint;\n    float3 curPoint = origin;\n    float mag = sqrt(delta.x*delta.x+delta.y*delta.y);\n    mag = min(mag,_maxLineSteps); //Lets not go crazy, we cap it at 10.000 to avoid insane unwated processing time \n    for( float a = 0; a < mag*_lineOffset; a = a + 1.0f )\{\n      curPoint -= (delta/mag);\n      _color = (_colorA*(1.0f-(a/mag*1.0f)))+(_colorB*(a/mag*1.00f));\n      if (_dof_enable)\{\n        Bokeh(curPoint,_color);\n      \}\n      else \{\n        if (_depthBuffer && isDepth) \{_color = float4(1.0f,1.0f,1.0f,curPoint.z);\} //Added\n        bilinear_Plot(float2(curPoint.x,curPoint.y),_color,1);\n      \}\n      \n    \}\n  \}\n\n//-------------------------------------\n// Point_Render\n//-------------------------------------\nvoid point_render(int2 pos, float3 screen_pos)\{\n  float4 color = src(pos.x,pos.y);\n\n  if (_filtering == 1)\{\n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        if (_depthBuffer) \{color.w = screen_pos.z;\} //Added\n        bilinear_Plot(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  /*\n  //THIS PART NEEDS TO BE RE-WRITTEN.\n  else if (_filtering == 2)\{ \n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        gaussian(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  */\n  else \{\n      int2 _position = int2(floor(screen_pos.x),floor(screen_pos.y)); \n      if (_depthBuffer) \{color.w = screen_pos.z;\}\n      writepixel(_position.x,_position.y, color,1,1.0f); //OutputSample\n  \}\n\n\}\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nvoid facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x+1,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos,V0_N,V1_N,V2_N;\n    float2 V0_ST,V1_ST,V2_ST;\n    float4 V1_Sample,V2_Sample;\n    float4 _tn;\n    float3 normal0,normal1,normal2;\n    float2 UV_Format = float2(Vformat.x,Vformat.y);\n\n\n    int2 P0 = int2(pos.x-1,pos.y-1);\n    int2 P1 = int2(pos.x+1,pos.y+1);\n    if (_plexConnectX && pos.x == int(Vformat.x))\{\n      insideX == true;\n      P1 = int2(0.0f,pos.y+1);\n    \}\n    if (_plexConnectY && pos.y == int(Vformat.y))\{\n      insideYtop == true;\n      P1 = int2(pos.x+1,0);\n    \} \n\n    if (_plexConnectY && pos.y == 0)\{\n      insideY == true;\n      P0 = int2(pos.x-1,int(UV_Format.y));\n    \} \n\n    if (!_flatshading) \{\n      _tn = normals(pos.x,pos.y);\n      V0_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n    V0_ST = float2(pos.x,pos.y)/UV_Format;\n\n  if (insideX) \{\n    V2_Sample = ppos(P1.x,pos.y);\n    V2_ST = float2(P1.x,pos.y)/UV_Format;\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (!_flatshading) \{\n      _tn = normals(P1.x,pos.y);\n      V2_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n        \n\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(P1.x,P0.y);\n        V1_ST = float2(P1.x,P0.y)/UV_Format;\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(P1.x,P0.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}\n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V2_Pos,V1_Pos,_vWorld,V2_wPos,V1_wPos,V0_N,V2_N,V1_N,V0_ST,V2_ST,V1_ST);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,P1.y);\n        V1_ST = float2(pos.x,P1.y)/UV_Format;        \n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(pos.x,P1.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}        \n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V1_Pos,V2_Pos,_vWorld,V1_wPos,V2_wPos,V0_N,V1_N,V2_N,V0_ST,V1_ST,V2_ST);\n        \}\n      \}\n    \}\n  \}\n\}\n\n\n\n//This function will calculate if pixel C is inside the triangle\nfloat edgeFunction(float3 a, float3 b, float3 c) \n\{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n\} \n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat Distance(float3 _a,float3 _b)\n\{\n          float xd = _a.x - _b.x;\n          float yd = _a.y - _b.y;\n          float zd = _a.z - _b.z;\n          return sqrt(xd*xd + yd*yd + zd*zd);\n\}\n\nvoid DrawTriangle(float3 V0, float3 V1, float3 V2,float3 WP0, float3 WP1, float3 WP2,float3 N0, float3 N1, float3 N2, float2 st0,float2 st1,float2 st2) \{\n\n  // Precompute reciprocal of vertex z-coordinate \n  V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n\n  float2 st0n = st0 * V0.z;\n  float2 st1n = st1 * V1.z; \n  float2 st2n = st2 * V2.z; //Normal version of ST\n\n  bool inside; \n  float X0 = Fmin(V0.x,V1.x,V2.x)-1.0f;\n  float X1 = Fmax(V0.x,V1.x,V2.x)+1.0f;\n  float Y0 = Fmin(V0.y,V1.y,V2.y)-1.0f;\n  float Y1 = Fmax(V0.y,V1.y,V2.y)+1.0f;\n  float area = edgeFunction(V2, V1, V0);\n\n\n  float2 sampos = float2(st0.x*float(Vformat.x),st0.y*float(Vformat.y));\n  float4 text0 = src(sampos.x,sampos.y);\n  sampos = float2(st1.x*float(Vformat.x),st1.y*float(Vformat.y));\n  float4 text1 = src(sampos.x,sampos.y);\n  sampos = float2(st2.x*float(Vformat.x),st2.y*float(Vformat.y));  //Why do we have to do this? =(\n  float4 text2 = src(sampos.x,sampos.y);\n  sampos = float2(min(min(st0.x,st1.x),st2.x)*float(Vformat.x),min(min(st0.y,st1.y),st2.y)*float(Vformat.y));\n  float4 text3 = src(sampos.x,sampos.y);\n\n\n  for( int x = X0; x < X1 ; x++) \{\n    for( int y = Y0; y < Y1 ; y++) \{\n      float3 pixelSample(x + _texoffset.x, y + _texoffset.y,0.0f); \n\n      //This is the part where we test if the current pixel is inside the triangle\n      //We check both for front facing and back faing options\n      float w0 = edgeFunction(V1, V0, pixelSample); //Front Facing\n      float w1 = edgeFunction(V2, V1, pixelSample); \n      float w2 = edgeFunction(V0, V2, pixelSample); \n      float w3 = edgeFunction(V0, V1, pixelSample); //Back Facing\n      float w4 = edgeFunction(V1, V2, pixelSample); \n      float w5 = edgeFunction(V2, V0, pixelSample);\n\n      //writepixel(x,y, float4(w1),1,1.0f);\n      if ((w0 >= 0 && w1 >= 0 && w2 >= 0 && _frontfacing) || (w3 >= 0 && w4 >= 0 && w5 >= 0 && _backfacing)) \{ //The curent pixel is inside the triangle\n\n       // calculate vectors from point f to vertices p1, p2 and p3:\n       float3 f1 = V0-pixelSample;\n       float3 f2 = V1-pixelSample;\n       float3 f3 = V2-pixelSample;\n       // calculate the areas and factors (order of parameters doesn't matter):\n       float a = length(cross(V0-V1,V0-V2 )); // main triangle area a\n       area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n        w0 /= area; \n        w1 /= area; \n        w2 /= area; \n\n        w3 /= area; \n        w4 /= area; \n        w5 /= area; \n\n       float a1 = length(cross(f2, f3)) / a; // p1's triangle area / a\n       float a2 = length(cross(f3, f1)) / a; // p2's triangle area / a \n       float a3 = length(cross(f1, f2)) / a; // p3's triangle area / a\n       float a_magnitude = a1+a2+a3;\n       a1 = a1/a_magnitude;\n       a2 = a2/a_magnitude;\n       a3 = a3/a_magnitude;\n       float z = 1.0f / (V0.z * a1 + V1.z * a2 + V2.z * a3); \n\n\n        // find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):\n        float2 uv = st0 * a1 + st1 * a2 + st2 * a3;\n        float2 st = st0 * w0 + st1 * w1 + st2 * w2; \n        st *= z;      \n\n\n        //Calculate normals. Eighter we have flat shading, else we calculate a normal per pixel\n        float3 normalB;\n        if (_flatshading) \{\n          normalB = CalculateSurfaceNormals(WP0,WP1,WP2);\n\n        \}\n        else \{\n          float3 c0 = N2/float3(V0.z); \n          float3 c1 = N0/float3(V1.z); \n          float3 c2 = N1/float3(V2.z);  \n\n          normalB.x = w0 * c0.x + w1 * c1.x + w2 * c2.x; \n          normalB.y = w0 * c0.y + w1 * c1.y + w2 * c2.y; \n          normalB.z = w0 * c0.z + w1 * c1.z + w2 * c2.z; \n\n          normalB.x *= z, normalB.y *= z, normalB.z *= z; \n        \}\n        normalB = normalize(normalB);\n\n        //CALCULATE THE OBJECT TEXTURE COORDINATES\n        float zn = 1.0f / (V0.z * w0 + V1.z * w1 + V2.z * w2); \n        st = st0n * w0 + st1n * w1 + st2n * w2; \n        st *= zn;   \n        //--END \n\n        float3 Wpos = WP0*a1 + WP1*a2 + WP2*a3; //World Position.\n        float3 ViewNormal = normalize(float3(cameraToWorld\[3]\[0],cameraToWorld\[3]\[1],cameraToWorld\[3]\[2])-Wpos);\n\n        float nDotView =  dot(normalB,ViewNormal);\n        nDotView = 1.0f-fabs(nDotView); //make sure that the view normal ramps back around when doing backface\n        float4 tempout;\n\n        //Flatshading or regular?\n        if (!_flatshading) \{\n          tempout = text0 * a1 + text1 * a2 + text2 * a3; \n        \}\n        else\{\n          tempout = text3;\n        \}\n\n        //Additional Render Modes\n        if (_vertexMode == 1)\{\n          tempout = float4(a1,a2,a3,1.0f);\n        \}\n        else if (_vertexMode == 2)\{\n          tempout = float4(normalB.x,normalB.y,normalB.z,1.0f);\n        \}\n        else if (_vertexMode == 3)\{\n          tempout = float4(nDotView,nDotView,nDotView,1.0f);\n        \}\n        else if (_vertexMode == 4)\{\n          tempout = float4(uv.x,uv.y,0.0f,1.0f);\n        \}       \n        else if (_vertexMode == 5)\{\n          tempout = float4(st.x,st.y,0.0f,1.0f);\n        \}               \n        else if (_vertexMode == 6)\{\n          tempout = float4(ViewNormal.x,ViewNormal.y,ViewNormal.z,1.0f);\n        \}             \n        else if (_vertexMode == 7)\{\n          tempout = float4(Wpos.x,Wpos.y,Wpos.z,1.0f);\n        \}   \n\n        if (_depthBuffer)\{\n          writepixel(x,y, float4(tempout.x,tempout.y,tempout.z,z),1,1.0f);  \n        \}\n        else \{\n          if (_dof_enable)\{\n            Bokeh(float3(x,y,z),float4(tempout.x,tempout.y,tempout.z,z));\n          \}\n          else \{\n            bilinear_Plot(float2(x,y),float4(tempout.x,tempout.y,tempout.z,z),1);\n          \}\n        \}\n\n      \}  \n\n    \}\n  \}\n\}\n\n//-------------------------------------\n// Wire_Render\n//-------------------------------------\nvoid wire_render(int2 pos) \{\n  float4 temp = float4(0.0f,0.0f,0.0f,FLT_MAX);\n  float4 wire_ref_sample;\n  int2 tempXY = int2(0,0);\n  float4 plexlist\[11] = \{temp,temp,temp,temp,temp,temp,temp,temp,temp,temp,temp\}; \n  int2 plexlistXY\[11] = \{tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY\};\n  int plex_count = 0; //We use this to figure how many points that should connect.\n  float plex_dist;\n  float3 plex_position,plex_position_b;\n  float4 temp_pos, temp_pos_b; //Temporary Position Containers\n  if (_maxPlexType == -1) \{ //Used for random connection types\n    for( int x = 0; x < max_line_connections ; x++)\{ //THIS 80 NUMBER IS THE LIMIT TO AVOID TOO SLOW PROCESSING!\n      for( int y = 0; y < max_line_connections ; y++)\{\n        wire_ref_sample = ppos(x,y);\n        if (wire_ref_sample.w != 0.0f && pos.x!=x && pos.y != y) \{ \n          plex_position = float3(wire_ref_sample.x,wire_ref_sample.y,wire_ref_sample.z)*(zoom);\n          float xd = plex_position.x - vWorld.x;\n          float yd = plex_position.y - vWorld.y;\n          float zd = plex_position.z - vWorld.z;\n          float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n          if (plex_dist<_maxPlexDistance)\{\n            plex_count = min(10,plex_count+1); //Add one to the count\n            for( int h = 0; h < plex_count+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n              if (plex_dist < plexlist\[h].w) \{                  \n                for( int i = plex_count+1; i > h ; i--) \{\n                  plexlist\[i] = plexlist\[i-1];\n                  plexlistXY\[i] = plexlistXY\[i-1];\n                \}\n                plexlist\[h] = float4(plex_position.x,plex_position.y,plex_position.z,plex_dist);\n                plexlistXY\[h] = int2(x,y);\n                break;        \n              \}\n            \}\n          \} \n        \}\n      \}\n    \}\n  \}\n  else\{ //Used for standard connection types\n    float4 temp_pos;\n    bool insideX = !(Vformat.x < pos.x+1);\n    bool insideY = !(Vformat.y < pos.y+1);\n\n\n    if (!_plexLinedefAUX)\{\n      temp_pos = normals(pos.x,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,vWorld+plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideX && !_plexLinedefX) \{\n      temp_pos = ppos(pos.x+1,pos.y );\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && !_plexLinedefX) \{\n      temp_pos = ppos(0,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideY && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\}                          \n    \}\n    else if ( _plexConnectY  && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,0);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    //_plexConnect\n    if ( insideX && insideY && !_plexLinedefXY) \{              \n      temp_pos = ppos(pos.x+1,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && _plexConnectY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && insideY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectY && insideX && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n  \}   \n\n  //now that all the connections have been sorted by distance then we connect the dots.\n  for( int x = 0; x < min(_maxPlexConnections,plex_count) ; x++)\{\n    plex_position = float3(plexlist\[x].x,plexlist\[x].y,plexlist\[x].z);\n    plex_dist = plexlist\[x].w;\n\n\n    float plex_distribution = 1.0f-((plexlist\[x].w-plexlist\[0].w)/((plexlist\[min(_maxPlexConnections,plex_count)].w-plexlist\[0].w)+0.00001f)); //Where does it lie between the best and the worst distance?\n    //plexlistXY\n\n    float4 plex_col = float4(pow(1.0f-(plex_dist/_maxPlexDistance),1.0f/_plex_gamma))*float4(plex_distribution); //This one is quite cool aswell, but does leave the center ones a bit too focused \n    float4 plex_colorA = src(pos.x,pos.y);\n    float4 plex_colorB = src( plexlistXY\[x].x,plexlistXY\[x].y);\n    plex_col *= 0.1f;\n\n    computePixelCoordinates(plex_position, pRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n    if (dst.bounds.inside(int(vRaster.x),int(vRaster.y)) || dst.bounds.inside(int(pRaster.x),int(pRaster.y)))\{\n        DrawLine(vRaster,pRaster,(plex_colorA*plex_col)*_lineInMultiplier,(plex_colorB*plex_col)*_lineOutMultiplier);\n    \}\n  \}\n\}\n\nvoid wire_connection(float3 p_source,float3 p_target, float4 (&p_plexlist)\[11], int2 (&p_plexlistXY)\[11],int &p_plexcount,int2 position) \{\n  float xd = p_target.x - p_source.x;\n  float yd = p_target.y - p_source.y;\n  float zd = p_target.z - p_source.z;\n  float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n  if (plex_dist<_maxPlexDistance)\{\n    p_plexcount = min(11,p_plexcount+1); //Add one to the count\n    for( int h = 0; h < p_plexcount+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n      if (plex_dist < p_plexlist\[h].w) \{                  \n        for( int i = p_plexcount+1; i > h ; i--) \{\n          p_plexlist\[i] = p_plexlist\[i-1];\n          p_plexlistXY\[i] = p_plexlistXY\[i-1];\n        \}\n        p_plexlist\[h] = float4(p_target.x,p_target.y,p_target.z,plex_dist);\n        p_plexlistXY\[h] = int2(position.x,position.y);\n        break;        \n      \}\n    \}  \n  \}\n\}\n//-------END OF WIRE RENDER FUNCTIONS---------\n\n\n\n\n//-------------------------------\n//-------BOKEH FUNCTIONS---------\n//thanks to: http://devlog-martinsh.blogspot.dk/2011/11/glsl-depth-of-field-with-bokeh-v21.html\nfloat2 rand(float2 coord) //generating noise/pattern texture for dithering\n\{\n  float noiseX = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.25)+(Frac(coord.y*(WHformat\[1]/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.75)+(Frac(coord.y*(WHformat\[1]/2.0))*0.25))*2.0-1.0;\n  noiseX = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f))) * 43758.5453f),0.0f,1.0f)*2.0f-1.0f;\n  noiseY = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f)*2.0f)) * 43758.5453f),0.0f,1.0f)*2.0-1.0f;\n  return float2(noiseX,noiseY);\n\}\n//-------------------------------------\n// Bokeh\n//-------------------------------------\nvoid Bokeh(float3 pos,float4 color)\{\n  float blur = 0.0;\n  blur = clamp((fabs(pos.z - focalDepth)/_depthOfField)*100.0f,-_maxDofSize,_maxDofSize);\n  \n  float w = (1.0/WHformat.x)*blur;//+noise.x;\n  float h = (1.0/(WHformat.x*dof_aspect))*blur;//+noise.y;\n  float3 v3_col = float3(color.x,color.y,color.z);\n  int ringsamples;\n  float s = 1.0;  \n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples; \n    for (int j = 0 ; j < ringsamples ; j += 1)  \n    \{ \n      s += (1.0f*mix(1.0f,(float(i))/(float(_dof_rings)),dof_bias)*1.0f); //No need to do this in the loop\n    \}\n  \}\n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples;\n     \n    for (int j = 0 ; j < ringsamples ; j += 1)   \n    \{\n      float step = PI*2.0 / float(ringsamples);\n      float pw = (cos(float(j)*step)*(float(i)/_dof_rings));\n      float ph = (sin(float(j)*step)*(float(i)/_dof_rings));\n      float p = 1.0;\n\n      float posx = pos.x+((pw*w)*blur);\n      float posy = pos.y+((ph*h)*blur);\n\n\n      float3 lumcoeff = float3(0.299,0.587,0.114);\n      float lum = dot(v3_col, lumcoeff);\n      float thresh = max((lum-dof_threshold)*dof_gain, 0.0f);\n      v3_col+mix(float3(0.0),v3_col,thresh*blur);\n\n      float3 col = (v3_col*mix(1.0,(float(i))/(float(_dof_rings)),dof_bias)*p)/s; \n      bilinear_Plot(float2(posx,posy),float4(col.x,col.y,col.z,color.w/(_dof_rings*_dof_rings)),1);\n    \}\n  \}\n\}\n//-------END OF BOKEH FUNCTIONS---------\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float2 posf = float2(pos.x,pos.y);\n\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n\n      //Convert worldspace coordinates to screenspcace coordinates.\n      vWorld = float3(_sample.x,_sample.y,_sample.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, vRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      if (ret) \{ //Only create points that are visible on screen\n        if (_pointRender)\{\n          point_render(pos,vRaster);\n        \}\n      \} //Pointrender over\n\n      if (_wireRender && _maxPlexConnections>=1) \{\n        if (max(pos.x,pos.y)<=max_line_connections || (_maxPlexType==0))\{ // Don't process more wires than allowed in nearest mode.\n          wire_render(pos);\n        \}\n      \} //WireRender over\n\n      if (_facetRender) \{\n        facet_render(pos,float3(_sample.x,_sample.y,_sample.z));\n      \}  //FacetRender over\n      \n    \}\n  \} //----> process\n\};\n"
  useGPUIfAvailable false
  rebuild ""
  PointRender3D_cam_Matrix {
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
    }
  PointRender3D_focallength {{parent.Camera1.focal}}
  PointRender3D_hapeture {{parent.Camera1.haperture}}
  PointRender3D_format {{!proxy?Settings_Format.width:Settings_Format.width*proxy_scale} {!proxy?Settings_Format.height:Settings_Format.height*proxy_scale}}
  PointRender3D_vertexformat {{parent.InputFormat.box.r-1} {parent.InputFormat.box.t-1}}
  PointRender3D__alphaMultiplier {{parent.AlphaMultiplier}}
  PointRender3D__pointRender {{parent.RenderMode==0}}
  PointRender3D__wireRender {{parent.RenderMode==1}}
  PointRender3D__facetRender {{parent.RenderMode==2}}
  PointRender3D__maxLDistance {{parent.wire_maxdistance}}
  PointRender3D__maxLConnections {{parent.wire_connections}}
  PointRender3D__maxPlexType {{-parent.wire_type}}
  PointRender3D__plexLinedefXY {{!parent.connect_xy}}
  PointRender3D__plexLinedefX {{!parent.connect_x}}
  PointRender3D__plexLinedefY {{!parent.connect_y}}
  PointRender3D__plexLinedefAUX {{!connect_aux}}
  PointRender3D__plexConnectX {{parent.CloseX}}
  PointRender3D__plexConnectY {{parent.CloseY}}
  PointRender3D__L_gamma {{parent.wire_Threshold}}
  "PointRender3D_Enable Depth of Field" {{parent.dof_enable}}
  PointRender3D_samples {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_rings {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_focalDepth {{parent.dof_focaldepth}}
  PointRender3D__depthOfField {{parent.dof_dof}}
  PointRender3D__depthMult 0
  PointRender3D__maxDofSize {{parent.dof_maxSize*400}}
  PointRender3D_dof_aspect {{parent.dof_Aspect}}
  PointRender3D_dof_bias {{parent.dof_bias}}
  PointRender3D__flatshading {{parent.facet_flatShading}}
  PointRender3D__backfacing {{parent.facet_backface}}
  PointRender3D__frontfacing {{parent.facet_front}}
  PointRender3D__vertexMode {{parent.renderMode}}
  PointRender3D__texoffset {-0.5 0.5}
  PointRender3D__pointSize 0
  PointRender3D__depthOcclusion {{parent.UseOcclusionMap}}
  PointRender3D__maxLineSteps {{parent.maxSamples}}
  PointRender3D__lineOffset {{parent.lineoffset}}
  PointRender3D__lineInMultiplier {{parent.inGain}}
  PointRender3D__lineOutMultiplier {{parent.outGain}}
  PointRender3D__overscan {{parent.overscan} {parent.overscan}}
  PointRender3D_isDepth true
  format "1280 720 0 0 1280 720 1 HD_720"
  rebuild_finalise ""
  name BlinkScriptZdepth
  label Zdepth
  xpos -28
  ypos 100
 }
 Dot {
  name Dot10
  xpos 97
  ypos 112
 }
 TimeBlur {
  divisions {{parent.Samples}}
  shutter {{parent.Shutter}}
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur1
  xpos 63
  ypos 300
  disable {{1-parent.mb_enable x89 0}}
 }
 Expression {
  expr3 a!=0?a/r:0
  name Expression3
  selected true
  xpos 63
  ypos 324
 }
 Dot {
  name Dot9
  xpos 97
  ypos 414
 }
push $N176e9040
push $N177b7320
push $N177f36a0
push $N17739d00
 BlinkScript {
  inputs 4
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Render/3D_PointRender_v17.cpp
  recompileCount 803
  ProgramGroup 1
  KernelDescription "2 \"PointRender3D\" iterate pixelWise 0c100cf8a634aa2c2e18f544ec8abfd6d5d138cc25ae8f7d7127230910c2e91f 5 \"ppos\" Read Random \"src\" Read Random \"normals\" Read Random \"occlusion\" Read Random \"dst\" Write Random 49 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"vertexformat\" Int 2 CgAAAAoAAAA= \"Zoom\" Float 1 AACAPw== \"Filtering Method\" Int 1 AQAAAA== \"_alphaMultiplier\" Float 1 AACAPw== \"_pointRender\" Bool 1 AQ== \"_wireRender\" Bool 1 AQ== \"_facetRender\" Bool 1 AQ== \"_maxLDistance\" Float 1 AACAPw== \"_maxLConnections\" Int 1 AQAAAA== \"_maxPlexType\" Int 1 AAAAAA== \"_plexLinedefXY\" Bool 1 AA== \"_plexLinedefX\" Bool 1 AA== \"_plexLinedefY\" Bool 1 AA== \"_plexLinedefXtoY\" Bool 1 AA== \"_plexLinedefAUX\" Bool 1 AA== \"_plexConnectX\" Bool 1 AA== \"_plexConnectY\" Bool 1 AA== \"_L_gamma\" Float 1 AACAPw== \"Enable Depth of Field\" Bool 1 AA== \"samples\" Int 1 AwAAAA== \"rings\" Int 1 BQAAAA== \"focalDepth\" Float 1 AACAPw== \"_depthOfField\" Float 1 AACAQA== \"_depthMult\" Float 1 zczMPQ== \"_maxDofSize\" Float 1 AAAAQQ== \"dof_aspect\" Float 1 AACAPw== \"dof_threshold\" Float 1 AACAPw== \"dof_gain\" Float 1 AAAAAA== \"dof_bias\" Float 1 AAAAwA== \"dof_fringe\" Float 1 AAAAAA== \"_flatshading\" Bool 1 AQ== \"_backfacing\" Bool 1 AQ== \"_frontfacing\" Bool 1 AQ== \"_vertexMode\" Int 1 AAAAAA== \"_depthBuffer\" Bool 1 AQ== \"_texoffset\" Float 2 AAAAPwAAAD8= \"_pointSize\" Int 1 AQAAAA== \"_gaussigma\" Float 1 AACAPw== \"_depthOcclusion\" Bool 1 AQ== \"depthMultiplier\" Float 1 AACAPw== \"_maxLineSteps\" Float 1 AAB6RQ== \"_lineOffset\" Float 1 AACAPw== \"_lineInMultiplier\" Float 1 AACAPw== \"_lineOutMultiplier\" Float 1 AACAPw== \"_overscan\" Float 2 AAAAAAAAAAA= 49 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"Vformat\" 2 1 \"zoom\" 1 1 \"_filtering\" 1 1 \"_alphaMultiplier\" 1 1 \"_pointRender\" 1 1 \"_wireRender\" 1 1 \"_facetRender\" 1 1 \"_maxPlexDistance\" 1 1 \"_maxPlexConnections\" 1 1 \"_maxPlexType\" 1 1 \"_plexLinedefXY\" 1 1 \"_plexLinedefX\" 1 1 \"_plexLinedefY\" 1 1 \"_plexLinedefXtoY\" 1 1 \"_plexLinedefAUX\" 1 1 \"_plexConnectX\" 1 1 \"_plexConnectY\" 1 1 \"_plex_gamma\" 1 1 \"_dof_enable\" 1 1 \"_dof_samples\" 1 1 \"_dof_rings\" 1 1 \"focalDepth\" 1 1 \"_depthOfField\" 1 1 \"_depthMult\" 1 1 \"_maxDofSize\" 1 1 \"dof_aspect\" 1 1 \"dof_threshold\" 1 1 \"dof_gain\" 1 1 \"dof_bias\" 1 1 \"dof_fringe\" 1 1 \"_flatshading\" 1 1 \"_backfacing\" 1 1 \"_frontfacing\" 1 1 \"_vertexMode\" 1 1 \"_depthBuffer\" 1 1 \"_texoffset\" 2 1 \"_pointSize\" 1 1 \"_gaussigma\" 1 1 \"_depthOcclusion\" 1 1 \"depthMultiplier\" 1 1 \"_maxLineSteps\" 1 1 \"_lineOffset\" 1 1 \"_lineInMultiplier\" 1 1 \"_lineOutMultiplier\" 1 1 \"_overscan\" 2 1 10 \"max_line_connections\" Int 1 1 AAAAAA== \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "//Some basic generic functions.\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float3 Cross(float3 A,float3 B)\n\{\n    return float3(A.y*B.z - A.z*B.y,A.z*B.x - A.x*B.z,A.x*B.y - A.y*B.x);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}     \n\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\ninline float mix(float _X,float _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}                                                                                              \n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n\n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight,\n    float2 overscan\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f-overscan.x || pRaster.x > imageWidth+overscan.x || \n       pRaster.y < 0.0f-overscan.y || pRaster.y > imageHeight+overscan.y || pRaster.z < 0.0f) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eRead, eAccessRandom, eEdgeClamped> src;     //The texture map\n  Image<eRead, eAccessRandom, eEdgeClamped> normals;     //The texture map  \n  Image<eRead, eAccessRandom, eEdgeClamped> occlusion;     //The texture map \n  Image<eWrite, eAccessRandom> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat,Vformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    int _filtering;        //Filter method\n    float _alphaMultiplier; //Additive multiplier\n    bool _pointRender,_wireRender,_facetRender;\n    float _maxPlexDistance; //Additive multiplier\n    int _maxPlexConnections;\n    int _maxPlexType; // 0==Grid, -1==Nearest\n    bool _plexLinedefXY,_plexLinedefX,_plexLinedefY,_plexLinedefXtoY,_plexLinedefAUX; // Define what connections NOT to include\n    bool _plexConnectX,_plexConnectY; //Connect from the edge of x to 0, or edge of y to 0, usually for spheres\n    float _plex_gamma; //The threshold making shorter paths bright and longer paths dark\n    bool _dof_enable; // Enable DOF\n    int _dof_samples; // How many samples per DOF ring\n    int _dof_rings; // How many rings \n    float focalDepth,_depthOfField,_depthMult,_maxDofSize; //DOF Settings\n    float dof_aspect; //Pixel aspect ratio\n    float dof_threshold;\n    float dof_gain;\n    float dof_bias; //bokeh edge bias\n    float dof_fringe; //bokeh chromatic aberration/fringing\n    bool _flatshading,_backfacing,_frontfacing; //Vertex rendering settings\n    int _vertexMode;  //The rendering output mode, (think AOV)\n    bool _depthBuffer; //Non-additive, only render front most pixel\n    float2 _texoffset;\n    int _pointSize;\n    float _gaussigma;\n    bool _depthOcclusion;\n    float depthMultiplier;\n    float _maxLineSteps; //cap the line length to avoid process lock\n    float _lineOffset; //Alow you to shrink or extend the lines\n    float _lineInMultiplier,_lineOutMultiplier; //Control the brightness of the wires at the tips.\n    float2 _overscan; //This will allow you to render some extra outside the bounds of the image.\n\n  local: //Local variables\n    int max_line_connections;\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(Vformat,      \"vertexformat\", int2(10,10));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(_filtering, \"Filtering Method\", 1); \n    defineParam(_alphaMultiplier, \"_alphaMultiplier\", 1.0f);     \n    defineParam(_pointRender, \"_pointRender\", true);  \n    defineParam(_wireRender, \"_wireRender\", true);\n    defineParam(_facetRender, \"_facetRender\", true);\n    defineParam(_maxPlexDistance, \"_maxLDistance\", 1.0f);    \n    defineParam(_maxPlexConnections, \"_maxLConnections\", 1);    \n    defineParam(_maxPlexType, \"_maxPlexType\", 0); \n    defineParam(_plexLinedefXY, \"_plexLinedefXY\", false);      \n    defineParam(_plexLinedefXtoY, \"_plexLinedefXtoY\", false); //NYI\n    defineParam(_plexLinedefAUX, \"_plexLinedefAUX\", false); \n    defineParam(_plexLinedefX, \"_plexLinedefX\", false);  \n    defineParam(_plexLinedefY, \"_plexLinedefY\", false);  \n    defineParam(_plexConnectX, \"_plexConnectX\", false);      \n    defineParam(_plexConnectY, \"_plexConnectY\", false);   \n    defineParam(_plex_gamma, \"_L_gamma\", 1.0f);\n    //DOF SETTINGS   \n    defineParam(_dof_enable, \"Enable Depth of Field\", false);   \n    defineParam(_dof_samples, \"samples\", 3);    \n    defineParam(_dof_rings, \"rings\", 5);   \n    defineParam(focalDepth, \"focalDepth\", 1.0f);  \n    defineParam(_depthOfField, \"_depthOfField\", 4.0f);  \n    defineParam(_depthMult, \"_depthMult\", 0.1f);  \n    defineParam(_maxDofSize, \"_maxDofSize\", 8.0f);  \n    defineParam(dof_aspect, \"dof_aspect\", 1.0f);  \n    defineParam(dof_threshold, \"dof_threshold\", 1.0f);  \n    defineParam(dof_gain, \"dof_gain\", 0.0f);  \n    defineParam(dof_bias, \"dof_bias\", -2.0f);  \n    defineParam(dof_fringe, \"dof_fringe\", 0.0f); \n    //SHADING SETTINGS \n    defineParam(_flatshading, \"_flatshading\", true);  \n    defineParam(_vertexMode, \"_vertexMode\", 0);  \n    defineParam(_backfacing, \"_backfacing\", true);    \n    defineParam(_frontfacing, \"_frontfacing\", true);        \n    defineParam(_depthBuffer, \"_depthBuffer\", true);  \n    defineParam(_texoffset, \"_texoffset\", float2(0.5f,0.5f)); \n    defineParam(_pointSize, \"_pointSize\", 1); \n    defineParam(_gaussigma, \"_gaussigma\", 1.0f); \n    defineParam(_depthOcclusion, \"_depthOcclusion\", true); \n    defineParam(depthMultiplier, \"depthMultiplier\", 1.0f); \n    defineParam(_maxLineSteps, \"_maxLineSteps\", 4000.0f); \n    defineParam(_lineOffset, \"_lineOffset\", 1.0f); \n    defineParam(_lineInMultiplier, \"_lineInMultiplier\", 1.0f);   \n    defineParam(_lineOutMultiplier, \"_lineOutMultiplier\", 1.0f);     \n    defineParam(_overscan, \"_overscan\",float2(0.0f,0.0f));    \n\n  \}\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    max_line_connections = 80;\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n  \}\n\n  //Convert a 3d point position into a 2d raster position.\n  float3 Reconsile3D(float3 _PointPos)\{\n      vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      return tRaster;\n  \}\n\n//------------------------------\n//-------DRAW FUNCTIONS---------\n//------------------------------\n  //Write pixels to output.\n  void writepixel(float posx,float posy, float4 color,int index,float weight=1.0f)\n  \{ \n      if (_depthOcclusion)\{\n        float4 depthSample = occlusion(posx,posy);\n        if (depthSample.x<=vRaster.z && depthSample.w>0.0f)\{\n\n          float depth = (vRaster.z-depthSample.x);\n          color = color*(1.0f-depthSample.w);\n          color = color / (((depth*depth)*depthMultiplier)+1.0f);\n          //return;\n        \}\n      \}\n      float4 finalOutput; //This is used to store the final output\n      float4 dstSample; //This is used to store a sample of the destination\n      if ( dst.bounds.inside( posx, posy ) ) \{ //Test if the pixel written to is inside the output image. \n        if (_depthBuffer) \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          if ((dstSample.w>color.w)||dstSample.w==0.0f) \{\n            dst(posx,posy) = color;\n          \}\n        \}\n        else \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          finalOutput = dstSample + (color*_alphaMultiplier*weight);\n          finalOutput.w = dstSample.w + ((color.w*_alphaMultiplier*weight));\n\n          finalOutput.w = (dstSample.w + ((color.w*_alphaMultiplier*weight)))-(dstSample.w * ((color.w*_alphaMultiplier*weight)));\n\n          dst(posx,posy) = finalOutput;\n        \}\n      \} \n  \}\n\n  //Calculate a Bilinear Plot\n  void bilinear_Plot(float2 temppos,float4 color,int index)\n  \{\n    float2 p;\n    p.x=Frac(temppos.x);\n    p.y=Frac(temppos.y);\n    float weights\[] = \{(1.0f-p.x)*(1.0f-p.y), p.x*(1.0f-p.y), (1.0f-p.x)*p.y, p.x*p.y\};\n    int2 _position = int2(floor(temppos.x)-0,floor(temppos.y)-0); \n    writepixel(_position.x,_position.y,color,index,weights\[0]);\n    writepixel(_position.x+1,_position.y,color,index,weights\[1]);\n    writepixel(_position.x,_position.y+1,color,index,weights\[2]);\n    writepixel(_position.x+1,_position.y+1,color,index,weights\[3]);\n  \}\n\n  //NYI, unused!\n  void gaussian(float2 temppos,float4 color,int index)\{\n    float in_x = temppos.x;\n    float in_y = temppos.y;\n    int kernelSize = (_pointSize+1)*2;\n    int subsize = (kernelSize /2)-1;\n    float gKernel\[64]\[64];\n    float sigma = _gaussigma;\n    float intSigma = float(_pointSize);\n    float r, s = intSigma * sigma * sigma;\n\n    float sum = 0.0f;\n\n    // generate 5x5 kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            r = float(sqrt(x*x + y*y));\n            gKernel\[x + subsize]\[y + subsize] = (exp(-(r*r)/s))/(3.141592654f * s);\n            sum += gKernel\[x + subsize]\[y + subsize];\n        \}\n    \}\n\n    // normalize the Kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            gKernel\[x + subsize]\[y + subsize] /= sum;\n            writepixel(in_x+x,in_y+y,color,index,gKernel\[x + subsize]\[y + subsize]);\n        \}\n    \}\n  \}\n\n//-------------------------------------\n// DrawLine\n// ----------\n// Draw a line between two points, \n// x,y being 2d screenspace pos and z being depth.\n//-------------------------------------\n  void DrawLine(float3 origin, float3 endpoint,float4 _colorA,float4 _colorB) \{\n    float4 _color;\n    float3 delta = origin-endpoint;\n    float3 curPoint = origin;\n    float mag = sqrt(delta.x*delta.x+delta.y*delta.y);\n    mag = min(mag,_maxLineSteps); //Lets not go crazy, we cap it at 10.000 to avoid insane unwated processing time \n    for( float a = 0; a < mag*_lineOffset; a = a + 1.0f )\{\n      curPoint -= (delta/mag);\n      _color = (_colorA*(1.0f-(a/mag*1.0f)))+(_colorB*(a/mag*1.00f));\n      if (_dof_enable)\{\n        Bokeh(curPoint,_color);\n      \}\n      else \{\n        bilinear_Plot(float2(curPoint.x,curPoint.y),_color,1);\n      \}\n      \n    \}\n  \}\n\n//-------------------------------------\n// Point_Render\n//-------------------------------------\nvoid point_render(int2 pos, float3 screen_pos)\{\n  float4 color = src(pos.x,pos.y);\n\n  if (_filtering == 1)\{\n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        if (_depthBuffer) \{color.w = screen_pos.z;\} //Added\n        bilinear_Plot(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  /*\n  //THIS PART NEEDS TO BE RE-WRITTEN.\n  else if (_filtering == 2)\{ \n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        gaussian(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  */\n  else \{\n      int2 _position = int2(floor(screen_pos.x),floor(screen_pos.y)); \n      if (_depthBuffer) \{color.w = screen_pos.z;\}\n      writepixel(_position.x,_position.y, color,1,1.0f); //OutputSample\n  \}\n\n\}\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nvoid facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x+1,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos,V0_N,V1_N,V2_N;\n    float2 V0_ST,V1_ST,V2_ST;\n    float4 V1_Sample,V2_Sample;\n    float4 _tn;\n    float3 normal0,normal1,normal2;\n    float2 UV_Format = float2(Vformat.x,Vformat.y);\n\n\n    int2 P0 = int2(pos.x-1,pos.y-1);\n    int2 P1 = int2(pos.x+1,pos.y+1);\n    if (_plexConnectX && pos.x == int(Vformat.x))\{\n      insideX == true;\n      P1 = int2(0.0f,pos.y+1);\n    \}\n    if (_plexConnectY && pos.y == int(Vformat.y))\{\n      insideYtop == true;\n      P1 = int2(pos.x+1,0);\n    \} \n\n    if (_plexConnectY && pos.y == 0)\{\n      insideY == true;\n      P0 = int2(pos.x-1,int(UV_Format.y));\n    \} \n\n    if (!_flatshading) \{\n      _tn = normals(pos.x,pos.y);\n      V0_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n    V0_ST = float2(pos.x,pos.y)/UV_Format;\n\n  if (insideX) \{\n    V2_Sample = ppos(P1.x,pos.y);\n    V2_ST = float2(P1.x,pos.y)/UV_Format;\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (!_flatshading) \{\n      _tn = normals(P1.x,pos.y);\n      V2_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n        \n\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(P1.x,P0.y);\n        V1_ST = float2(P1.x,P0.y)/UV_Format;\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(P1.x,P0.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}\n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V2_Pos,V1_Pos,_vWorld,V2_wPos,V1_wPos,V0_N,V2_N,V1_N,V0_ST,V2_ST,V1_ST);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,P1.y);\n        V1_ST = float2(pos.x,P1.y)/UV_Format;        \n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(pos.x,P1.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}        \n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V1_Pos,V2_Pos,_vWorld,V1_wPos,V2_wPos,V0_N,V1_N,V2_N,V0_ST,V1_ST,V2_ST);\n        \}\n      \}\n    \}\n  \}\n\}\n\n\n\n//This function will calculate if pixel C is inside the triangle\nfloat edgeFunction(float3 a, float3 b, float3 c) \n\{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n\} \n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat Distance(float3 _a,float3 _b)\n\{\n          float xd = _a.x - _b.x;\n          float yd = _a.y - _b.y;\n          float zd = _a.z - _b.z;\n          return sqrt(xd*xd + yd*yd + zd*zd);\n\}\n\nvoid DrawTriangle(float3 V0, float3 V1, float3 V2,float3 WP0, float3 WP1, float3 WP2,float3 N0, float3 N1, float3 N2, float2 st0,float2 st1,float2 st2) \{\n\n  // Precompute reciprocal of vertex z-coordinate \n  V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n\n  float2 st0n = st0 * V0.z;\n  float2 st1n = st1 * V1.z; \n  float2 st2n = st2 * V2.z; //Normal version of ST\n\n  bool inside; \n  float X0 = Fmin(V0.x,V1.x,V2.x)-1.0f;\n  float X1 = Fmax(V0.x,V1.x,V2.x)+1.0f;\n  float Y0 = Fmin(V0.y,V1.y,V2.y)-1.0f;\n  float Y1 = Fmax(V0.y,V1.y,V2.y)+1.0f;\n  float area = edgeFunction(V2, V1, V0);\n\n\n  float2 sampos = float2(st0.x*float(Vformat.x),st0.y*float(Vformat.y));\n  float4 text0 = src(sampos.x,sampos.y);\n  sampos = float2(st1.x*float(Vformat.x),st1.y*float(Vformat.y));\n  float4 text1 = src(sampos.x,sampos.y);\n  sampos = float2(st2.x*float(Vformat.x),st2.y*float(Vformat.y));  //Why do we have to do this? =(\n  float4 text2 = src(sampos.x,sampos.y);\n  sampos = float2(min(min(st0.x,st1.x),st2.x)*float(Vformat.x),min(min(st0.y,st1.y),st2.y)*float(Vformat.y));\n  float4 text3 = src(sampos.x,sampos.y);\n\n\n  for( int x = X0; x < X1 ; x++) \{\n    for( int y = Y0; y < Y1 ; y++) \{\n      float3 pixelSample(x + _texoffset.x, y + _texoffset.y,0.0f); \n\n      //This is the part where we test if the current pixel is inside the triangle\n      //We check both for front facing and back faing options\n      float w0 = edgeFunction(V1, V0, pixelSample); //Front Facing\n      float w1 = edgeFunction(V2, V1, pixelSample); \n      float w2 = edgeFunction(V0, V2, pixelSample); \n      float w3 = edgeFunction(V0, V1, pixelSample); //Back Facing\n      float w4 = edgeFunction(V1, V2, pixelSample); \n      float w5 = edgeFunction(V2, V0, pixelSample);\n\n      //writepixel(x,y, float4(w1),1,1.0f);\n      if ((w0 >= 0 && w1 >= 0 && w2 >= 0 && _frontfacing) || (w3 >= 0 && w4 >= 0 && w5 >= 0 && _backfacing)) \{ //The curent pixel is inside the triangle\n\n       // calculate vectors from point f to vertices p1, p2 and p3:\n       float3 f1 = V0-pixelSample;\n       float3 f2 = V1-pixelSample;\n       float3 f3 = V2-pixelSample;\n       // calculate the areas and factors (order of parameters doesn't matter):\n       float a = length(cross(V0-V1,V0-V2 )); // main triangle area a\n       area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n        w0 /= area; \n        w1 /= area; \n        w2 /= area; \n\n        w3 /= area; \n        w4 /= area; \n        w5 /= area; \n\n       float a1 = length(cross(f2, f3)) / a; // p1's triangle area / a\n       float a2 = length(cross(f3, f1)) / a; // p2's triangle area / a \n       float a3 = length(cross(f1, f2)) / a; // p3's triangle area / a\n       float a_magnitude = a1+a2+a3;\n       a1 = a1/a_magnitude;\n       a2 = a2/a_magnitude;\n       a3 = a3/a_magnitude;\n       float z = 1.0f / (V0.z * a1 + V1.z * a2 + V2.z * a3); \n\n\n        // find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):\n        float2 uv = st0 * a1 + st1 * a2 + st2 * a3;\n        float2 st = st0 * w0 + st1 * w1 + st2 * w2; \n        st *= z;      \n\n\n        //Calculate normals. Eighter we have flat shading, else we calculate a normal per pixel\n        float3 normalB;\n        if (_flatshading) \{\n          normalB = CalculateSurfaceNormals(WP0,WP1,WP2);\n\n        \}\n        else \{\n          float3 c0 = N2/float3(V0.z); \n          float3 c1 = N0/float3(V1.z); \n          float3 c2 = N1/float3(V2.z);  \n\n          normalB.x = w0 * c0.x + w1 * c1.x + w2 * c2.x; \n          normalB.y = w0 * c0.y + w1 * c1.y + w2 * c2.y; \n          normalB.z = w0 * c0.z + w1 * c1.z + w2 * c2.z; \n\n          normalB.x *= z, normalB.y *= z, normalB.z *= z; \n        \}\n        normalB = normalize(normalB);\n\n        //CALCULATE THE OBJECT TEXTURE COORDINATES\n        float zn = 1.0f / (V0.z * w0 + V1.z * w1 + V2.z * w2); \n        st = st0n * w0 + st1n * w1 + st2n * w2; \n        st *= zn;   \n        //--END \n\n        float3 Wpos = WP0*a1 + WP1*a2 + WP2*a3; //World Position.\n        float3 ViewNormal = normalize(float3(cameraToWorld\[3]\[0],cameraToWorld\[3]\[1],cameraToWorld\[3]\[2])-Wpos);\n\n        float nDotView =  dot(normalB,ViewNormal);\n        nDotView = 1.0f-fabs(nDotView); //make sure that the view normal ramps back around when doing backface\n        float4 tempout;\n\n        //Flatshading or regular?\n        if (!_flatshading) \{\n          tempout = text0 * a1 + text1 * a2 + text2 * a3; \n        \}\n        else\{\n          tempout = text3;\n        \}\n\n        //Additional Render Modes\n        if (_vertexMode == 1)\{\n          tempout = float4(a1,a2,a3,1.0f);\n        \}\n        else if (_vertexMode == 2)\{\n          tempout = float4(normalB.x,normalB.y,normalB.z,1.0f);\n        \}\n        else if (_vertexMode == 3)\{\n          tempout = float4(nDotView,nDotView,nDotView,1.0f);\n        \}\n        else if (_vertexMode == 4)\{\n          tempout = float4(uv.x,uv.y,0.0f,1.0f);\n        \}       \n        else if (_vertexMode == 5)\{\n          tempout = float4(st.x,st.y,0.0f,1.0f);\n        \}               \n        else if (_vertexMode == 6)\{\n          tempout = float4(ViewNormal.x,ViewNormal.y,ViewNormal.z,1.0f);\n        \}             \n        else if (_vertexMode == 7)\{\n          tempout = float4(Wpos.x,Wpos.y,Wpos.z,1.0f);\n        \}   \n\n        if (_depthBuffer)\{\n          writepixel(x,y, float4(tempout.x,tempout.y,tempout.z,z),1,1.0f);  \n        \}\n        else \{\n          if (_dof_enable)\{\n            Bokeh(float3(x,y,z),float4(tempout.x,tempout.y,tempout.z,z));\n          \}\n          else \{\n            bilinear_Plot(float2(x,y),float4(tempout.x,tempout.y,tempout.z,z),1);\n          \}\n        \}\n\n      \}  \n\n    \}\n  \}\n\}\n\n//-------------------------------------\n// Wire_Render\n//-------------------------------------\nvoid wire_render(int2 pos) \{\n  float4 temp = float4(0.0f,0.0f,0.0f,FLT_MAX);\n  float4 wire_ref_sample;\n  int2 tempXY = int2(0,0);\n  float4 plexlist\[11] = \{temp,temp,temp,temp,temp,temp,temp,temp,temp,temp,temp\}; \n  int2 plexlistXY\[11] = \{tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY\};\n  int plex_count = 0; //We use this to figure how many points that should connect.\n  float plex_dist;\n  float3 plex_position,plex_position_b;\n  float4 temp_pos, temp_pos_b; //Temporary Position Containers\n  if (_maxPlexType == -1) \{ //Used for random connection types\n    for( int x = 0; x < max_line_connections ; x++)\{ //THIS 80 NUMBER IS THE LIMIT TO AVOID TOO SLOW PROCESSING!\n      for( int y = 0; y < max_line_connections ; y++)\{\n        wire_ref_sample = ppos(x,y);\n        if (wire_ref_sample.w != 0.0f && pos.x!=x && pos.y != y) \{ \n          plex_position = float3(wire_ref_sample.x,wire_ref_sample.y,wire_ref_sample.z)*(zoom);\n          float xd = plex_position.x - vWorld.x;\n          float yd = plex_position.y - vWorld.y;\n          float zd = plex_position.z - vWorld.z;\n          float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n          if (plex_dist<_maxPlexDistance)\{\n            plex_count = min(10,plex_count+1); //Add one to the count\n            for( int h = 0; h < plex_count+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n              if (plex_dist < plexlist\[h].w) \{                  \n                for( int i = plex_count+1; i > h ; i--) \{\n                  plexlist\[i] = plexlist\[i-1];\n                  plexlistXY\[i] = plexlistXY\[i-1];\n                \}\n                plexlist\[h] = float4(plex_position.x,plex_position.y,plex_position.z,plex_dist);\n                plexlistXY\[h] = int2(x,y);\n                break;        \n              \}\n            \}\n          \} \n        \}\n      \}\n    \}\n  \}\n  else\{ //Used for standard connection types\n    float4 temp_pos;\n    bool insideX = !(Vformat.x < pos.x+1);\n    bool insideY = !(Vformat.y < pos.y+1);\n\n\n    if (!_plexLinedefAUX)\{\n      temp_pos = normals(pos.x,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,vWorld+plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideX && !_plexLinedefX) \{\n      temp_pos = ppos(pos.x+1,pos.y );\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && !_plexLinedefX) \{\n      temp_pos = ppos(0,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideY && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\}                          \n    \}\n    else if ( _plexConnectY  && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,0);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    //_plexConnect\n    if ( insideX && insideY && !_plexLinedefXY) \{              \n      temp_pos = ppos(pos.x+1,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && _plexConnectY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && insideY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectY && insideX && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n  \}   \n\n  //now that all the connections have been sorted by distance then we connect the dots.\n  for( int x = 0; x < min(_maxPlexConnections,plex_count) ; x++)\{\n    plex_position = float3(plexlist\[x].x,plexlist\[x].y,plexlist\[x].z);\n    plex_dist = plexlist\[x].w;\n\n\n    float plex_distribution = 1.0f-((plexlist\[x].w-plexlist\[0].w)/((plexlist\[min(_maxPlexConnections,plex_count)].w-plexlist\[0].w)+0.00001f)); //Where does it lie between the best and the worst distance?\n    //plexlistXY\n\n    float4 plex_col = float4(pow(1.0f-(plex_dist/_maxPlexDistance),1.0f/_plex_gamma))*float4(plex_distribution); //This one is quite cool aswell, but does leave the center ones a bit too focused \n    float4 plex_colorA = src(pos.x,pos.y);\n    float4 plex_colorB = src( plexlistXY\[x].x,plexlistXY\[x].y);\n    plex_col *= 0.1f;\n\n    computePixelCoordinates(plex_position, pRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n    if (dst.bounds.inside(int(vRaster.x),int(vRaster.y)) || dst.bounds.inside(int(pRaster.x),int(pRaster.y)))\{\n        DrawLine(vRaster,pRaster,(plex_colorA*plex_col)*_lineInMultiplier,(plex_colorB*plex_col)*_lineOutMultiplier);\n    \}\n  \}\n\}\n\nvoid wire_connection(float3 p_source,float3 p_target, float4 (&p_plexlist)\[11], int2 (&p_plexlistXY)\[11],int &p_plexcount,int2 position) \{\n  float xd = p_target.x - p_source.x;\n  float yd = p_target.y - p_source.y;\n  float zd = p_target.z - p_source.z;\n  float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n  if (plex_dist<_maxPlexDistance)\{\n    p_plexcount = min(11,p_plexcount+1); //Add one to the count\n    for( int h = 0; h < p_plexcount+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n      if (plex_dist < p_plexlist\[h].w) \{                  \n        for( int i = p_plexcount+1; i > h ; i--) \{\n          p_plexlist\[i] = p_plexlist\[i-1];\n          p_plexlistXY\[i] = p_plexlistXY\[i-1];\n        \}\n        p_plexlist\[h] = float4(p_target.x,p_target.y,p_target.z,plex_dist);\n        p_plexlistXY\[h] = int2(position.x,position.y);\n        break;        \n      \}\n    \}  \n  \}\n\}\n//-------END OF WIRE RENDER FUNCTIONS---------\n\n\n\n\n//-------------------------------\n//-------BOKEH FUNCTIONS---------\n//thanks to: http://devlog-martinsh.blogspot.dk/2011/11/glsl-depth-of-field-with-bokeh-v21.html\nfloat2 rand(float2 coord) //generating noise/pattern texture for dithering\n\{\n  float noiseX = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.25)+(Frac(coord.y*(WHformat\[1]/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.75)+(Frac(coord.y*(WHformat\[1]/2.0))*0.25))*2.0-1.0;\n  noiseX = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f))) * 43758.5453f),0.0f,1.0f)*2.0f-1.0f;\n  noiseY = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f)*2.0f)) * 43758.5453f),0.0f,1.0f)*2.0-1.0f;\n  return float2(noiseX,noiseY);\n\}\n//-------------------------------------\n// Bokeh\n//-------------------------------------\nvoid Bokeh(float3 pos,float4 color)\{\n  float blur = 0.0;\n  blur = clamp((fabs(pos.z - focalDepth)/_depthOfField)*100.0f,-_maxDofSize,_maxDofSize);\n  \n  float w = (1.0/WHformat.x)*blur;//+noise.x;\n  float h = (1.0/(WHformat.x*dof_aspect))*blur;//+noise.y;\n  float3 v3_col = float3(color.x,color.y,color.z);\n  int ringsamples;\n  float s = 1.0;  \n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples; \n    for (int j = 0 ; j < ringsamples ; j += 1)  \n    \{ \n      s += (1.0f*mix(1.0f,(float(i))/(float(_dof_rings)),dof_bias)*1.0f); //No need to do this in the loop\n    \}\n  \}\n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples;\n     \n    for (int j = 0 ; j < ringsamples ; j += 1)   \n    \{\n      float step = PI*2.0 / float(ringsamples);\n      float pw = (cos(float(j)*step)*(float(i)/_dof_rings));\n      float ph = (sin(float(j)*step)*(float(i)/_dof_rings));\n      float p = 1.0;\n\n      float posx = pos.x+((pw*w)*blur);\n      float posy = pos.y+((ph*h)*blur);\n\n\n      float3 lumcoeff = float3(0.299,0.587,0.114);\n      float lum = dot(v3_col, lumcoeff);\n      float thresh = max((lum-dof_threshold)*dof_gain, 0.0f);\n      v3_col+mix(float3(0.0),v3_col,thresh*blur);\n\n      float3 col = (v3_col*mix(1.0,(float(i))/(float(_dof_rings)),dof_bias)*p)/s; \n      bilinear_Plot(float2(posx,posy),float4(col.x,col.y,col.z,color.w/(_dof_rings*_dof_rings)),1);\n    \}\n  \}\n\}\n//-------END OF BOKEH FUNCTIONS---------\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float2 posf = float2(pos.x,pos.y);\n\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n\n      //Convert worldspace coordinates to screenspcace coordinates.\n      vWorld = float3(_sample.x,_sample.y,_sample.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, vRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      if (ret) \{ //Only create points that are visible on screen\n        if (_pointRender)\{\n          point_render(pos,vRaster);\n        \}\n      \} //Pointrender over\n\n      if (_wireRender && _maxPlexConnections>=1) \{\n        if (max(pos.x,pos.y)<=max_line_connections || (_maxPlexType==0))\{ // Don't process more wires than allowed in nearest mode.\n          wire_render(pos);\n        \}\n      \} //WireRender over\n\n      if (_facetRender) \{\n        facet_render(pos,float3(_sample.x,_sample.y,_sample.z));\n      \}  //FacetRender over\n      \n    \}\n  \} //----> process\n\};\n"
  useGPUIfAvailable false
  rebuild ""
  PointRender3D_cam_Matrix {
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
    }
  PointRender3D_focallength {{parent.Camera1.focal}}
  PointRender3D_hapeture {{parent.Camera1.haperture}}
  PointRender3D_format {{!proxy?Settings_Format.width:Settings_Format.width*proxy_scale} {!proxy?Settings_Format.height:Settings_Format.height*proxy_scale}}
  PointRender3D_vertexformat {{parent.InputFormat.box.r-1} {parent.InputFormat.box.t-1}}
  PointRender3D__alphaMultiplier {{parent.AlphaMultiplier}}
  PointRender3D__pointRender {{parent.RenderMode==0}}
  PointRender3D__wireRender {{parent.RenderMode==1}}
  PointRender3D__facetRender {{parent.RenderMode==2}}
  PointRender3D__maxLDistance {{parent.wire_maxdistance}}
  PointRender3D__maxLConnections {{parent.wire_connections}}
  PointRender3D__maxPlexType {{-parent.wire_type}}
  PointRender3D__plexLinedefXY {{!parent.connect_xy}}
  PointRender3D__plexLinedefX {{!parent.connect_x}}
  PointRender3D__plexLinedefY {{!parent.connect_y}}
  PointRender3D__plexLinedefAUX {{!connect_aux}}
  PointRender3D__plexConnectX {{parent.CloseX}}
  PointRender3D__plexConnectY {{parent.CloseY}}
  PointRender3D__L_gamma {{parent.wire_Threshold}}
  "PointRender3D_Enable Depth of Field" {{parent.dof_enable}}
  PointRender3D_samples {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_rings {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_focalDepth {{parent.dof_focaldepth}}
  PointRender3D__depthOfField {{parent.dof_dof}}
  PointRender3D__depthMult 0
  PointRender3D__maxDofSize {{parent.dof_maxSize*400}}
  PointRender3D_dof_aspect {{parent.dof_Aspect}}
  PointRender3D_dof_bias {{parent.dof_bias}}
  PointRender3D__flatshading {{parent.facet_flatShading}}
  PointRender3D__backfacing {{parent.facet_backface}}
  PointRender3D__frontfacing {{parent.facet_front}}
  PointRender3D__vertexMode {{parent.renderMode}}
  PointRender3D__depthBuffer {{parent.facet_depth}}
  PointRender3D__texoffset {-0.5 0.5}
  PointRender3D__pointSize 0
  PointRender3D__depthOcclusion {{parent.UseOcclusionMap}}
  PointRender3D__maxLineSteps {{parent.maxSamples}}
  PointRender3D__lineOffset {{parent.lineoffset}}
  PointRender3D__lineInMultiplier {{parent.inGain}}
  PointRender3D__lineOutMultiplier {{parent.outGain}}
  PointRender3D__overscan {{parent.overscan} {parent.overscan}}
  format "1280 720 0 0 1280 720 1 HD_720"
  rebuild_finalise ""
  name BlinkScript1
  xpos -27
  ypos 159
 }
set N178abb80 [stack 0]
 TimeBlur {
  divisions {{parent.Samples}}
  shutter {{parent.Shutter}}
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur
  xpos -27
  ypos 301
  disable {{1-parent.mb_enable x89 0}}
 }
 ShuffleCopy {
  inputs 2
  alpha alpha2
  black alpha
  out2 depth
  name ShuffleCopy2
  xpos -27
  ypos 411
  disable {{!parent.OutputZdepth}}
 }
 CopyBBox {
  inputs 2
  name CopyBBox1
  xpos -27
  ypos 521
 }
 Reformat {
  format {{{Settings_Format.format}}}
  resize none
  center false
  pbb {{max(parent.overscan.w,parent.overscan.h)!=0}}
  name Reformat1
  xpos -27
  ypos 545
 }
 Group {
  name SoftLook
  xpos -27
  ypos 647
  disable {{!parent.HighlightCompression}}
  addUserKnob {20 User}
  addUserKnob {26 ""}
  addUserKnob {7 Add R 0 4}
  Add {{parent.HighlightCeiling}}
  addUserKnob {7 Offset R 0 4}
  Offset {{parent.Compression}}
 }
  Input {
   inputs 0
   name Input1
   xpos -248
   ypos 500
  }
set N17947a60 [stack 0]
  Expression {
   expr0 r/(r+parent.Offset)*parent.Add
   expr1 g/(g+parent.Offset)*parent.Add
   expr2 b/(b+parent.Offset)*parent.Add
   expr3 a/(a+parent.Offset)*parent.Add
   name Expression1
   xpos -339
   ypos 576
  }
push $N17947a60
  ShuffleCopy {
   inputs 2
   red red
   green green
   blue blue
   alpha alpha2
   name ShuffleCopy1
   xpos -248
   ypos 576
  }
  Output {
   name Output1
   xpos -248
   ypos 651
  }
 end_group
 ShuffleCopy {
  inputs 2
  in pos
  red red
  green green
  blue blue
  out pos
  name ShuffleCopy1
  xpos -27
  ypos 860
  disable true
 }
 Output {
  name Output1
  xpos -27
  ypos 897
 }
push $N177f36a0
 PositionToPoints2 {
  display textured
  render_mode textured
  P_channel pos
  detail 0.25
  pointSize 0.6
  name PreviewNode
  xpos -22
  ypos 8
  disable {{!parent.Enable3DPreview}}
 }
push $N17623280
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize none
  filter Impulse
  black_outside true
  name Reformat3
  xpos -633
  ypos -1109
  disable {{!wire_type==1}}
 }
push $N176678a0
push $N17687710
push $N1768c270
 Merge2 {
  inputs 2
  operation min
  Achannels {-pos.red -pos.green -pos.blue pos.alpha}
  Bchannels {-pos.red -pos.green -pos.blue pos.alpha}
  output {-pos.red -pos.green -pos.blue pos.alpha}
  name Merge4
  xpos -582
  ypos -634
 }
 Merge2 {
  inputs 2
  operation min
  Achannels {-pos.red -pos.green -pos.blue pos.alpha}
  Bchannels {-pos.red -pos.green -pos.blue pos.alpha}
  output {-pos.red -pos.green -pos.blue pos.alpha}
  name Merge5
  xpos -582
  ypos -602
 }
push $N1769f620
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -456
  ypos -402
 }
push $N178abb80
 Viewer {
  frame 36
  frame_range 1-100
  name Viewer1
  xpos -27
  ypos 325
 }
 Input {
  inputs 0
  name InputCamera
  xpos -1271
  ypos 89
  number 1
 }
 Camera {
  useMatrix true
  matrix {
      {1 0 0 0}
      {0 {1/Settings_Format.actual_format.pixel_aspect} 0 0}
      {0 0 1 0}
      {0 0 0 1}
    }
  projection_mode {{"\[value the_cam]projection_mode"}}
  focal {{"\[value \[value the_cam]focal]"}}
  haperture {{"\[value \[value the_cam]haperture]"}}
  vaperture {{"\[value \[value the_cam]vaperture]"}}
  near {{"\[value \[value the_cam]near]"}}
  far {{"\[value \[value the_cam]far]"}}
  win_translate {{"\[lindex \[value \[value the_cam]win_translate] 0]"} {"\[lindex \[value \[value the_cam]win_translate] 1]"}}
  win_scale {{"\[lindex \[value \[value the_cam]win_scale] 0]"} {"\[lindex \[value \[value the_cam]win_scale] 1]"}}
  winroll {{"\[value \[value the_cam]winroll]"}}
  focal_point {{"\[value \[value the_cam]focal_point]"}}
  fstop {{"\[value \[value the_cam]fstop]"}}
  name Camera1
  help "DummyCam by Adrian Pueyo\n\nCamera that apart from the matrices also grabs all the \"Projection\" values from the upstream camera that it's connected to. Turns into a default Camera if not Camera connected.\n\nCan also be used inside of groups and gizmos, as many levels deep as you want :D\n\nAll using live and super fast TCL.\n\nadrianpueyo.com, 2019"
  onCreate "n = nuke.thisNode()\nfor k in \[\"projection_mode\",\"focal\",\"haperture\",\"vaperture\",\"near\",\"far\",\"win_translate\",\"win_scale\",\"winroll\",\"focal_point\",\"fstop\"]:\n    n\[k].setFlag(0x0000000010000000)"
  label "(thanks to Adrian Pueyo and Ernest Dios)"
  xpos -1261
  ypos 198
  addUserKnob {20 DummyCam l Defaults}
  addUserKnob {43 the_cam +INVISIBLE}
  the_cam "\[\nset the_knob \"focal\"\nset knob_index 0\nset starting_point \"this.input0\"\nset default \"this\"\nset default \[append default \".d_\"]\n\n# If cam has no inputs, return the default...\nif \{\[exists \$starting_point]\} \{\n    set x \[node \$starting_point]\n\} \{ \n    return \$default\n\}\n\nset finished 0\nwhile \{\$finished != 1\} \{\n\n    # First look for a Cam or Input or topnode.\n    while \{\[class \$x] != \"Camera2\" && \[class \$x] != \"Camera\" && \[class \$x] != \"Input\" && \$x != \[topnode \$x]\} \{\n        set x \[node \$x.input0]\n    \}\n\n    # Then, check if node is a cam (and return), and otherwise, if it's an input, see if the parent exists and move to it.\n    if \{\[class \$x]==\"Camera2\"||\[class \$x]==\"Camera\"\} \{\n        set x \[append x \".\"]\n        return \$x\n    \} \{ \n        if \{\[class \$x]==\"Input\"\} \{ \n            set inp \"\$x.parent.input\"\n            set inputNum \[value \$x.number]\n            set inp \[append inp \$inputNum]\n            if \{\[exists \$inp]\} \{\n                set x \[node \$inp]\n            \} \{ \n                set finished 1\n            \}\n        \} \{ \n            set finished 1\n        \}\n    \}\n\}\nreturn \$default\n]"
  addUserKnob {4 d_projection_mode l projection M {perspective orthographic uv spherical ""}}
  addUserKnob {7 d_focal l focal R 0 100}
  d_focal 50
  addUserKnob {7 d_haperture l "horiz aperture" R 0 50}
  d_haperture 24.576
  addUserKnob {7 d_vaperture l "vert aperture" R 0 50}
  d_vaperture 18.672
  addUserKnob {7 d_near l near R 0 10}
  d_near 0.1
  addUserKnob {7 d_far l far R 0 10000}
  d_far 10000
  addUserKnob {12 d_win_translate l "window translate"}
  addUserKnob {12 d_win_scale l "window scale"}
  d_win_scale {1 1}
  addUserKnob {7 d_winroll l "window roll" R 0 45}
  addUserKnob {7 d_focal_point l "focal distance" R 0 10}
  d_focal_point 2
  addUserKnob {7 d_fstop l fstop R 0 30}
  d_fstop 16
  addUserKnob {26 text l " " T "<span style=\"color:#666\"><br/><b>DummyCam v1.0</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2019</span>"}
 }
end_group
StickyNote {
 inputs 0
 name StickyNote17
 label 5
 note_font_size 200
 xpos -2662
 ypos 416
}
Ramp {
 inputs 0
 p0 {649 694}
 p1 {1604 649}
 name Ramp2
 label "MASK FOR ELEMENT B"
 xpos -1790
 ypos -4474
}
FrameRange {
 first_frame 450
 last_frame 550
 time ""
 name FrameRange6
 xpos -1790
 ypos -4280
}
RotoPaint {
 inputs 0
 cliptype none
 curves {{{v x3f99999a}
  {f 0}
  {n
   {layer Root
    {f 2097152}
    {t x44800000 x44428000}
    {a pt1x 0 pt1y 0 pt2x 0 pt2y 0 pt3x 0 pt3y 0 pt4x 0 pt4y 0 ptex00 0 ptex01 0 ptex02 0 ptex03 0 ptex10 0 ptex11 0 ptex12 0 ptex13 0 ptex20 0 ptex21 0 ptex22 0 ptex23 0 ptex30 0 ptex31 0 ptex32 0 ptex33 0 ptof1x 0 ptof1y 0 ptof2x 0 ptof2y 0 ptof3x 0 ptof3y 0 ptof4x 0 ptof4y 0 pterr 0 ptrefset 0 ptmot x40800000 ptref 0}
    {curvegroup RectangleCusped1 512 bezier
     {{cc
       {f 8192}
       {px x43e80000
        {0 0}
        {x4463c000 x43060000}
        {0 0}
        {0 0}
        {x44158000 x43060000}
        {0 0}
        {0 0}
        {x44158000 x44bee000}
        {0 0}
        {0 0}
        {x4463c000 x44bee000}
        {0 0}}}
      {cc
       {f 8192}
       {p
        {{{x43e80000 0}}
      {{x43e80000 0}}}
        {{{x43e80000 0}}
      {{x43e80000 0}}}
        {{{x43e80000 0}}
      {{x43e80000 0}}}
        {{{x43e80000 0}}
      {{x43e80000 0}}}
        {{{x43e80000 0}}
      {{x43e80000 0}}}
        {{{x43e80000 0}}
      {{x43e80000 0}}}
        {{{x43e80000 0}}
      {{x43e80000 0}}}
        {{{x43e80000 0}}
      {{x43e80000 0}}}
        {{{x43e80000 0}}
      {{x43e80000 0}}}
        {{{x43e80000 0}}
      {{x43e80000 0}}}
        {{{x43e80000 0}}
      {{x43e80000 0}}}
        {{{x43e80000 0}}
      {{x43e80000 0}}}}}}
     {tx x43e80000 x443ca000 x444fa000}
     {a osw x41200000 osf 0 str 1 spx x44800000 spy x44428000 sb 1 ltn x43e80000 ltm x43e80000 tt x41100000}}}}}}
 toolbox {selectAll {
  { selectAll str 1 ssx 1 ssy 1 sf 1 }
  { createBezier str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createBezierCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createBSpline str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createEllipse str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createRectangle str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createRectangleCusped str 1 ssx 1 ssy 1 sf 1 sb 1 tt 9 }
  { brush str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { eraser src 2 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { clone src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { reveal src 3 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { dodge src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { burn src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { blur src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { sharpen src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { smear src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
} }
 toolbar_brush_hardness 0.200000003
 toolbar_source_transform_scale {1 1}
 toolbar_source_transform_center {1024 778}
 colorOverlay {0 0 0 0}
 lifetime_type "all frames"
 lifetime_start 464
 lifetime_end 464
 motionblur_shutter_offset_type centred
 source_black_outside true
 name RotoPaint1
 label "MASK FOR ELEMENT A"
 xpos -1920
 ypos -4471
}
FrameRange {
 first_frame 450
 last_frame 550
 time ""
 name FrameRange5
 xpos -1920
 ypos -4281
}
AppendClip {
 inputs 2
 firstFrame 450
 meta_from_first false
 time ""
 name AppendClip2
 xpos -1867
 ypos -4227
}
Dot {
 name Dot42
 xpos -1839
 ypos -3886
}
set N17ab88d0 [stack 0]
push $N17ab88d0
push $N17ab88d0
Radial {
 inputs 0
 area {{curve x423 291 x501 1096.25} {curve x423 430.5 x501 361.625} {curve x423 941 x501 1627.75} {curve x423 1073.5 x501 862.375}}
 color {1 0 0 1}
 name ELEMENT_B
 xpos -2149
 ypos -4500
}
FrameRange {
 first_frame 450
 last_frame 550
 time ""
 name FrameRange4
 xpos -2149
 ypos -4267
}
Radial {
 inputs 0
 area {{curve x423 291 x501 362.5} {curve x423 430.5 x501 872} {curve x423 941 x501 894} {curve x423 1073.5 x501 1372.75}}
 softness 10
 color {0 1 0 1}
 name ELEMENT_A
 xpos -2278
 ypos -4502
}
FrameRange {
 first_frame 450
 last_frame 550
 time ""
 name FrameRange3
 xpos -2278
 ypos -4269
}
AppendClip {
 inputs 2
 firstFrame 450
 meta_from_first false
 time ""
 name AppendClip1
 xpos -2278
 ypos -4214
}
EdgeDetectWrapper {
 name EdgeDetect2
 xpos -2278
 ypos -3993
}
FilterErode {
 size {{curve(((frame-450)%(549-450+1))+450) x450 -200 x550 0} 0}
 filter gaussian
 name FilterErode19
 label "!!!LOOP ANIMATION"
 xpos -2278
 ypos -3957
}
Blur {
 inputs 1+1
 size {0 100}
 name Blur5
 xpos -2278
 ypos -3902
}
Grade {
 inputs 1+1
 white {0.2397063971 0.2834104896 1 1}
 name Grade15
 xpos -2278
 ypos -3866
}
Group {
 name OrganicEdge_v1
 note_font "Bitstream Vera Sans"
 xpos -2278
 ypos -3838
 mapsize {0.15 0.15}
 addUserKnob {20 User l OrganicEdges}
 addUserKnob {41 size_2 l size T Noise1.size}
 addUserKnob {41 zoffset l seed T Noise1.zoffset}
 addUserKnob {41 uv_scale l distortion T IDistort1.uv_scale}
 addUserKnob {41 uv_offset l offset T IDistort1.uv_offset}
 addUserKnob {14 rot l disp.rotate R 0 100}
 addUserKnob {41 rotate l "all rotate" T Transform1.rotate}
 addUserKnob {26 ""}
 addUserKnob {41 size l erode T FilterErode1.size}
 addUserKnob {41 size_1 l blur T Blur1.size}
 addUserKnob {41 ClampAlpha l "Clamp Alpha" T Clamp1.ClampAlpha}
 addUserKnob {26 info l "" +STARTLINE T "lev-k\nv2"}
}
 Input {
  inputs 0
  name Input1
  xpos 140
  ypos 28
 }
set N17b3aef0 [stack 0]
 Shuffle {
  red black
  green black
  blue black
  alpha black
  name Shuffle1
  xpos 140
  ypos 116
 }
set N17b40380 [stack 0]
 Noise {
  output {rgba.red -rgba.green -rgba.blue -rgba.alpha}
  cliptype none
  replace true
  size {{Noise1.size*-1}}
  zoffset {{Noise1.zoffset}}
  rotate {{-rot.h}}
  center {1024 778}
  name Noise2
  xpos 420
  ypos 110
 }
push $N17b40380
 Noise {
  output {-rgba.red rgba.green -rgba.blue -rgba.alpha}
  cliptype none
  replace true
  size 200
  zoffset 1.8
  rotate {{-rot.w}}
  center {1024 778}
  name Noise1
  xpos 140
  ypos 174
 }
 Merge2 {
  inputs 2
  operation plus
  name Merge2
  xpos 420
  ypos 180
 }
 Shuffle {
  out forward
  name Shuffle2
  xpos 420
  ypos 206
 }
push $N17b3aef0
 FilterErode {
  name FilterErode1
  xpos -140
  ypos 116
 }
 Transform {
  center {{width/2} {height/2}}
  black_outside false
  name Transform1
  xpos -140
  ypos 244
 }
 Copy {
  inputs 2
  from0 -rgba.alpha
  to0 -rgba.alpha
  channels forward
  name Copy1
  xpos 420
  ypos 232
 }
 IDistort {
  channels alpha
  uv forward
  uv_offset 0.25
  uv_scale 600
  filter Mitchell
  name IDistort1
  xpos 420
  ypos 282
 }
 Transform {
  rotate {{-parent.Transform1.rotate}}
  center {{parent.Transform1.center} {parent.Transform1.center}}
  black_outside false
  name Transform2
  xpos 420
  ypos 320
 }
 Blur {
  channels alpha
  name Blur1
  xpos 420
  ypos 346
 }
 Clamp {
  channels alpha
  name Clamp1
  xpos 420
  ypos 392
  disable {{ClampAlpha-1}}
  addUserKnob {20 User}
  addUserKnob {6 ClampAlpha l "Clamp Alpha" t "Alpha output from this gizmo is clamped so values are in the 0-1 range.\n\nNormally, compositing math assumes alpha is within 0-1 range,\nAlphas outside of 0 - 1, such as negative values or above 1 can sometimes cause issues." +STARTLINE}
  ClampAlpha true
 }
 Output {
  name Output1
  xpos 420
  ypos 461
 }
 NoOp {
  inputs 0
  name SECRET
  label "SECRET\nSECRET\nSECRET"
  xpos -401
  ypos 56
 }
end_group
EdgeDetectWrapper {
 channels alpha
 name EdgeDetect4
 xpos -2278
 ypos -3805
}
Saturation {
 inputs 1+1
 saturation 2
 mode Maximum
 name Saturation1
 xpos -2278
 ypos -3764
}
Dot {
 name Dot41
 xpos -2250
 ypos -3499
}
set N17c1f280 [stack 0]
TimeOffset {
 time ""
 name TimeOffset_a_1
 xpos -2333
 ypos -3440
 addUserKnob {20 User}
 addUserKnob {3 no}
 no {{"\[lindex \[split \[value name] _] end]"}}
}
push $N17c1f280
TimeOffset {
 time_offset {{"(450-550-1) * (no-1)"}}
 time ""
 name TimeOffset_a_2
 xpos -2208
 ypos -3435
 addUserKnob {20 User}
 addUserKnob {3 no}
 no {{"\[lindex \[split \[value name] _] end]"}}
}
Merge2 {
 inputs 2
 name Merge13
 xpos -2268
 ypos -3354
}
StickyNote {
 inputs 0
 name StickyNote13
 label 1
 note_font_size 200
 xpos -2640
 ypos -8524
}
Read {
 inputs 0
 file_type exr
 file /jobs/TRAINVFX/REF/montreal/general_reference/data/2021/Elements/head_mask_a.exr
 localizationPolicy off
 format "2112 998 0 0 2112 998 1 "
 proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 origset true
 smartGrade true
 name Read4
 xpos -2160
 ypos -5832
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 _ivyFile "no results were found for query (Leaf) (WHERE Leaf.job = 'TRAINVFX' AND Leaf.location = '/jobs/TRAINVFX/REF/montreal/general_reference/data/2021/Elements/head_mask_a.exr' AND Leaf.deleted = '0000-00-00 00:00:00' AND Leaf.archived = '0000-00-00 00:00:00' AND Leaf.provisional = '0')"
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 addUserKnob {1 leaf_label l Leaf}
 addUserKnob {1 ivy_version l Version}
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
add_layer {maskHead maskHead.maskHead}
Shuffle {
 in maskHead
 out alpha
 name Shuffle13
 xpos -2160
 ypos -5665
}
Dot {
 name Dot39
 label "mask is under \nthe same name"
 note_font_size 41
 xpos -2132
 ypos -5559
}
Radial {
 inputs 0
 replace true
 area {872 85.5 1516 626.5}
 name Radial5
 xpos -1936
 ypos -6090
}
set Nc2c1710 [stack 0]
Group {
 inputs 0
 name AOVCodex18
 autolabel "__import__(\"dnnuke.nodes.codex_utils\", fromlist=\[\"autolabel_codex_group\"]).autolabel_codex_group()"
 tile_color 0x242424ff
 label CG_co_mcro_m_1003_environ_ludgateHill_L010_BEAUTY_v001
 note_font_color 0xffffffff
 xpos -1930
 ypos -6449
 postage_stamp true
 addUserKnob {20 AOVCodex}
 addUserKnob {1 _class l "" +STARTLINE +INVISIBLE}
 _class AOVCodex
 addUserKnob {1 _wrapper l "" +STARTLINE +INVISIBLE}
 _wrapper "AOVCodex dnnuke.nodes.aov_codex.wrapper"
 addUserKnob {22 docButton l Documentation -STARTLINE T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocs']).openDocs(nuke.thisNode())"}
 addUserKnob {26 docdivider l "" +STARTLINE}
 addUserKnob {1 file l Beauty}
 file /jobs/TRAINVFX/co_mcro_m_1003/CG/CG_co_mcro_m_1003_environ_ludgateHill_L010_BEAUTY_v001/beauty/2112x998/CG_co_mcro_m_1003_environ_ludgateHill_L010_BEAUTY_v001.####.exr
 addUserKnob {41 AOVs T Codex.aovs}
 addUserKnob {20 custom l Custom n 1}
 addUserKnob {20 custom_end l Custom n -1}
 addUserKnob {20 readknobs l "Read Knobs" n 1}
 addUserKnob {41 format T Codex.format}
 addUserKnob {41 first l "frame range" T Codex.first}
 addUserKnob {41 before l "" -STARTLINE T Codex.before}
 addUserKnob {41 last l "" -STARTLINE T Codex.last}
 addUserKnob {41 after l "" -STARTLINE T Codex.after}
 addUserKnob {41 frame_mode l frame T Codex.frame_mode}
 addUserKnob {41 frame l "" -STARTLINE T Codex.frame}
 addUserKnob {41 on_error l "missing frames" T Codex.on_error}
 addUserKnob {20 readknobsEndGroup l "Read Knobs" n -1}
 addUserKnob {20 template_tab l Template}
 addUserKnob {26 template l "script : " T CDXC_TRAINVFX_v001.nk}
 addUserKnob {26 _1 l "" +STARTLINE T " "}
 addUserKnob {22 ivy_publish l Publish... t "Publish internal nodes as a new codex template to the SHOW.<br />New AOVCodex nodes import the latest published, approved template." T "__import__('dnnuke.core.codex.publisher', fromlist=\['publish']).publish(group=nuke.thisNode())" +STARTLINE}
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 twig_dnuuid 3ec3ef28-f582-4512-96dd-815a1579d0ba
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 stalk_dnuuid 027e9c44-92bb-4099-bac5-6363953b7901
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 leaf_dnuuid aa649ab6-f44a-4994-8cc0-23129b07ca39
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 twigtype cgr
 addUserKnob {1 leaf_label l Leaf}
 leaf_label main_proxy0
 addUserKnob {1 ivy_version l Version}
 ivy_version 1
 addUserKnob {43 ivy_notes l Notes}
 ivy_notes "first test publish"
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
 MetaPython {
  inputs 0
  python "stalk_dnuuid = nuke.thisNode()\['stalk_dnuuid'].value()\n\nthis.catalog\['stalk'].clear()\nif stalk_dnuuid:\n    codex_item = codex.CodexItem.create(stalk_dnuuid, \"Stalk\")\n    this.catalog\['stalk'].append(codex_item)\n"
  name MetaStalkCreatePy
  tile_color 0x4800ff
  label "stalk_dnuuid : \[value stalk_dnuuid]"
  xpos -40
  ypos -9
  addUserKnob {20 StalkCreate}
  addUserKnob {1 stalk_dnuuid}
  stalk_dnuuid 027e9c44-92bb-4099-bac5-6363953b7901
 }
 MetaPython {
  python "if len(this.catalog\[\"stalk\"]):\n    stalk_dnuuid = this.catalog\[\"stalk\"]\[0]\[\"dnuuid\"]\n    codex_array = codex.CodexArray.create(stalk_dnuuid)\n    this.catalog\['leaf'] = codex_array.filter(codex.ItemType.deep, \"0\")\n    for item in codex_array.filter(codex.ItemType.deep, \"1\"):\n        if item.get(\"dnuuid\"):\n            data_object = item.get(\"dnuuid\").as_data_object()\n            if data_object.hasAttr(\"format\") and data_object.get(\"format\") == \"id\":\n                this.catalog\['id'].append(item)\n            else:\n                this.catalog\['leaf'].append(item)\n    this.catalog\['stalk'].clear()\n"
  name MetaLeafsFromStalk
  tile_color 0x4800ff
 }
 Codex {
  file /jobs/TRAINVFX/co_mcro_m_1003/CG/CG_co_mcro_m_1003_environ_ludgateHill_L010_BEAUTY_v001/beauty/2112x998/CG_co_mcro_m_1003_environ_ludgateHill_L010_BEAUTY_v001.####.exr
  format "2112 998 0 0 2112 998 1 "
  first 998
  last 1065
  smartGrade true
  aovs ""
  name Codex
 }
 Output {
  name Output1
 }
 StickyNote {
  inputs 0
  name StickyNote1
  label "<p>Codex Template Script\n/jobs/TRAINVFX/ASSET/ivy/cdxc/CDXC_TRAINVFX_v001/CDXC_TRAINVFX_v001.nk"
  note_font_size 12
  xpos 160
  ypos -9
 }
end_group
Remove {
 operation keep
 channels rgba
 name Remove1
 xpos -1930
 ypos -6341
}
Dot {
 name Dot38
 xpos -1902
 ypos -6151
}
set Nc5ddd10 [stack 0]
Copy {
 inputs 2
 from0 rgba.alpha
 to0 maskHead.maskHead
 name Copy2
 label "ALL CHANNELS"
 note_font_size 21
 xpos -2160
 ypos -6118
}
set Nc031ec0 [stack 0]
Shuffle {
 in maskHead
 out alpha
 name Shuffle15
 xpos -2349
 ypos -6096
}
push $Nc2c1710
push $Nc5ddd10
add_layer {rotoHead rotoHead.a rotoHead.alpha}
Copy {
 inputs 2
 from0 rgba.alpha
 to0 rotoHead.a
 name Copy3
 label "ONLY TO A CHANNEL"
 note_font_size 21
 xpos -1695
 ypos -6118
}
set N17cc6b60 [stack 0]
Shuffle {
 in {rotoHead.a -rotoHead.alpha}
 out alpha
 name Shuffle14
 xpos -1491
 ypos -6096
}
Read {
 inputs 0
 file_type exr
 file /jobs/TRAINVFX/REF/montreal/general_reference/data/2021/Elements/head_mask_b.exr
 localizationPolicy off
 format "2112 998 0 0 2112 998 1 "
 proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 origset true
 version 1
 smartGrade true
 name Read8
 xpos -1697
 ypos -5838
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 _ivyFile "no results were found for query (Leaf) (WHERE Leaf.job = 'TRAINVFX' AND Leaf.location = '/jobs/TRAINVFX/REF/montreal/general_reference/data/2021/Elements/head_mask_b.exr' AND Leaf.deleted = '0000-00-00 00:00:00' AND Leaf.archived = '0000-00-00 00:00:00' AND Leaf.provisional = '0')"
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 addUserKnob {1 leaf_label l Leaf}
 addUserKnob {1 ivy_version l Version}
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
Shuffle {
 in {rotoHead.a -rotoHead.alpha}
 out alpha
 name Shuffle16
 xpos -1697
 ypos -5668
}
Dot {
 name Dot40
 label "mask jumped from \nA to G channel"
 note_font_size 41
 xpos -1669
 ypos -5561
}
StickyNote {
 inputs 0
 name StickyNote2
 label "seems like Nuke shuffles newly added layers if you \nplace them on 1 channel, so after WRTIE you might \nfind your mask in a different channel. See the work \naround below."
 note_font_size 40
 xpos -2496
 ypos -6702
}
StickyNote {
 inputs 0
 name StickyNote16
 label 4
 note_font_size 200
 xpos -2600
 ypos -2827
}
StickyNote {
 inputs 0
 name StickyNote3
 label "In case where you have multiple element and you need to apply \none setup to all of them (with different masks) you can use the \none below. This way you have one setup for all, instead of making \ncopies or clones. The key idea is to stack all elements on one timeline,\nthen applying the setup and deviding the timeline into elements back. \nIt works even if you have animation and masks. Just loop animation \nof your nodes and plug-in mask the same way as element. For frame \nrange node use shot's lengh."
 note_font_size 40
 xpos -2468
 ypos -5054
}
StickyNote {
 inputs 0
 name StickyNote15
 label 3
 note_font_size 200
 xpos -2687
 ypos -5036
}
Group {
 inputs 0
 name AOVBundle2
 knobChanged "__import__('dnnuke.core.bundles.aov',fromlist=\['syncValues']).syncValues()"
 tile_color 0x242424ff
 label CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001
 note_font_color 0xffffffff
 xpos -2194
 ypos -2161
 postage_stamp true
 addUserKnob {20 AOVBundle}
 addUserKnob {1 data +INVISIBLE}
 data "\{\}"
 addUserKnob {6 aovbundlegroup -STARTLINE +INVISIBLE}
 aovbundlegroup true
 addUserKnob {1 _class l "" +STARTLINE +INVISIBLE}
 _class AOVBundle
 addUserKnob {1 _wrapper l "" +STARTLINE +INVISIBLE}
 _wrapper "AOVBundle dnnuke.core.bundles.wrapper"
 addUserKnob {22 docButton l Documentation T "__import__('dnnuke.utils.asst.common',fromlist=\['openDocs']).openDocs(nuke.thisNode())" +STARTLINE}
 addUserKnob {26 docdivider l "" +STARTLINE}
 addUserKnob {1 file l Beauty}
 file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/beauty/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001.####.exr
 addUserKnob {52 aovpasses l AOVs T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.bundles.aov',fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))" +STARTLINE}
 addUserKnob {20 readknobs l "Read Knobs" n 1}
 addUserKnob {17 format}
 format "1078 858 0 0 1078 858 2 "
 addUserKnob {3 first l "frame range"}
 first 1001
 addUserKnob {4 before l "" -STARTLINE M {hold loop bounce black}}
 addUserKnob {3 last l "" -STARTLINE}
 last 1107
 addUserKnob {4 after l "" -STARTLINE M {hold loop bounce black}}
 addUserKnob {4 frame_mode l frame M {expression "start at" offset}}
 addUserKnob {1 frame l "" -STARTLINE}
 addUserKnob {4 on_error l "missing frames" M {error black checkerboard "nearest frame"}}
 addUserKnob {4 on_exr_error l "incomplete frames" M {error black checkerboard}}
 addUserKnob {20 readknobsEndGroup l "Read Knobs" n -1}
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 leaf_dnuuid fcd2b88c-69e1-4cbf-bff4-1406f5b2f347
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 twigtype cgr
 addUserKnob {1 leaf_label l Leaf}
 leaf_label main_proxy0
 addUserKnob {1 ivy_version l Version}
 ivy_version 1
 addUserKnob {43 ivy_notes l Notes}
 ivy_notes "cg robot"
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/incandescent/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___incandescent.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name incandescent
  xpos -540
  ypos 2867
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/incandescent/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___incandescent.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid 2b4a5e0d-c72f-4f31-ab9e-3c5f4584a861
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label incandescent_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp1/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp1.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name light_grp1
  xpos -540
  ypos 2767
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp1/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp1.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid 9291a61c-cbff-40c6-9fd2-2f49852a8920
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label light_grp1_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp0/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp0.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name light_grp0
  xpos -540
  ypos 2667
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp0/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp0.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid ff91f3ca-8edf-459f-9c7c-359090a084fa
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label light_grp0_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp2/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp2.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name light_grp2
  xpos -540
  ypos 2567
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp2/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp2.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid 23ac8b92-4334-4f7b-b8de-168f48acc04b
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label light_grp2_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/uv_map1/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___uv_map1.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name uv_map1
  xpos -540
  ypos 2467
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/uv_map1/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___uv_map1.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid 17df6e49-6935-4f12-ad33-4e7d3e90eb71
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label uv_map1_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/specular/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___specular.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name specular
  xpos -540
  ypos 2367
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/specular/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___specular.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid 5a0efef5-0076-4e7e-a73f-f144797ca2db
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label specular_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/depth/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___depth.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name depth
  xpos -540
  ypos 2267
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/depth/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___depth.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid c5a2ddd1-0e97-462f-8cb9-8b32bfe4c354
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label depth_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp1_indirect_diffuse/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp1_indirect_diffuse.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name light_grp1_indirect_diffuse
  xpos -540
  ypos 2167
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp1_indirect_diffuse/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp1_indirect_diffuse.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid 5486b883-8563-4bb8-aaf6-a44e0682778d
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label light_grp1_indirect_diffuse_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp2_direct_diffuse/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp2_direct_diffuse.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name light_grp2_direct_diffuse
  xpos -540
  ypos 2067
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp2_direct_diffuse/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp2_direct_diffuse.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid 563f6c61-3fb7-4da6-b28a-12f3e77d179f
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label light_grp2_direct_diffuse_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/motion_vector/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___motion_vector.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name motion_vector
  xpos -540
  ypos 1967
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/motion_vector/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___motion_vector.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid 1c1a7f02-99f5-4562-a7ef-a85f93b8d650
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label motion_vector_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp0_indirect_specular/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp0_indirect_specular.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name light_grp0_indirect_specular
  xpos -540
  ypos 1867
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp0_indirect_specular/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp0_indirect_specular.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid 074af015-e31a-43f6-8e5b-8961362b01d0
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label light_grp0_indirect_specular_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp1_direct_diffuse/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp1_direct_diffuse.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name light_grp1_direct_diffuse
  xpos -540
  ypos 1767
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp1_direct_diffuse/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp1_direct_diffuse.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid f1409d21-0218-46aa-b77e-22214490015b
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label light_grp1_direct_diffuse_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/diffuse/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___diffuse.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name diffuse
  xpos -540
  ypos 1667
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/diffuse/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___diffuse.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid e1ffaffa-9b03-472d-ab15-4e1f3f2527b1
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label diffuse_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp2_direct_diffuse_unoccluded/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp2_direct_diffuse_unoccluded.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name light_grp2_direct_diffuse_unoccluded
  xpos -540
  ypos 1567
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp2_direct_diffuse_unoccluded/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp2_direct_diffuse_unoccluded.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid aa53529d-28f4-4df3-a41a-b01674da81e3
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label light_grp2_direct_diffuse_unoccluded_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp0_direct_specular/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp0_direct_specular.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name light_grp0_direct_specular
  xpos -540
  ypos 1467
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp0_direct_specular/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp0_direct_specular.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid f4071494-1930-4fad-b578-78bcbd703d8d
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label light_grp0_direct_specular_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp0_direct_diffuse_unoccluded/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp0_direct_diffuse_unoccluded.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name light_grp0_direct_diffuse_unoccluded
  xpos -540
  ypos 1367
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp0_direct_diffuse_unoccluded/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp0_direct_diffuse_unoccluded.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid 102fa6b9-89ac-4304-9675-43f87b84222a
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label light_grp0_direct_diffuse_unoccluded_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp0_indirect_diffuse/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp0_indirect_diffuse.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name light_grp0_indirect_diffuse
  xpos -540
  ypos 1267
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp0_indirect_diffuse/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp0_indirect_diffuse.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid 3de21209-283c-4a44-a3f5-c42ffdb9594e
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label light_grp0_indirect_diffuse_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp1_indirect_specular/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp1_indirect_specular.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name light_grp1_indirect_specular
  xpos -540
  ypos 1167
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp1_indirect_specular/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp1_indirect_specular.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid 9fbea7bf-ea82-49d7-b520-569293eccf93
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label light_grp1_indirect_specular_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp0_direct_diffuse/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp0_direct_diffuse.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name light_grp0_direct_diffuse
  xpos -540
  ypos 1067
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp0_direct_diffuse/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp0_direct_diffuse.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid 81d9cf28-600c-4980-a628-d856dcc078c6
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label light_grp0_direct_diffuse_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp2_direct_specular/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp2_direct_specular.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name light_grp2_direct_specular
  xpos -540
  ypos 967
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp2_direct_specular/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp2_direct_specular.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid 75089a32-f409-4a78-81df-fb1693db0f01
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label light_grp2_direct_specular_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/diffuse_albedo/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___diffuse_albedo.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name diffuse_albedo
  xpos -540
  ypos 867
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/diffuse_albedo/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___diffuse_albedo.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid 9a7b3c19-bf32-43fc-ba22-a7477714b371
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label diffuse_albedo_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp2_indirect_specular/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp2_indirect_specular.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name light_grp2_indirect_specular
  xpos -540
  ypos 767
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp2_indirect_specular/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp2_indirect_specular.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid 3a3a3121-35ab-4291-80d5-6f1d1d038b98
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label light_grp2_indirect_specular_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/position_object/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___position_object.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name position_object
  xpos -540
  ypos 667
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/position_object/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___position_object.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid 7370d38b-00ec-42f3-8540-65f7f2646b86
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label position_object_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp1_direct_specular/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp1_direct_specular.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name light_grp1_direct_specular
  xpos -540
  ypos 567
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp1_direct_specular/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp1_direct_specular.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid 5910a40b-7f11-41ce-8945-3bf3e7e1aee7
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label light_grp1_direct_specular_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp1_direct_diffuse_unoccluded/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp1_direct_diffuse_unoccluded.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name light_grp1_direct_diffuse_unoccluded
  xpos -540
  ypos 467
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp1_direct_diffuse_unoccluded/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp1_direct_diffuse_unoccluded.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid fa2642d2-d193-4db3-8de1-c881c1da9d99
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label light_grp1_direct_diffuse_unoccluded_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/position_world/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___position_world.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name position_world
  xpos -540
  ypos 367
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/position_world/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___position_world.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid 989610e9-b8be-4244-b887-08dd4b4167e7
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label position_world_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp2_indirect_diffuse/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp2_indirect_diffuse.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name light_grp2_indirect_diffuse
  xpos -540
  ypos 267
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/light_grp2_indirect_diffuse/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___light_grp2_indirect_diffuse.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid c6575a31-92de-4706-bf2a-91e355d2dbdd
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label light_grp2_indirect_diffuse_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/object_id/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___object_id.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name object_id
  xpos -540
  ypos 167
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/object_id/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___object_id.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid 2cf9f6a9-d7fa-4f15-945f-4341eded236a
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label object_id_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/position_reference/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___position_reference.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name position_reference
  xpos -540
  ypos 67
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/position_reference/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___position_reference.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid 3aea12e3-aeed-42aa-aa11-6c382a6f8a08
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label position_reference_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
push 0
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/normal_world/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___normal_world.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name normal_world
  xpos -540
  ypos -33
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/normal_world/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001___normal_world.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid b0533e20-abc6-49f8-8edc-58d67840d333
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label normal_world_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
 Read {
  inputs 0
  file_type exr
  file /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/beauty/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001.####.exr
  localizationPolicy off
  format "1078 858 0 0 1078 858 2 "
  proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  first 1001
  last 1107
  origfirst 1001
  origlast 1107
  origset true
  smartGrade true
  name main
  xpos -40
  ypos -27
  postage_stamp_frame 1054
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  _ivyFile /jobs/TRAINVFX/co_core_m_1006/CG/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001/beauty/1078x858/CG_co_core_m_1006_lighting_character_L020_BEAUTY_v001.####.exr
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  twig_dnuuid 4173137b-013d-4622-85d2-693f793eb1b5
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  stalk_dnuuid 2de24be3-8827-4c7d-94fc-00a4e62488d6
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  twigtype_dnuuid 053253ae-c7cf-4d13-b22e-1219a8e5951e
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  leaf_dnuuid fcd2b88c-69e1-4cbf-bff4-1406f5b2f347
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  twigtype cgr
  addUserKnob {1 leaf_label l Leaf}
  leaf_label main_proxy0
  addUserKnob {1 ivy_version l Version}
  ivy_version 1
  addUserKnob {43 ivy_notes l Notes}
  ivy_notes "cg robot"
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
set N182349f0 [stack 0]
 Merge2 {
  inputs 31+1
  operation plus
  bbox B
  also_merge all
  name Merge1
  xpos -40
  ypos 2902
 }
 Output {
  name Output1
  xpos -40
  ypos 3017
 }
push $N182349f0
 Viewer {
  frame_range 1-1000
  overscan 300
  center_fstop 0
  viewerProcess Film
  far 100000
  name Viewer1
  xpos 55
  ypos 131
 }
end_group
Reformat {
 format "2224 1548 0 0 2224 1548 1 Alexa LF 4.5k OpenGate Working"
 resize height
 pbb true
 name Reformat2
 xpos -2194
 ypos -2079
}
Dot {
 name Dot21
 xpos -2166
 ypos -1901
}
set N182a2b50 [stack 0]
Dot {
 name Dot26
 xpos -2057
 ypos -1901
}
set N182a7700 [stack 0]
Dot {
 name Dot46
 label "you can add \nsoftness here"
 note_font_size 31
 xpos -1893
 ypos -1901
}
OCIOColorSpace {
 in_colorspace linear
 out_colorspace log
 name OCIOColorSpace3
 xpos -1921
 ypos -1837
 disable true
}
Blur {
 size 300
 name Blur2
 xpos -1921
 ypos -1813
 disable true
}
FilterErode {
 size -100
 filter gaussian
 name FilterErode2
 xpos -1922
 ypos -1777
 disable true
}
Crop {
 box {0 0 2224 1548}
 name Crop3
 xpos -1922
 ypos -1735
}
Constant {
 inputs 0
 format "2224 1548 0 0 2224 1548 1 Alexa LF 4.5k OpenGate Working"
 name Constant10
 xpos -1567
 ypos -2542
}
CropPadded {
 name CropPadded1
 xpos -1567
 ypos -2460
 box {0 0 2224 1548}
 padding 100
 intersect false
}
set N182f02b0 [stack 0]
Grid {
 number {0 {"height / (width / Grid4.number.0 / 0.576441) "}}
 size {{parent.Grid4.size}}
 name Grid7
 xpos -1445
 ypos -2373
}
Grade {
 channels alpha
 white 1000000
 white_clamp true
 name Grade6
 xpos -1445
 ypos -2169
}
push $N182f02b0
Grid {
 number {0 {"height / (width / Grid4.number.0 / (23/39.9) / 2 ) "}}
 size {{parent.Grid4.size}}
 name Grid6
 xpos -1567
 ypos -2374
}
push $N182f02b0
Grid {
 number {30 0}
 size 1.01
 name Grid4
 label "NUMBER knob controls all"
 note_font_size 21
 xpos -1749
 ypos -2386
}
ChannelMerge {
 inputs 2
 operation multiply
 name ChannelMerge5
 xpos -1567
 ypos -2298
}
Shuffle {
 in alpha
 name Shuffle6
 xpos -1567
 ypos -2250
}
TransformMasked {
 inputs 1+1
 translate {{"width / Grid4.number.0 / 2"} 0}
 center {1112 774}
 filter Impulse
 shutteroffset centred
 name Transform4
 xpos -1567
 ypos -2169
}
Grade {
 channels rgba
 white 400000
 name Grade4
 xpos -1567
 ypos -2120
}
Crop {
 box {0 0 2224 1548}
 name Crop6
 xpos -1567
 ypos -2096
}
OCIOColorSpace {
 in_colorspace linear
 out_colorspace log
 name OCIOColorSpace1
 xpos -1567
 ypos -1776
 disable true
}
Multiply {
 inputs 1+1
 value 0
 invert_mask true
 name Multiply1
 xpos -1567
 ypos -1741
}
OCIOColorSpace {
 in_colorspace log
 out_colorspace linear
 name OCIOColorSpace2
 xpos -1567
 ypos -1696
 disable true
}
Dot {
 name Dot20
 xpos -1539
 ypos -1626
}
set N183c6bd0 [stack 0]
Dot {
 name Dot24
 xpos -875
 ypos -1626
}
FrameHold {
 first_frame 1200
 name FrameHold1
 xpos -903
 ypos -1340
 addUserKnob {20 dneg l DNeg}
 addUserKnob {26 _version l "" +STARTLINE +INVISIBLE T 1.1}
 addUserKnob {22 documentation l Documentation -STARTLINE T nukescripts.start('http://dnet/x/PwBDBg')}
 addUserKnob {26 ""}
 addUserKnob {3 first_frame_dup l "first frame" t "The first frame to use. If increment is set to 0, first frame is used at every frame of the input clip.\n\n<b>NOTE:</b> This is a duplicate of the knob on the first tab, here for convenience. Any change here will set the knob on the first tab."}
 first_frame_dup 1200
 addUserKnob {3 increment_dup l increment t "The increment to use when rendering every certain number of frames from the input clip. For example, if this is set to 5 and first frame is set to 1, Nuke only uses frames 1, 6, 11, 16, and so on from the input.\n\n<b>NOTE:</b> This is a duplicate of the knob on the first tab, here for convenience. Any change here will set the knob on the first tab."}
 addUserKnob {26 ""}
 addUserKnob {22 comp_first l "comp first" t "Set the hold frame to the comp first frame, a.k.a. in Nuke parlance, root.first_frame, or in Shotgun parlance, 'sg_head_in'" -STARTLINE T "__import__(\"dnnuke.init.callbacks.on_user_create.tabs.framehold\", fromlist=\[\"compFirstButton\"]).compFirstButton()"}
 addUserKnob {22 cut_in l "cut in" t "Set the hold frame to the cut in frame, which is the comp first frame plus head handles, or in Shotgun parlance, 'sg_cut_in'" -STARTLINE T "__import__(\"dnnuke.init.callbacks.on_user_create.tabs.framehold\", fromlist=\[\"cutInButton\"]).cutInButton()"}
 addUserKnob {22 cut_out l "cut out" t "Set the hold frame to the cut out frame, which is the comp last frame minus tail handles, or in Shotgun parlance, 'sg_cut_out'" -STARTLINE T "__import__(\"dnnuke.init.callbacks.on_user_create.tabs.framehold\", fromlist=\[\"cutOutButton\"]).cutOutButton()"}
 addUserKnob {22 comp_last l "comp last" t "Set the hold frame to the comp last frame, a.k.a. in Nuke parlance, root.last_frame, or in Shotgun parlance, 'sg_tail_out'" -STARTLINE T "__import__(\"dnnuke.init.callbacks.on_user_create.tabs.framehold\", fromlist=\[\"compLastButton\"]).compLastButton()"}
 addUserKnob {26 "" -STARTLINE T " "}
 addUserKnob {22 hero_frame l "hero frame" t "Set the hold frame to the hero frame from Shotgun, a.k.a. 'sg_hero_frame'. Beware that this may not always be set by the sequence supervisor. If not, go bug him or her!" T "__import__(\"dnnuke.init.callbacks.on_user_create.tabs.framehold\", fromlist=\[\"getHeroFrameButton\"]).getHeroFrameButton()" +STARTLINE}
 addUserKnob {22 middle_frame l "middle frame" t "Set the hold frame to the frame between the cut in and cut out." -STARTLINE T "__import__(\"dnnuke.init.callbacks.on_user_create.tabs.framehold\", fromlist=\[\"middleFrameButton\"]).middleFrameButton()"}
 addUserKnob {22 current_frame l "current frame" t "Set the hold frame to the current frame as in the active viewer's timeline, a.k.a. nuke.frame()." -STARTLINE T "__import__(\"dnnuke.init.callbacks.on_user_create.tabs.framehold\", fromlist=\[\"currentFrameButton\"]).currentFrameButton()"}
 addUserKnob {26 ""}
 addUserKnob {4 get_show_shot_from l "get show/shot from" t "Which should be used to retrieve info from the database? Default is <b>environment</b>, which uses \$SHOW and \$SHOT. If you want to use this node's input, use <b>metadata</b>, which will grab the input/filename value. Or, you can type it in manually with <b>specify</b>.," M {environment metadata specify}}
 addUserKnob {6 always_refresh l "always refresh" t "If unchecked, use locally-cached frame range information if available. If checked, always refresh from the database no matter what. Certain actions will cause locally-cached frame range info to become stale and override this preference, such as changing the <i>get show/shot from</i> value." -STARTLINE}
 addUserKnob {1 hidden_foce_startline +HIDDEN}
 addUserKnob {26 show -STARTLINE +HIDDEN T " "}
 addUserKnob {26 shot -STARTLINE +HIDDEN T " "}
 addUserKnob {1 show_specify l show +HIDDEN}
 show_specify " "
 addUserKnob {1 shot_specify l shot +HIDDEN}
 shot_specify " "
 addUserKnob {26 cut_range l "cut range" +HIDDEN T " "}
 addUserKnob {26 comp_range l "comp range" +HIDDEN T " "}
 addUserKnob {26 hero_frame_value l "hero frame" +HIDDEN T " "}
 addUserKnob {6 hidden_is_stale l "" -STARTLINE +HIDDEN}
 addUserKnob {1 cut_in_specify +HIDDEN}
 addUserKnob {1 cut_out_specify +HIDDEN}
 addUserKnob {1 comp_first_specify +HIDDEN}
 addUserKnob {1 comp_last_specify +HIDDEN}
 addUserKnob {1 hero_frame_specify +HIDDEN}
}
Dot {
 name Dot29
 xpos -875
 ypos -1118
}
set N183de430 [stack 0]
ZDefocus2 {
 math depth
 size {{"Grid6.height / Grid6.number.1 * 1.333333333333 / 2.5"}}
 max_size {{size}}
 layers 10
 layerCurve 10
 filter_type bladed
 legacy_resize_mode false
 show_legacy_resize_mode false
 blades 2
 roundness -0.6
 rotation -30
 inner_size 1
 inner_brightness 1
 name ZDefocus4
 xpos -799
 ypos -954
 addUserKnob {20 camera_tab l "Camera (DNeg)"}
 addUserKnob {22 create_camera_knobs l "create camera knobs and expressions" -STARTLINE T "__import__('dnnuke.menu.toolbar.filter.zdefocus', fromlist=\['createZDefocusCameraKnobs']).createZDefocusCameraKnobs(nuke.thisNode())"}
 addUserKnob {43 camera_knobs_info l "" +STARTLINE}
 camera_knobs_info "For a more intuitive way of controlling the depth of field, you can have camera knobs here (such as focal length, fstop etc.) along with expressions to drive ZDefocus.\n\nThe ZDefocus knobs that will be affected are:\n   depth channel\n   math\n   size\n   maximum\n   filter shape\n   aspect ratio\n\nIf you want to drive the camera knobs as well as the focal point from an existing camera you can use the Tools->Create Node from Selected Node->ZDefocus from ZenCamera, after selecting the ZenCamera node.\n\nThe same applies for BokehZDefocus."
}
push $N183de430
ZDefocus2 {
 math depth
 size {{"Grid6.height / Grid6.number.1 * 1.333333333333 / 2.5"}}
 max_size {{size}}
 layers 10
 layerCurve 10
 filter_type bladed
 legacy_resize_mode false
 show_legacy_resize_mode false
 blades 3
 roundness -0.6
 rotation -30
 inner_size 1
 inner_brightness 1
 name ZDefocus5
 xpos -676
 ypos -958
 addUserKnob {20 camera_tab l "Camera (DNeg)"}
 addUserKnob {22 create_camera_knobs l "create camera knobs and expressions" -STARTLINE T "__import__('dnnuke.menu.toolbar.filter.zdefocus', fromlist=\['createZDefocusCameraKnobs']).createZDefocusCameraKnobs(nuke.thisNode())"}
 addUserKnob {43 camera_knobs_info l "" +STARTLINE}
 camera_knobs_info "For a more intuitive way of controlling the depth of field, you can have camera knobs here (such as focal length, fstop etc.) along with expressions to drive ZDefocus.\n\nThe ZDefocus knobs that will be affected are:\n   depth channel\n   math\n   size\n   maximum\n   filter shape\n   aspect ratio\n\nIf you want to drive the camera knobs as well as the focal point from an existing camera you can use the Tools->Create Node from Selected Node->ZDefocus from ZenCamera, after selecting the ZenCamera node.\n\nThe same applies for BokehZDefocus."
}
push $N183de430
ZDefocus2 {
 math depth
 size {{"Grid6.height / Grid6.number.1 * 1.333333333333 / 2.5"}}
 max_size {{size}}
 layers 10
 layerCurve 10
 filter_type bladed
 legacy_resize_mode false
 show_legacy_resize_mode false
 roundness -2.3
 rotation -50
 inner_size -1
 inner_feather 0
 inner_brightness 1
 name ZDefocus6
 xpos -569
 ypos -953
 addUserKnob {20 camera_tab l "Camera (DNeg)"}
 addUserKnob {22 create_camera_knobs l "create camera knobs and expressions" -STARTLINE T "__import__('dnnuke.menu.toolbar.filter.zdefocus', fromlist=\['createZDefocusCameraKnobs']).createZDefocusCameraKnobs(nuke.thisNode())"}
 addUserKnob {43 camera_knobs_info l "" +STARTLINE}
 camera_knobs_info "For a more intuitive way of controlling the depth of field, you can have camera knobs here (such as focal length, fstop etc.) along with expressions to drive ZDefocus.\n\nThe ZDefocus knobs that will be affected are:\n   depth channel\n   math\n   size\n   maximum\n   filter shape\n   aspect ratio\n\nIf you want to drive the camera knobs as well as the focal point from an existing camera you can use the Tools->Create Node from Selected Node->ZDefocus from ZenCamera, after selecting the ZenCamera node.\n\nThe same applies for BokehZDefocus."
}
push $N183de430
ZDefocus2 {
 math depth
 size {{"Grid6.height / Grid6.number.1 * 1.333333333333 / 2.5"}}
 max_size {{size}}
 layers 10
 layerCurve 10
 filter_type bladed
 legacy_resize_mode false
 show_legacy_resize_mode false
 blades 9
 roundness -10.3
 rotation -20
 inner_size -1
 inner_feather 0.2
 inner_brightness 2
 name ZDefocus7
 xpos -439
 ypos -948
 addUserKnob {20 camera_tab l "Camera (DNeg)"}
 addUserKnob {22 create_camera_knobs l "create camera knobs and expressions" -STARTLINE T "__import__('dnnuke.menu.toolbar.filter.zdefocus', fromlist=\['createZDefocusCameraKnobs']).createZDefocusCameraKnobs(nuke.thisNode())"}
 addUserKnob {43 camera_knobs_info l "" +STARTLINE}
 camera_knobs_info "For a more intuitive way of controlling the depth of field, you can have camera knobs here (such as focal length, fstop etc.) along with expressions to drive ZDefocus.\n\nThe ZDefocus knobs that will be affected are:\n   depth channel\n   math\n   size\n   maximum\n   filter shape\n   aspect ratio\n\nIf you want to drive the camera knobs as well as the focal point from an existing camera you can use the Tools->Create Node from Selected Node->ZDefocus from ZenCamera, after selecting the ZenCamera node.\n\nThe same applies for BokehZDefocus."
}
push $N183de430
ZDefocus2 {
 math depth
 size {{"Grid6.height / Grid6.number.1 * 1.333333333333 / 2.5"}}
 max_size {{size}}
 layers 10
 layerCurve 10
 filter_type bladed
 legacy_resize_mode false
 show_legacy_resize_mode false
 blades 2
 roundness -12
 inner_size 6
 inner_feather 0.1
 inner_brightness 0
 name ZDefocus9
 xpos -175
 ypos -952
 addUserKnob {20 camera_tab l "Camera (DNeg)"}
 addUserKnob {22 create_camera_knobs l "create camera knobs and expressions" -STARTLINE T "__import__('dnnuke.menu.toolbar.filter.zdefocus', fromlist=\['createZDefocusCameraKnobs']).createZDefocusCameraKnobs(nuke.thisNode())"}
 addUserKnob {43 camera_knobs_info l "" +STARTLINE}
 camera_knobs_info "For a more intuitive way of controlling the depth of field, you can have camera knobs here (such as focal length, fstop etc.) along with expressions to drive ZDefocus.\n\nThe ZDefocus knobs that will be affected are:\n   depth channel\n   math\n   size\n   maximum\n   filter shape\n   aspect ratio\n\nIf you want to drive the camera knobs as well as the focal point from an existing camera you can use the Tools->Create Node from Selected Node->ZDefocus from ZenCamera, after selecting the ZenCamera node.\n\nThe same applies for BokehZDefocus."
}
push $N183de430
ZDefocus2 {
 math depth
 size {{"Grid6.height / Grid6.number.1 * 1.333333333333 / 2.5"}}
 max_size {{size}}
 layers 10
 layerCurve 10
 filter_type bladed
 legacy_resize_mode false
 show_legacy_resize_mode false
 blades 13
 roundness -100
 rotation 60
 inner_size 6
 inner_feather 0
 inner_brightness 0
 name ZDefocus8
 xpos -303
 ypos -948
 addUserKnob {20 camera_tab l "Camera (DNeg)"}
 addUserKnob {22 create_camera_knobs l "create camera knobs and expressions" -STARTLINE T "__import__('dnnuke.menu.toolbar.filter.zdefocus', fromlist=\['createZDefocusCameraKnobs']).createZDefocusCameraKnobs(nuke.thisNode())"}
 addUserKnob {43 camera_knobs_info l "" +STARTLINE}
 camera_knobs_info "For a more intuitive way of controlling the depth of field, you can have camera knobs here (such as focal length, fstop etc.) along with expressions to drive ZDefocus.\n\nThe ZDefocus knobs that will be affected are:\n   depth channel\n   math\n   size\n   maximum\n   filter shape\n   aspect ratio\n\nIf you want to drive the camera knobs as well as the focal point from an existing camera you can use the Tools->Create Node from Selected Node->ZDefocus from ZenCamera, after selecting the ZenCamera node.\n\nThe same applies for BokehZDefocus."
}
ZDefocus2 {
 inputs 0
 math direct
 output "filter shape setup"
 size 14.69773913
 max_size {{size}}
 layers 10
 layerCurve 10
 filter_type bladed
 legacy_resize_mode false
 show_legacy_resize_mode false
 blades 6
 roundness 0
 rotation 30
 inner_size 1
 inner_feather 0
 inner_brightness 1
 name ZDefocus1
 xpos -1990
 ypos -913
 addUserKnob {20 camera_tab l "Camera (DNeg)"}
 addUserKnob {22 create_camera_knobs l "create camera knobs and expressions" -STARTLINE T "__import__('dnnuke.menu.toolbar.filter.zdefocus', fromlist=\['createZDefocusCameraKnobs']).createZDefocusCameraKnobs(nuke.thisNode())"}
 addUserKnob {43 camera_knobs_info l "" +STARTLINE}
 camera_knobs_info "For a more intuitive way of controlling the depth of field, you can have camera knobs here (such as focal length, fstop etc.) along with expressions to drive ZDefocus.\n\nThe ZDefocus knobs that will be affected are:\n   depth channel\n   math\n   size\n   maximum\n   filter shape\n   aspect ratio\n\nIf you want to drive the camera knobs as well as the focal point from an existing camera you can use the Tools->Create Node from Selected Node->ZDefocus from ZenCamera, after selecting the ZenCamera node.\n\nThe same applies for BokehZDefocus."
}
Transform {
 scale 0.98
 center {127.5 127.5}
 shutteroffset centred
 name Transform2
 xpos -1990
 ypos -877
}
Constant {
 inputs 0
 channels rgb
 format "256 256 0 0 256 256 1 square_256"
 name Constant2
 xpos -1875
 ypos -1099
}
Flare {
 position {{(width+1)/2} {(height+1)/2}}
 radius {80 100 {width/2}}
 inner_color 1
 vis_out 1
 corners 6
 flattening 1
 sharpness 1
 corners_angle 30
 name Flare2
 xpos -1875
 ypos -1015
}
Grade {
 white 20
 white_clamp true
 name Grade3
 xpos -1875
 ypos -981
}
Shuffle {
 alpha red
 name Shuffle5
 xpos -1875
 ypos -957
}
Switch {
 inputs 2
 which 1
 name Switch3
 xpos -1875
 ypos -877
}
Reformat {
 type "to box"
 box_width {{"Grid6.height / Grid6.number.1 * 1.333333333333 - 5"}}
 scale 0.5
 name Reformat3
 xpos -1875
 ypos -844
}
push $N182a7700
Dot {
 name Dot25
 xpos -2057
 ypos -1527
}
Dot {
 name Dot47
 label "optional bekeh size \ncontroling channel"
 note_font_size 31
 xpos -1899
 ypos -1527
}
OCIOColorSpace {
 in_colorspace linear
 out_colorspace log
 name OCIOColorSpace4
 xpos -1927
 ypos -1459
}
Blur {
 size 620
 name Blur3
 xpos -1927
 ypos -1435
}
FilterErode {
 size 200
 filter gaussian
 name FilterErode3
 xpos -1928
 ypos -1400
}
Crop {
 box {0 0 2224 1548}
 name Crop7
 xpos -1928
 ypos -1364
}
OCIOColorSpace {
 in_colorspace log
 out_colorspace linear
 name OCIOColorSpace5
 xpos -1928
 ypos -1340
}
Grade {
 channels alpha
 white 1.1
 gamma 0.6
 white_clamp true
 name Grade7
 xpos -1928
 ypos -1316
}
push $N183c6bd0
Copy {
 inputs 2
 from0 rgba.alpha
 to0 depth.Z
 name Copy1
 xpos -1567
 ypos -1316
}
Dot {
 name Dot22
 xpos -1539
 ypos -959
}
set N1b1d40a0 [stack 0]
Convolve2 {
 inputs 2
 use_input_channels true
 name Convolve1
 xpos -1747
 ypos -850
}
Clamp {
 minimum 0.01
 MinClampTo_enable true
 name Clamp4
 xpos -1747
 ypos -814
}
Dot {
 name Dot28
 xpos -1719
 ypos -418
}
set N1b1f8ec0 [stack 0]
Shuffle {
 alpha red
 name Shuffle8
 xpos -1862
 ypos -421
}
push $N182a2b50
Dot {
 name Dot23
 xpos -2166
 ypos -350
}
set N1b20e000 [stack 0]
Glass {
 inputs 2
 name Glass1
 xpos -1862
 ypos -347
 channels rgb
 from0 rgba.red
 displace 0.1
 size_1 9
}
push $N1b1d40a0
ZDefocus2 {
 math direct
 size {{"Grid6.height / Grid6.number.1 * 1.333333333333 / 2.5"}}
 max_size {{size}}
 layers 10
 layerCurve 10
 filter_type bladed
 legacy_resize_mode false
 show_legacy_resize_mode false
 blades 6
 roundness 0
 rotation 30
 inner_size 1
 inner_brightness 1
 name ZDefocus3
 label "set MATH = DIRECT to let DEPTH \nchannel to contrlo bokeh size\n\nfor equal size set MATH = DEPTH"
 xpos -1375
 ypos -863
 addUserKnob {20 camera_tab l "Camera (DNeg)"}
 addUserKnob {22 create_camera_knobs l "create camera knobs and expressions" -STARTLINE T "__import__('dnnuke.menu.toolbar.filter.zdefocus', fromlist=\['createZDefocusCameraKnobs']).createZDefocusCameraKnobs(nuke.thisNode())"}
 addUserKnob {43 camera_knobs_info l "" +STARTLINE}
 camera_knobs_info "For a more intuitive way of controlling the depth of field, you can have camera knobs here (such as focal length, fstop etc.) along with expressions to drive ZDefocus.\n\nThe ZDefocus knobs that will be affected are:\n   depth channel\n   math\n   size\n   maximum\n   filter shape\n   aspect ratio\n\nIf you want to drive the camera knobs as well as the focal point from an existing camera you can use the Tools->Create Node from Selected Node->ZDefocus from ZenCamera, after selecting the ZenCamera node.\n\nThe same applies for BokehZDefocus."
}
Clamp {
 minimum 0.01
 MinClampTo_enable true
 name Clamp2
 xpos -1375
 ypos -775
}
Dot {
 name Dot27
 xpos -1347
 ypos -600
}
set N1b3df0f0 [stack 0]
FilterErode {
 channels rgba
 size 3
 filter quadratic
 name FilterErode4
 xpos -1249
 ypos -597
}
EdgeDetectWrapper {
 name EdgeDetect1
 xpos -1249
 ypos -573
}
Shuffle {
 in alpha
 name Shuffle7
 xpos -1249
 ypos -391
}
push $N1b3df0f0
Merge2 {
 inputs 2
 operation difference
 name Merge4
 xpos -1375
 ypos -385
}
Grade {
 white {3 0.05999994278 0.102152288 1}
 multiply 0.5
 gamma 1.5
 name Grade5
 xpos -1375
 ypos -346
}
push $N1b1f8ec0
Switch {
 inputs 2
 which 1
 name Switch2
 xpos -1561
 ypos -266
}
push $N1b20e000
Merge2 {
 inputs 2
 operation plus
 name Merge2
 xpos -2194
 ypos -266
}
push $N183de430
ZDefocus2 {
 math depth
 size {{"Grid6.height / Grid6.number.1 * 1.333333333333 / 2.5"}}
 max_size {{size}}
 layers 10
 layerCurve 10
 filter_type bladed
 legacy_resize_mode false
 show_legacy_resize_mode false
 blades 2
 roundness 0
 rotation -50
 inner_size 1
 inner_brightness 1
 name ZDefocus2
 xpos -903
 ypos -959
 addUserKnob {20 camera_tab l "Camera (DNeg)"}
 addUserKnob {22 create_camera_knobs l "create camera knobs and expressions" -STARTLINE T "__import__('dnnuke.menu.toolbar.filter.zdefocus', fromlist=\['createZDefocusCameraKnobs']).createZDefocusCameraKnobs(nuke.thisNode())"}
 addUserKnob {43 camera_knobs_info l "" +STARTLINE}
 camera_knobs_info "For a more intuitive way of controlling the depth of field, you can have camera knobs here (such as focal length, fstop etc.) along with expressions to drive ZDefocus.\n\nThe ZDefocus knobs that will be affected are:\n   depth channel\n   math\n   size\n   maximum\n   filter shape\n   aspect ratio\n\nIf you want to drive the camera knobs as well as the focal point from an existing camera you can use the Tools->Create Node from Selected Node->ZDefocus from ZenCamera, after selecting the ZenCamera node.\n\nThe same applies for BokehZDefocus."
}
Constant {
 inputs 0
 channels rgb
 format "1920 1080 0 0 1920 1080 1 Canon 5D mkIII HD"
 name Constant3
 xpos 834
 ypos -1836
}
Dot {
 name Dot33
 xpos 862
 ypos -1737
}
set N1b46a300 [stack 0]
Noise {
 opacity 0.5
 type turbulence
 size 2200
 zoffset {{frame/200}}
 octaves 2
 nyquist false
 lacunarity 10
 gain 2
 gamma 0.1
 center {1112 774}
 color {7231.5 20000 2.498627 1}
 name Noise11
 xpos 834
 ypos -1643
}
Blur {
 size 50
 filter box
 quality 10
 name Blur9
 xpos 834
 ypos -1609
}
FilterErode {
 channels all
 size 19
 filter gaussian
 name FilterErode14
 xpos 834
 ypos -1559
}
Grade {
 channels all
 white 6
 add -0.05
 gamma 1.4
 black_clamp false
 name Grade30
 xpos 834
 ypos -1510
}
TimeEcho {
 framesbehind 5
 name TimeEcho1
 xpos 834
 ypos -1474
}
Matrix {
 matrix {
     {-36.23 {matrix.0} {matrix.0} {matrix.0} {matrix.0}}
     {{matrix.0} {"-matrix.0 * mult"} {matrix.6} {matrix.6} {matrix.0}}
     {{matrix.0} {matrix.6} -290.2 {matrix.6} {matrix.0}}
     {{matrix.0} {matrix.6} {matrix.6} {matrix.6} {matrix.0}}
     {{matrix.0} {matrix.0} {matrix.0} {matrix.0} {matrix.0}}
   }
 name Matrix1
 xpos 834
 ypos -1419
 addUserKnob {20 User}
 addUserKnob {7 mult}
 mult 3
}
Grade {
 channels all
 black -0.1
 name Grade29
 xpos 834
 ypos -1383
}
ColorCorrect {
 midtones.saturation 0.9
 highlights.saturation 0.8
 highlights.contrast 1.1
 name ColorCorrect1
 xpos 834
 ypos -1347
}
Dot {
 name Dot35
 xpos 862
 ypos -1297
}
set N1b4efc10 [stack 0]
FilterErode {
 size -4
 filter gaussian
 name FilterErode13
 xpos 1005
 ypos -1300
}
Glint {
 repeat 3
 length {{sin(frame/10)*30}}
 name Glint1
 xpos 1005
 ypos -1264
}
push $N1b46a300
Dot {
 name Dot34
 xpos 1170
 ypos -1737
}
UVRamp {
 name UVRamp1
 xpos 1142
 ypos -1208
 overscan {0 {"overscan.u * this.Input1.width/this.Input1.height * this.Input1.pixel_aspect"}}
 output rgb
}
Merge2 {
 inputs 2
 operation mask
 name Merge5
 xpos 1005
 ypos -1208
}
push $N1b4efc10
STMap {
 inputs 2
 uv rgba
 name STMap2
 xpos 834
 ypos -1214
}
FrameRange {
 first_frame 1
 last_frame 200
 time ""
 name FrameRange2
 xpos 834
 ypos -1178
}
RotoPaint {
 inputs 0
 cliptype none
 curves {{{v x3f99999a}
  {f 0}
  {n
   {layer Root
    {f 2097152}
    {t x44800000 x44428000}
    {a pt1x 0 pt1y 0 pt2x 0 pt2y 0 pt3x 0 pt3y 0 pt4x 0 pt4y 0 ptex00 0 ptex01 0 ptex02 0 ptex03 0 ptex10 0 ptex11 0 ptex12 0 ptex13 0 ptex20 0 ptex21 0 ptex22 0 ptex23 0 ptex30 0 ptex31 0 ptex32 0 ptex33 0 ptof1x 0 ptof1y 0 ptof2x 0 ptof2y 0 ptof3x 0 ptof3y 0 ptof4x 0 ptof4y 0 pterr 0 ptrefset 0 ptmot x40800000 ptref 0}
    {curvegroup OpenSpline3 1049088 bezier
     {{cc
       {f 1056800}
       {px
        {1 x42980000}
        {{xc2438e36}
      {x4260e390}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {x442e8000}
      {x44c64000}}
        {{x42438e39}
      {xc260e38e}}
        {{xc2929c76}
      {x41551407}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x44658000 -}
       {x443b8000 -}}
      {{x44a6a000 -}
       {x44ab3999 -}}}
        {{x42929c76}
      {xc15513fd}}
        {{xc26b8730}
      {x413af119}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x44a3a000 -}
       {x44a96cce -}}
      {{x44b86000 -}}}
        {{x426b8730}
      {xc13af115}}
        {{xc26ff881}
      {xc007832f}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {x44b26000 x44aa9334}
      {x449a0000 x449c0000}}
        {{x426ff881}
      {x4007834c}}
        {{xc1ef91e8}
      {xc162ba51}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x44e36000 -}
       {x44e82ccd -}}
      {{x44baa000 -}
       {x44b9a000 -}}}
        {{x41ef91e7}
      {x4162ba5a}}
        {{x4084257b}
      {x42037c48}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x44f60000 -}
       {x44fcffff -}}
      {{x44ba0000 -}
       {x44b6cccd -}}}
        {{xc0842570}
      {xc2037c48}}
        {{{x419559ab -}
       {x4224ccc0 -}}
      {{x41f443ab -}
       {x41c4cc80 -}}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x44e04000 0 1 x3ec49bbc 1}
       {x44e3d99a x3ec49bbc 1 0 1}}
      {{x44a1c000 0 1 xbeaec2fd 1}
       {x449e8cce xbeaec2fd 1 0 1}}}
        {{{xc19559a9 -}
       {xc1f5d200 -}}
      {{xc1f443ad -}
       {xc192c680 -}}}
        {{{x3ed50d5a -}
       {x40da9700 -}}
      {{x420f2491 -}
       {x420c8520 -}}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x44db4000 0 1 xbf4a11b5 1}
       {x44d5d999 xbf4a11b5 1 0 1}}
      {{x448e4000 0 1 xbe704ccd 1}
       {x448b3ffe xbe704ccd 1 0 1}}}
        {{{xbed50ca5 -}
       {xc11ccd00 -}}
      {{xc20f2491 -}
       {xc2499980 -}}}
        {{xc12dce22}
      {x41d35d68}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x44dfc000 -}
       {x44d75998 -}}
      {{x446d8000 -}
       {x44664ccc -}}}
        {{x412dce26}
      {xc1d35d67}}
        {{{xc1b905be -}
       {xc2aaccc0 -}}
      {{xc1862426 -}
       {xc2b0ccd0 -}}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x44ea0000 0 1 xbcaec5f9 1}
       {x44e9cccc xbcaec5f9 1 0 1}}
      {{x4454c000 0 1 xbcaec28f 1}
       {x4454599a xbcaec28f 1 0 1}}}
        {{{x41b905bc -}
       {x419ec8c0 -}}
      {{x41862429 -}
       {x41a45cc0 -}}}
        {{xc1a28640}
      {xc1dd46f6}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x44f3c000 -}
       {x44f2f333 -}}
      {{x44854000 -}
       {x44844000 -}}}
        {{x41a2863a}
      {x41dd46fa}}
        {{xc1acc1e6}
      {xc123f91c}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x45025000 -}
       {x45015001 -}}
      {{x448ea000 -}
       {x4494d333 -}}}
        {{x41acc1e5}
      {x4123f91e}}
        {{xc1b4bf75}
      {xc0f9b52b}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {x4508a000}
      {x44934000}}
        {{x41b4bf74}
      {x40f9b539}}
        {{xc2038e39}
      {xc12e38df}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {x4511e000}
      {x44996000}}
        {{x42038e39}
      {x412e38e5}}}}     idem}
     {tx 1 x44d56db7 x449bd249}
     {a osbe 0 osee 0 osw x40000000 osf 0 str 1 tt x41200000}}
    {curvegroup OpenSpline2 1049088 bezier
     {{cc
       {f 1056800}
       {px
        {1 x42980000}
        {{0}
      {0}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x447ec000 -}
       {x44805fff -}}
      {{xc1c00000 -}
       {xc2600000 -}}}
        {{x4262aaab}
      {x4203ffff}}
        {{x40f2f461}
      {xc28244b9}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x4494a000 -}
       {x448dd332 -}}
      {{x42960000 -}
       {x42893330 -}}}
        {{xc0f2f465}
      {x428244b9}}
        {{x428671b0}
      {xc21b3d30}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x44740cce -}
       {x44700ccf -}}
      {{x43b56665 -}
       {x43cd6665 -}}}
        {{xc2aa6670}
      {x4244ccd8}}
        {{x429c4e60}
      {x40ae9f80}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x441e0cce -}
       {x44147336 -}}
      {{x43e8cccb -}
       {x43fd9999 -}}}
        {{xc2a06670}
      {xc0b332c0}}
        {{x41ec1ef8}
      {x41aa28f9}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x43d00000 -}
       {x43b80000 -}}
      {{x43c40000 -}
       {x43c0cccc -}}}
        {{xc1ec1ef7}
      {xc1aa28fb}}
        {{xc145b438}
      {x4208df3f}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x43c30000 -}
       {x43b30002 -}}
      {{x438f0000 -}
       {x43823334 -}}}
        {{x4145b43e}
      {xc208df3f}}
        {{xc242bebe}
      {x41542f66}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {x43f70000 x43dfcccc}
      {x43300000 x43199998}}
        {{x4242bebf}
      {xc1542f59}}
        {{xc203a2bb}
      {xc1e73ba0}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x44248000 -}
       {x442a8000 -}}
      {{x43550000 -}
       {x43236664 -}}}
        {{x4203a2b9}
      {x41e73ba5}}
        {{x41b75f47}
      {xc2154b54}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {x4428c000}
      {x43a3cccc}}
        {{xc1b75f4a}
      {x42154b53}}
        {{x42b265d7}
      {xc26e14ce}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x43d80000 -}
       {x43e9999a -}}
      {{x44114000 -}
       {x4417a666 -}}}
        {{xc2b265d8}
      {x426e14ca}}
        {{x429d52a7}
      {xc20b834f}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x4314ccd0 -}
       {x43333338 -}}
      {{x44338ccd -}
       {x443cc000 -}}}
        {{xc29d52a9}
      {x420b8347}}
        {{x41f7b777}
      {xc16b8f1e}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {xc2c40000}
      {x444c0002}}
        {{xc1f7b77b}
      {x416b8f11}}
        {{x41f55556}
      {xc1755558}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {xc33e0000}
      {x44578002}}
        {{0}
      {0}}}}     idem}
     {tx 1 x4401c000 x43c7b13b}
     {a osbe 0 osee 0 osw x40000000 osf 0 str 1 tt x41200000}}
    {curvegroup OpenSpline1 1049088 bezier
     {{cc
       {f 1056800}
       {px
        {1 x41d00000 x424c0000 x42980000}
        {{{0 -}}
	 {{0 -}}}
        {{a osw
	  {{1 1 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}	 osf
	  {{1 0 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}}
	 {{x4504dfff 0 1 xbf072b85 1}
	  {x4503accb xbf9fbeb8 1 xbf9fbeb8 1}
	  {x4500f997 -}
	  {x45012cca x3e449ae1 1 0 1}}
	 {{x43df0000 0 1 x3fb020c3 1}
	  {x43f0999a x3fbc6a8f 1 x3fbc6a8f 1}
	  {x4401e668 x3f872b14 1 x3f872b14 1}
	  {x44058002 x3eac083e 1 0 1}}}
        {{{x 2
	   {xc3bcaaa6 -}}
	  {xc38a3320 x4065cda9 1 x4065cda9 1}
	  {xc345cca0 x403aec36 1 0 1}}
	 {{x 2
	   {xc26ffffd -}}
	  {xc2c4ccd4 xbfe6667d 1 xbfe6667d 1}
	  {xc3160008 xc00c8b4f 1 0 1}}}
        {{{x 3
	   {x434fc5cc -}}
	  {x4345e650 xbf17a629 1 0 1}}
	 {{x 3
	   {xc13c9e11 -}}
	  {x417cccc0 x3fd3e15a 1 0 1}}}
        {{a osw
	  {{1 1 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}	 osf
	  {{1 0 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}}
	 {{x44c40fff 0 1 x3f449ccd 1}
	  {x44c5a99b -}
	  {x44c47669 xbe449ae1 1 xbe449ae1 1}
	  {x44c44336 xb10f5c29 1 0 1}}
	 {{x43cd3333 0 1 xc00b4395 1}
	  {x43b53333 xbfb4395c 1 xbfb4395c 1}
	  {x43a9ffff xbfac082e 1 xbfac082e 1}
	  {x4393999a xc001061b 1 0 1}}}
        {{{x 3
	   {xc34fc5cd -}}
	  {xc34f7268 x3ca01e14 1 0 1}}
	 {{x 3
	   {x413c9dbd -}}
	  {xc1847fd0 xbfd9bc2d 1 0 1}}}
        {{{x 3
	   {x41fcaa7c -}}
	  {x40800400 xbfd3d5e8 1 0 1}}
	 {{x 3
	   {xc34db23d -}}
	  {xc318999e x404be3aa 1 0 1}}}
        {{a osw
	  {{1 1 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}	 osf
	  {{1 0 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}}
	 {{x449fffff 0 1 x3f449b5c 1}
	  {x44a19998 -}
	  {x449f3330 xbf872b33 1 xbf872b33 1}
	  {x449afffc xbfbe76e1 1 0 1}}
	 {{x43f70000 0 1 x3fc49bb8 1}
	  {x4401e667 -}
	  {x43ffccce xbef5c27b 1 xbef5c27b 1}
	  {x43f7cccf xbf3851d2 1 0 1}}}
        {{{x 3
	   {xc1fcaa8c -}}
	  {xc0ae8600 x3fc8ac86 1 0 1}}
	 {{x 3
	   {x434db23d -}}
	  {x4350090e x3e0fb748 1 0 1}}}
        {{{x 3
	   {x41ba6680 -}}
	  {x4059b200 xbf98d229 1 0 1}}
	 {{x 3
	   {xc325999c -}}
	  {xc3273254 xbdc42f5c 1 0 1}}}
        {{a osw
	  {{1 1 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}	 osf
	  {{1 0 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}}
	 {{x44b75666 0 1 x3f5d2f33 1}
	  {x44b92333 -}
	  {x44b7bccc xbf872b0a 1 xbf872b0a 1}
	  {x44b28999 xbffbe75c 1 0 1}}
	 {{x44572667 0 1 x3e937429 1}
	  {x44585999 -}
	  {x444f2666 -}
	  {x4453f334 x3f9374e1 1 0 1}}}
        {{{x 3
	   {xc1b12900 -}}
	  {xc0533200 x3f90baf6 1 0 1}}
	 {{x 3
	   {x431d63fc -}}
	  {x43223330 x3e93be8f 1 0 1}}}
        {{{x 3
	   {x430e19a0 -}}
	  {x43098010 xbe8d4eb8 1 0 1}}
	 {{x 3
	   {xc1f99940 -}}
	  {xc2226660 xbf1062e1 1 0 1}}}
        {{a osw
	  {{1 1 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}	 osf
	  {{1 0 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}}
	 {{x449efccc 0 1 xbf1ba55c 1}
	  {x449cfccd xbf343971 1 xbf343971 1}
	  {x449a9665 -}
	  {x449c2ffe x3f449b5c 1 0 1}}
	 {{x44840665 0 1 xbfcac071 1}
	  {x447f3ffe xbf872af6 1 xbf872af6 1}
	  {x447ad998 -}
	  {x4480d333 x3fd0e585 1 0 1}}}
        {{{x 3
	   {xc31b3e30 -}}
	  {xc3186f40 x3e2c8b85 1 0 1}}
	 {{x 3
	   {x420857a0 -}}
	  {x42340a00 x3f27cbae 1 0 1}}}
        {{{x 3
	   {x43014ccc -}}
	  {x42e50000 xbf6353ec 1 0 1}}
	 {{x 3
	   {xc1633340 -}}
	  {xc1e599c0 xbf5eb88f 1 0 1}}}
        {{a osw
	  {{1 1 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}	 osf
	  {{1 0 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}}
	 {{x44476000 0 1 xbedd2e7b 1}
	  {x4444f99b xbe9374a4 1 xbe9374a4 1}
	  {x4443c667 xbee5607b 1 xbee5607b 1}
	  {x443f6000 xbf54fe0a 1 0 1}}
	 {{x4478c666 0 1 x400d4fcd 1}
	  {x4480fccc -}
	  {x447cc666 xbf5d2ee1 1 xbf5d2ee1 1}
	  {x44772cce xbf697890 1 0 1}}}
        {{{x 3
	   {xc2f3d2e8 -}}
	  {xc2edede0 x3e351571 1 0 1}}
	 {{x 3
	   {x41563800 -}}
	  {x41ee8dc0 x3f7c5f85 1 0 1}}}
        {{{x42a53338 -}}
	 {{x40bccc80 -}}}
        {{a osw
	  {{1 1 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}	 osf
	  {{1 0 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}}
	 {{x440ee665 0 1 xbe656029 1}
	  {x440db332 xbe03123d 1 xbe03123d 1}
	  {x440d4ccc -}
	  {x440f4ccb x3ef5c214 1 0 1}}
	 {{x445f8ccd 0 1 x408a3d78 1}
	  {x44718cce -}
	  {x446e599a xbf6d9171 1 xbf6d9171 1}
	  {x4465f334 xbfc6a7e1 1 0 1}}}
        {{{xc2f4aaa0 -}}
	 {{xc10bcec0 -}}}
        {{{x43243389 -}}
	 {{xc2bed864 -}}}
        {{a osw
	  {{1 1 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}	 osf
	  {{1 0 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}}
	 {{x 2
	   {x4395ccca -}}
	  {x43a2999a x3f1374a4 1 x3f1374a4 1}
	  {x43a50000 xb1a3d70a 1 0 1}}
	 {{x 2
	   {x447ed998 -}}
	  {x44813999 -}
	  {x447ba666 xbfd0e548 1 0 1}}}
        {{{xc324338a -}}
	 {{x42bed861 -}}}
        {{{x431c40ea -}}
	 {{xc2d7e46f -}}}
        {{a osw
	  {{1 1 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}	 osf
	  {{1 0 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}}
	 {{x42d0fff8 0 1 xbec49b5c 1}
	  {x42c43330 -}
	  {x430219a0 x3f978d66 1 x3f978d66 1}
	  {x431d4cd4 x3f851eb3 1 0 1}}
	 {{x449a8665 0 1 x4039580f 1}
	  {x44a28665 x3ff1aa00 1 x3ff1aa00 1}
	  {x44a65332 x3f7df385 1 x3f7df385 1}
	  {x44a8b997 x3f27ef0a 1 0 1}}}
        {{{xc31c40e9 -}}
	 {{x42d7e471 -}}}
        {{{x4347ffff -}}
	 {{xc2f80003 -}}}
        {{a osw
	  {{1 1 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}	 osf
	  {{1 0 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}}
	 {{x 3
	   {xc34c0000 -}}
	  {xc3640000 xbfb851ec 1 0 1}}
	 {{x 3
	   {x44b07fff -}}
	  {x44b37fff x3fb851ec 1 0 1}}}
        {{{0 -}}
	 {{0 -}}}}}     idem}
     {tx x447ac000 x446aa2e9 x445f22e9}
     {a osbe 0 osee 0 osw x40000000 osf 0 str 1 ltn x447ac000 ltm x447ac000 tt x41200000}}}}}}
 toolbox {selectAll {
  { selectAll str 1 ssx 1 ssy 1 sf 1 }
  { createBezier str 1 ssx 1 ssy 1 sf 1 sb 1 tt 4 }
  { createBezierCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createBSpline str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createEllipse str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createRectangle str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createRectangleCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createOpenSpline str 1 ssx 1 ssy 1 sf 1 tt 10 }
  { brush str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { eraser src 2 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { clone src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { reveal src 3 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { dodge src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { burn src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { blur src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { sharpen src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { smear src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
} }
 toolbar_brush_hardness 0.200000003
 toolbar_openspline_width 2
 toolbar_source_transform_scale {1 1}
 toolbar_source_transform_center {320 240}
 colorOverlay {0 0 0 0}
 lifetime_type "all frames"
 motionblur_shutter_offset_type centred
 openspline_width 2
 name RotoPaint6
 xpos 2091
 ypos -1774
}
Glint {
 repeat 32
 length 132000
 oddlen 0
 rotation 50
 steps 10
 effect_only true
 w_channel -depth.Z
 tolerance 0
 name Glint7
 xpos 2091
 ypos -1606
}
Noise {
 inputs 0
 type turbulence
 size 30
 zoffset {{frame/20}}
 gain 0.6
 translate {{frame*10} 0}
 center {1024 778}
 name Noise9
 xpos 1821
 ypos -1690
}
RotoPaint {
 inputs 0
 cliptype none
 curves {{{v x3f99999a}
  {f 0}
  {n
   {layer Root
    {f 2097152}
    {t x44800000 x44428000}
    {a pt1x 0 pt1y 0 pt2x 0 pt2y 0 pt3x 0 pt3y 0 pt4x 0 pt4y 0 ptex00 0 ptex01 0 ptex02 0 ptex03 0 ptex10 0 ptex11 0 ptex12 0 ptex13 0 ptex20 0 ptex21 0 ptex22 0 ptex23 0 ptex30 0 ptex31 0 ptex32 0 ptex33 0 ptof1x 0 ptof1y 0 ptof2x 0 ptof2y 0 ptof3x 0 ptof3y 0 ptof4x 0 ptof4y 0 pterr 0 ptrefset 0 ptmot x40800000 ptref 0}
    {curvegroup OpenSpline3 1049088 bezier
     {{cc
       {f 1056800}
       {px
        {1 x42980000}
        {{xc2438e36}
      {x4260e390}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {x442e8000}
      {x44c64000}}
        {{x42438e39}
      {xc260e38e}}
        {{xc2929c76}
      {x41551407}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x44658000 -}
       {x443b8000 -}}
      {{x44a6a000 -}
       {x44ab3999 -}}}
        {{x42929c76}
      {xc15513fd}}
        {{xc26b8730}
      {x413af119}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x44a3a000 -}
       {x44a96cce -}}
      {{x44b86000 -}}}
        {{x426b8730}
      {xc13af115}}
        {{xc26ff881}
      {xc007832f}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {x44b26000 x44aa9334}
      {x449a0000 x449c0000}}
        {{x426ff881}
      {x4007834c}}
        {{xc1ef91e8}
      {xc162ba51}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x44e36000 -}
       {x44e82ccd -}}
      {{x44baa000 -}
       {x44b9a000 -}}}
        {{x41ef91e7}
      {x4162ba5a}}
        {{x4084257b}
      {x42037c48}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x44f60000 -}
       {x44fcffff -}}
      {{x44ba0000 -}
       {x44b6cccd -}}}
        {{xc0842570}
      {xc2037c48}}
        {{{x419559ab -}
       {x4224ccc0 -}}
      {{x41f443ab -}
       {x41c4cc80 -}}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x44e04000 0 1 x3ec49bbc 1}
       {x44e3d99a x3ec49bbc 1 0 1}}
      {{x44a1c000 0 1 xbeaec2fd 1}
       {x449e8cce xbeaec2fd 1 0 1}}}
        {{{xc19559a9 -}
       {xc1f5d200 -}}
      {{xc1f443ad -}
       {xc192c680 -}}}
        {{{x3ed50d5a -}
       {x40da9700 -}}
      {{x420f2491 -}
       {x420c8520 -}}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x44db4000 0 1 xbf4a11b5 1}
       {x44d5d999 xbf4a11b5 1 0 1}}
      {{x448e4000 0 1 xbe704ccd 1}
       {x448b3ffe xbe704ccd 1 0 1}}}
        {{{xbed50ca5 -}
       {xc11ccd00 -}}
      {{xc20f2491 -}
       {xc2499980 -}}}
        {{xc12dce22}
      {x41d35d68}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x44dfc000 -}
       {x44d75998 -}}
      {{x446d8000 -}
       {x44664ccc -}}}
        {{x412dce26}
      {xc1d35d67}}
        {{{xc1b905be -}
       {xc2aaccc0 -}}
      {{xc1862426 -}
       {xc2b0ccd0 -}}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x44ea0000 0 1 xbcaec5f9 1}
       {x44e9cccc xbcaec5f9 1 0 1}}
      {{x4454c000 0 1 xbcaec28f 1}
       {x4454599a xbcaec28f 1 0 1}}}
        {{{x41b905bc -}
       {x419ec8c0 -}}
      {{x41862429 -}
       {x41a45cc0 -}}}
        {{xc1a28640}
      {xc1dd46f6}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x44f3c000 -}
       {x44f2f333 -}}
      {{x44854000 -}
       {x44844000 -}}}
        {{x41a2863a}
      {x41dd46fa}}
        {{xc1acc1e6}
      {xc123f91c}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x45025000 -}
       {x45015001 -}}
      {{x448ea000 -}
       {x4494d333 -}}}
        {{x41acc1e5}
      {x4123f91e}}
        {{xc1b4bf75}
      {xc0f9b52b}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {x4508a000}
      {x44934000}}
        {{x41b4bf74}
      {x40f9b539}}
        {{xc2038e39}
      {xc12e38df}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {x4511e000}
      {x44996000}}
        {{x42038e39}
      {x412e38e5}}}}     idem}
     {tx 1 x44d56db7 x449bd249}
     {a osbe 0 osee 0 osw x40000000 osf 0 str 1 tt x41200000}}
    {curvegroup OpenSpline2 1049088 bezier
     {{cc
       {f 1056800}
       {px
        {1 x42980000}
        {{0}
      {0}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x447ec000 -}
       {x44805fff -}}
      {{xc1c00000 -}
       {xc2600000 -}}}
        {{x4262aaab}
      {x4203ffff}}
        {{x40f2f461}
      {xc28244b9}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x4494a000 -}
       {x448dd332 -}}
      {{x42960000 -}
       {x42893330 -}}}
        {{xc0f2f465}
      {x428244b9}}
        {{x428671b0}
      {xc21b3d30}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x44740cce -}
       {x44700ccf -}}
      {{x43b56665 -}
       {x43cd6665 -}}}
        {{xc2aa6670}
      {x4244ccd8}}
        {{x429c4e60}
      {x40ae9f80}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x441e0cce -}
       {x44147336 -}}
      {{x43e8cccb -}
       {x43fd9999 -}}}
        {{xc2a06670}
      {xc0b332c0}}
        {{x41ec1ef8}
      {x41aa28f9}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x43d00000 -}
       {x43b80000 -}}
      {{x43c40000 -}
       {x43c0cccc -}}}
        {{xc1ec1ef7}
      {xc1aa28fb}}
        {{xc145b438}
      {x4208df3f}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x43c30000 -}
       {x43b30002 -}}
      {{x438f0000 -}
       {x43823334 -}}}
        {{x4145b43e}
      {xc208df3f}}
        {{xc242bebe}
      {x41542f66}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {x43f70000 x43dfcccc}
      {x43300000 x43199998}}
        {{x4242bebf}
      {xc1542f59}}
        {{xc203a2bb}
      {xc1e73ba0}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x44248000 -}
       {x442a8000 -}}
      {{x43550000 -}
       {x43236664 -}}}
        {{x4203a2b9}
      {x41e73ba5}}
        {{x41b75f47}
      {xc2154b54}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {x4428c000}
      {x43a3cccc}}
        {{xc1b75f4a}
      {x42154b53}}
        {{x42b265d7}
      {xc26e14ce}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x43d80000 -}
       {x43e9999a -}}
      {{x44114000 -}
       {x4417a666 -}}}
        {{xc2b265d8}
      {x426e14ca}}
        {{x429d52a7}
      {xc20b834f}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {{x4314ccd0 -}
       {x43333338 -}}
      {{x44338ccd -}
       {x443cc000 -}}}
        {{xc29d52a9}
      {x420b8347}}
        {{x41f7b777}
      {xc16b8f1e}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {xc2c40000}
      {x444c0002}}
        {{xc1f7b77b}
      {x416b8f11}}
        {{x41f55556}
      {xc1755558}}
        {{a osw
       {{1 1}
        {x42980000}}	 osf
       {{1 0}
        {x42980000}}}
      {xc33e0000}
      {x44578002}}
        {{0}
      {0}}}}     idem}
     {tx 1 x4401c000 x43c7b13b}
     {a osbe 0 osee 0 osw x40000000 osf 0 str 1 tt x41200000}}
    {curvegroup OpenSpline1 1049088 bezier
     {{cc
       {f 1056800}
       {px
        {1 x41d00000 x424c0000 x42980000}
        {{{0 -}}
	 {{0 -}}}
        {{a osw
	  {{1 1 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}	 osf
	  {{1 0 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}}
	 {{x4504dfff 0 1 xbf072b85 1}
	  {x4503accb xbf9fbeb8 1 xbf9fbeb8 1}
	  {x4500f997 -}
	  {x45012cca x3e449ae1 1 0 1}}
	 {{x43df0000 0 1 x3fb020c3 1}
	  {x43f0999a x3fbc6a8f 1 x3fbc6a8f 1}
	  {x4401e668 x3f872b14 1 x3f872b14 1}
	  {x44058002 x3eac083e 1 0 1}}}
        {{{x 2
	   {xc3bcaaa6 -}}
	  {xc38a3320 x4065cda9 1 x4065cda9 1}
	  {xc345cca0 x403aec36 1 0 1}}
	 {{x 2
	   {xc26ffffd -}}
	  {xc2c4ccd4 xbfe6667d 1 xbfe6667d 1}
	  {xc3160008 xc00c8b4f 1 0 1}}}
        {{{x 3
	   {x434fc5cc -}}
	  {x4345e650 xbf17a629 1 0 1}}
	 {{x 3
	   {xc13c9e11 -}}
	  {x417cccc0 x3fd3e15a 1 0 1}}}
        {{a osw
	  {{1 1 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}	 osf
	  {{1 0 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}}
	 {{x44c40fff 0 1 x3f449ccd 1}
	  {x44c5a99b -}
	  {x44c47669 xbe449ae1 1 xbe449ae1 1}
	  {x44c44336 xb10f5c29 1 0 1}}
	 {{x43cd3333 0 1 xc00b4395 1}
	  {x43b53333 xbfb4395c 1 xbfb4395c 1}
	  {x43a9ffff xbfac082e 1 xbfac082e 1}
	  {x4393999a xc001061b 1 0 1}}}
        {{{x 3
	   {xc34fc5cd -}}
	  {xc34f7268 x3ca01e14 1 0 1}}
	 {{x 3
	   {x413c9dbd -}}
	  {xc1847fd0 xbfd9bc2d 1 0 1}}}
        {{{x 3
	   {x41fcaa7c -}}
	  {x40800400 xbfd3d5e8 1 0 1}}
	 {{x 3
	   {xc34db23d -}}
	  {xc318999e x404be3aa 1 0 1}}}
        {{a osw
	  {{1 1 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}	 osf
	  {{1 0 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}}
	 {{x449fffff 0 1 x3f449b5c 1}
	  {x44a19998 -}
	  {x449f3330 xbf872b33 1 xbf872b33 1}
	  {x449afffc xbfbe76e1 1 0 1}}
	 {{x43f70000 0 1 x3fc49bb8 1}
	  {x4401e667 -}
	  {x43ffccce xbef5c27b 1 xbef5c27b 1}
	  {x43f7cccf xbf3851d2 1 0 1}}}
        {{{x 3
	   {xc1fcaa8c -}}
	  {xc0ae8600 x3fc8ac86 1 0 1}}
	 {{x 3
	   {x434db23d -}}
	  {x4350090e x3e0fb748 1 0 1}}}
        {{{x 3
	   {x41ba6680 -}}
	  {x4059b200 xbf98d229 1 0 1}}
	 {{x 3
	   {xc325999c -}}
	  {xc3273254 xbdc42f5c 1 0 1}}}
        {{a osw
	  {{1 1 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}	 osf
	  {{1 0 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}}
	 {{x44b75666 0 1 x3f5d2f33 1}
	  {x44b92333 -}
	  {x44b7bccc xbf872b0a 1 xbf872b0a 1}
	  {x44b28999 xbffbe75c 1 0 1}}
	 {{x44572667 0 1 x3e937429 1}
	  {x44585999 -}
	  {x444f2666 -}
	  {x4453f334 x3f9374e1 1 0 1}}}
        {{{x 3
	   {xc1b12900 -}}
	  {xc0533200 x3f90baf6 1 0 1}}
	 {{x 3
	   {x431d63fc -}}
	  {x43223330 x3e93be8f 1 0 1}}}
        {{{x 3
	   {x430e19a0 -}}
	  {x43098010 xbe8d4eb8 1 0 1}}
	 {{x 3
	   {xc1f99940 -}}
	  {xc2226660 xbf1062e1 1 0 1}}}
        {{a osw
	  {{1 1 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}	 osf
	  {{1 0 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}}
	 {{x449efccc 0 1 xbf1ba55c 1}
	  {x449cfccd xbf343971 1 xbf343971 1}
	  {x449a9665 -}
	  {x449c2ffe x3f449b5c 1 0 1}}
	 {{x44840665 0 1 xbfcac071 1}
	  {x447f3ffe xbf872af6 1 xbf872af6 1}
	  {x447ad998 -}
	  {x4480d333 x3fd0e585 1 0 1}}}
        {{{x 3
	   {xc31b3e30 -}}
	  {xc3186f40 x3e2c8b85 1 0 1}}
	 {{x 3
	   {x420857a0 -}}
	  {x42340a00 x3f27cbae 1 0 1}}}
        {{{x 3
	   {x43014ccc -}}
	  {x42e50000 xbf6353ec 1 0 1}}
	 {{x 3
	   {xc1633340 -}}
	  {xc1e599c0 xbf5eb88f 1 0 1}}}
        {{a osw
	  {{1 1 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}	 osf
	  {{1 0 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}}
	 {{x44476000 0 1 xbedd2e7b 1}
	  {x4444f99b xbe9374a4 1 xbe9374a4 1}
	  {x4443c667 xbee5607b 1 xbee5607b 1}
	  {x443f6000 xbf54fe0a 1 0 1}}
	 {{x4478c666 0 1 x400d4fcd 1}
	  {x4480fccc -}
	  {x447cc666 xbf5d2ee1 1 xbf5d2ee1 1}
	  {x44772cce xbf697890 1 0 1}}}
        {{{x 3
	   {xc2f3d2e8 -}}
	  {xc2edede0 x3e351571 1 0 1}}
	 {{x 3
	   {x41563800 -}}
	  {x41ee8dc0 x3f7c5f85 1 0 1}}}
        {{{x42a53338 -}}
	 {{x40bccc80 -}}}
        {{a osw
	  {{1 1 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}	 osf
	  {{1 0 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}}
	 {{x440ee665 0 1 xbe656029 1}
	  {x440db332 xbe03123d 1 xbe03123d 1}
	  {x440d4ccc -}
	  {x440f4ccb x3ef5c214 1 0 1}}
	 {{x445f8ccd 0 1 x408a3d78 1}
	  {x44718cce -}
	  {x446e599a xbf6d9171 1 xbf6d9171 1}
	  {x4465f334 xbfc6a7e1 1 0 1}}}
        {{{xc2f4aaa0 -}}
	 {{xc10bcec0 -}}}
        {{{x43243389 -}}
	 {{xc2bed864 -}}}
        {{a osw
	  {{1 1 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}	 osf
	  {{1 0 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}}
	 {{x 2
	   {x4395ccca -}}
	  {x43a2999a x3f1374a4 1 x3f1374a4 1}
	  {x43a50000 xb1a3d70a 1 0 1}}
	 {{x 2
	   {x447ed998 -}}
	  {x44813999 -}
	  {x447ba666 xbfd0e548 1 0 1}}}
        {{{xc324338a -}}
	 {{x42bed861 -}}}
        {{{x431c40ea -}}
	 {{xc2d7e46f -}}}
        {{a osw
	  {{1 1 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}	 osf
	  {{1 0 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}}
	 {{x42d0fff8 0 1 xbec49b5c 1}
	  {x42c43330 -}
	  {x430219a0 x3f978d66 1 x3f978d66 1}
	  {x431d4cd4 x3f851eb3 1 0 1}}
	 {{x449a8665 0 1 x4039580f 1}
	  {x44a28665 x3ff1aa00 1 x3ff1aa00 1}
	  {x44a65332 x3f7df385 1 x3f7df385 1}
	  {x44a8b997 x3f27ef0a 1 0 1}}}
        {{{xc31c40e9 -}}
	 {{x42d7e471 -}}}
        {{{x4347ffff -}}
	 {{xc2f80003 -}}}
        {{a osw
	  {{1 1 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}	 osf
	  {{1 0 -}
	   {x41d00000}
	   {x424c0000}
	   {x42980000}}}
	 {{x 3
	   {xc34c0000 -}}
	  {xc3640000 xbfb851ec 1 0 1}}
	 {{x 3
	   {x44b07fff -}}
	  {x44b37fff x3fb851ec 1 0 1}}}
        {{{0 -}}
	 {{0 -}}}}}     idem}
     {tx x447ac000 x446aa2e9 x445f22e9}
     {a osbe 0 osee 0 osw x40000000 osf 0 str 1 ltn x447ac000 ltm x447ac000 tt x41200000}}}}}}
 toolbox {selectAll {
  { selectAll str 1 ssx 1 ssy 1 sf 1 }
  { createBezier str 1 ssx 1 ssy 1 sf 1 sb 1 tt 4 }
  { createBezierCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createBSpline str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createEllipse str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createRectangle str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createRectangleCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createOpenSpline str 1 ssx 1 ssy 1 sf 1 tt 10 }
  { brush str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { eraser src 2 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { clone src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { reveal src 3 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { dodge src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { burn src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { blur src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { sharpen src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { smear src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
} }
 toolbar_brush_hardness 0.200000003
 toolbar_openspline_width 2
 toolbar_source_transform_scale {1 1}
 toolbar_source_transform_center {320 240}
 colorOverlay {0 0 0 0}
 lifetime_type "all frames"
 motionblur_shutter_offset_type centred
 openspline_width 2
 name RotoPaint7
 xpos 1726
 ypos -1780
}
set N1b6d0f40 [stack 0]
push $N1b6d0f40
Copy {
 inputs 2+1
 from0 rgba.alpha
 to0 depth.Z
 name Copy8
 xpos 1726
 ypos -1696
}
Glint {
 repeat 32
 length 140000
 oddlen 0
 rotation 90
 steps 9
 effect_only true
 w_channel depth.Z
 tolerance 0
 name Glint6
 xpos 1726
 ypos -1606
}
Grid {
 inputs 0
 number {0 {"height / (width / Grid3.number.0 / 0.576441) "}}
 size {{parent.Grid3.size}}
 name Grid1
 xpos 2546
 ypos -1618
}
Grade {
 channels alpha
 white 1000000
 white_clamp true
 name Grade12
 xpos 2546
 ypos -1586
}
CropPadded {
 inputs 0
 name CropPadded2
 xpos 2671
 ypos -1881
 box {0 0 2224 1548}
 padding 100
 intersect false
}
set N1b82cf80 [stack 0]
Grid {
 number {0 {"height / (width / Grid3.number.0 / (23/39.9) / 2 ) "}}
 size {{parent.Grid3.size}}
 name Grid2
 xpos 2727
 ypos -1789
}
push $N1b82cf80
Expression {
 expr3 0
 name Expression2
 xpos 2671
 ypos -1857
}
Grid {
 number {20 0}
 size 1.01
 name Grid3
 xpos 2590
 ypos -1786
}
ChannelMerge {
 inputs 2
 operation multiply
 name ChannelMerge2
 xpos 2671
 ypos -1715
}
Shuffle {
 in alpha
 name Shuffle10
 xpos 2671
 ypos -1667
}
TransformMasked {
 inputs 1+1
 translate {{"width / Grid3.number.0 / 2"} 0}
 center {1112 774}
 filter Impulse
 shutteroffset centred
 name Transform3
 xpos 2671
 ypos -1586
}
Crop {
 box {0 0 2224 1548}
 name Crop9
 xpos 2671
 ypos -1550
}
Grade {
 channels rgba
 gamma 0.8
 name Grade11
 xpos 2671
 ypos -1483
}
Dot {
 name Dot30
 xpos 2699
 ypos -1439
}
set N1b8bfff0 [stack 0]
Noise {
 replace true
 size 50
 zoffset {{frame/20}}
 octaves 1
 lacunarity 0
 gamma 0.6
 center {1112 774}
 name Noise5
 xpos 2540
 ypos -1391
}
Grade {
 channels rgba
 white 2.9
 name Grade10
 xpos 2540
 ypos -1367
}
push $N1b8bfff0
Multiply {
 inputs 1+1
 value 0
 name Multiply2
 xpos 2671
 ypos -1373
}
ZDefocus2 {
 math depth
 size 84
 max_size {{size}}
 layers 10
 layerCurve 10
 filter_type bladed
 legacy_resize_mode false
 show_legacy_resize_mode false
 blades 6
 roundness 0
 rotation 30
 inner_size 1
 inner_brightness 1
 name ZDefocus10
 xpos 2671
 ypos -1297
 addUserKnob {20 camera_tab l "Camera (DNeg)"}
 addUserKnob {22 create_camera_knobs l "create camera knobs and expressions" -STARTLINE T "__import__('dnnuke.menu.toolbar.filter.zdefocus', fromlist=\['createZDefocusCameraKnobs']).createZDefocusCameraKnobs(nuke.thisNode())"}
 addUserKnob {43 camera_knobs_info l "" +STARTLINE}
 camera_knobs_info "For a more intuitive way of controlling the depth of field, you can have camera knobs here (such as focal length, fstop etc.) along with expressions to drive ZDefocus.\n\nThe ZDefocus knobs that will be affected are:\n   depth channel\n   math\n   size\n   maximum\n   filter shape\n   aspect ratio\n\nIf you want to drive the camera knobs as well as the focal point from an existing camera you can use the Tools->Create Node from Selected Node->ZDefocus from ZenCamera, after selecting the ZenCamera node.\n\nThe same applies for BokehZDefocus."
}
Grade {
 channels rgba
 white 20000
 name Grade8
 xpos 2671
 ypos -1233
}
Shuffle {
 red alpha
 green alpha
 blue alpha
 name Shuffle9
 xpos 2671
 ypos -1202
}
FilterErode {
 channels rgba
 size 3
 name FilterErode5
 xpos 2671
 ypos -1161
}
FilterErode {
 channels rgba
 size {{-parent.FilterErode5.size}}
 name FilterErode6
 xpos 2671
 ypos -1128
}
Clamp {
 maximum 14
 name Clamp3
 xpos 2672
 ypos -1104
}
Grade {
 channels rgba
 white 70
 reverse true
 name Grade9
 xpos 2672
 ypos -1043
}
EdgeDetectWrapper {
 channels rgba
 name EdgeDetect3
 xpos 2672
 ypos -995
}
Grid {
 inputs 0
 number {0 {"height / (width / Grid9.number.0 / 0.576441) "}}
 size {{parent.Grid9.size}}
 name Grid5
 xpos 3258
 ypos -1617
}
Grade {
 channels alpha
 white 1000000
 white_clamp true
 name Grade13
 xpos 3258
 ypos -1585
}
CropPadded {
 inputs 0
 name CropPadded3
 xpos 3383
 ypos -1880
 box {0 0 2224 1548}
 padding 100
 intersect false
}
Expression {
 expr3 0
 name Expression3
 xpos 3383
 ypos -1856
}
set N1b9b3640 [stack 0]
Grid {
 number {0 {"height / (width / Grid9.number.0 / (23/39.9) / 2 ) "}}
 size {{parent.Grid9.size}}
 name Grid8
 xpos 3439
 ypos -1788
}
push $N1b9b3640
Grid {
 number {30 0}
 size 1.01
 name Grid9
 xpos 3299
 ypos -1789
}
ChannelMerge {
 inputs 2
 operation multiply
 name ChannelMerge6
 xpos 3383
 ypos -1714
}
Shuffle {
 in alpha
 name Shuffle11
 xpos 3383
 ypos -1666
}
TransformMasked {
 inputs 1+1
 translate {{"width / Grid9.number.0 / 2"} 0}
 center {1112 774}
 filter Impulse
 shutteroffset centred
 name Transform5
 xpos 3383
 ypos -1585
}
Crop {
 box {0 0 2224 1548}
 name Crop8
 xpos 3383
 ypos -1549
}
Grade {
 channels rgba
 gamma 0.8
 name Grade14
 xpos 3383
 ypos -1482
}
Dot {
 name Dot31
 xpos 3411
 ypos -1438
}
set N1ba273d0 [stack 0]
Noise {
 replace true
 size 4
 zoffset {{frame/20}}
 octaves 1
 lacunarity 0
 gain 0.7
 gamma 0.61
 center {1112 774}
 name Noise6
 xpos 3252
 ypos -1390
}
Grade {
 channels rgba
 white 2.9
 name Grade16
 xpos 3252
 ypos -1366
}
push $N1ba273d0
Multiply {
 inputs 1+1
 value 0
 name Multiply3
 xpos 3383
 ypos -1372
}
Crop {
 box {0 0 1870 1080}
 name Crop11
 xpos 3383
 ypos -1336
}
ZDefocus2 {
 math depth
 size 164
 max_size {{size}}
 layers 10
 layerCurve 10
 legacy_resize_mode false
 show_legacy_resize_mode false
 blades 6
 roundness 0
 rotation 30
 inner_size 1
 inner_brightness 1
 name ZDefocus11
 xpos 3383
 ypos -1288
 addUserKnob {20 camera_tab l "Camera (DNeg)"}
 addUserKnob {22 create_camera_knobs l "create camera knobs and expressions" -STARTLINE T "__import__('dnnuke.menu.toolbar.filter.zdefocus', fromlist=\['createZDefocusCameraKnobs']).createZDefocusCameraKnobs(nuke.thisNode())"}
 addUserKnob {43 camera_knobs_info l "" +STARTLINE}
 camera_knobs_info "For a more intuitive way of controlling the depth of field, you can have camera knobs here (such as focal length, fstop etc.) along with expressions to drive ZDefocus.\n\nThe ZDefocus knobs that will be affected are:\n   depth channel\n   math\n   size\n   maximum\n   filter shape\n   aspect ratio\n\nIf you want to drive the camera knobs as well as the focal point from an existing camera you can use the Tools->Create Node from Selected Node->ZDefocus from ZenCamera, after selecting the ZenCamera node.\n\nThe same applies for BokehZDefocus."
}
Grade {
 channels rgba
 white 20000
 name Grade20
 xpos 3383
 ypos -1232
}
Shuffle {
 red alpha
 green alpha
 blue alpha
 name Shuffle17
 xpos 3383
 ypos -1201
}
FilterErode {
 channels rgba
 size 3
 name FilterErode7
 xpos 3383
 ypos -1165
}
FilterErode {
 channels rgba
 size {{-parent.FilterErode7.size}}
 name FilterErode8
 xpos 3383
 ypos -1132
}
Clamp {
 maximum 14
 name Clamp5
 xpos 3384
 ypos -1108
}
Grade {
 channels rgba
 white 20
 reverse true
 name Grade21
 xpos 3384
 ypos -1045
}
EdgeDetectWrapper {
 channels rgba
 name EdgeDetect7
 xpos 3384
 ypos -987
}
FilterErode {
 channels rgba
 size -30
 filter gaussian
 name FilterErode9
 xpos 3384
 ypos -920
}
FilterErode {
 channels rgba
 size {{-parent.FilterErode9.size}}
 filter gaussian
 name FilterErode10
 xpos 3384
 ypos -888
}
Clamp {
 maximum 14
 name Clamp6
 xpos 3384
 ypos -855
}
Grade {
 channels rgba
 white 2
 name Grade22
 xpos 3385
 ypos -802
}
EdgeDetectWrapper {
 channels rgba
 name EdgeDetect8
 xpos 3385
 ypos -750
}
Sharpen {
 amount 5
 size 5
 name Sharpen1
 xpos 3385
 ypos -711
}
Noise {
 inputs 0
 replace true
 size 100
 zoffset {{frame/20}}
 octaves 1
 lacunarity 0
 center {1112 774}
 name Noise8
 xpos 4624
 ypos -1807
}
Noise {
 inputs 0
 replace true
 size 100
 zoffset {{frame/20}}
 gain 0.8
 center {1112 774}
 name Noise10
 xpos 4751
 ypos -1808
}
Glass {
 inputs 2
 name Glass2
 xpos 4695
 ypos -1726
 channels rgb
 from0 rgba.red
 displace 10000
}
Grade {
 white {1 0.675242424 0.4909615517 1}
 name Grade28
 xpos 4691
 ypos -1702
}
Expression {
 expr3 0
 name Expression1
 xpos 4691
 ypos -1678
}
set N1bd176e0 [stack 0]
FrameHold {
 first_frame 1075
 name FrameHold2
 xpos 4691
 ypos -1594
 addUserKnob {20 dneg l DNeg}
 addUserKnob {26 _version l "" +STARTLINE +INVISIBLE T 1.1}
 addUserKnob {22 documentation l Documentation -STARTLINE T nukescripts.start('http://dnet/x/PwBDBg')}
 addUserKnob {26 ""}
 addUserKnob {3 first_frame_dup l "first frame" t "The first frame to use. If increment is set to 0, first frame is used at every frame of the input clip.\n\n<b>NOTE:</b> This is a duplicate of the knob on the first tab, here for convenience. Any change here will set the knob on the first tab."}
 first_frame_dup 1075
 addUserKnob {3 increment_dup l increment t "The increment to use when rendering every certain number of frames from the input clip. For example, if this is set to 5 and first frame is set to 1, Nuke only uses frames 1, 6, 11, 16, and so on from the input.\n\n<b>NOTE:</b> This is a duplicate of the knob on the first tab, here for convenience. Any change here will set the knob on the first tab."}
 addUserKnob {26 ""}
 addUserKnob {22 comp_first l "comp first" t "Set the hold frame to the comp first frame, a.k.a. in Nuke parlance, root.first_frame, or in Shotgun parlance, 'sg_head_in'" -STARTLINE T "__import__(\"dnnuke.init.callbacks.on_user_create.tabs.framehold\", fromlist=\[\"compFirstButton\"]).compFirstButton()"}
 addUserKnob {22 cut_in l "cut in" t "Set the hold frame to the cut in frame, which is the comp first frame plus head handles, or in Shotgun parlance, 'sg_cut_in'" -STARTLINE T "__import__(\"dnnuke.init.callbacks.on_user_create.tabs.framehold\", fromlist=\[\"cutInButton\"]).cutInButton()"}
 addUserKnob {22 cut_out l "cut out" t "Set the hold frame to the cut out frame, which is the comp last frame minus tail handles, or in Shotgun parlance, 'sg_cut_out'" -STARTLINE T "__import__(\"dnnuke.init.callbacks.on_user_create.tabs.framehold\", fromlist=\[\"cutOutButton\"]).cutOutButton()"}
 addUserKnob {22 comp_last l "comp last" t "Set the hold frame to the comp last frame, a.k.a. in Nuke parlance, root.last_frame, or in Shotgun parlance, 'sg_tail_out'" -STARTLINE T "__import__(\"dnnuke.init.callbacks.on_user_create.tabs.framehold\", fromlist=\[\"compLastButton\"]).compLastButton()"}
 addUserKnob {26 "" -STARTLINE T " "}
 addUserKnob {22 hero_frame l "hero frame" t "Set the hold frame to the hero frame from Shotgun, a.k.a. 'sg_hero_frame'. Beware that this may not always be set by the sequence supervisor. If not, go bug him or her!" T "__import__(\"dnnuke.init.callbacks.on_user_create.tabs.framehold\", fromlist=\[\"getHeroFrameButton\"]).getHeroFrameButton()" +STARTLINE}
 addUserKnob {22 middle_frame l "middle frame" t "Set the hold frame to the frame between the cut in and cut out." -STARTLINE T "__import__(\"dnnuke.init.callbacks.on_user_create.tabs.framehold\", fromlist=\[\"middleFrameButton\"]).middleFrameButton()"}
 addUserKnob {22 current_frame l "current frame" t "Set the hold frame to the current frame as in the active viewer's timeline, a.k.a. nuke.frame()." -STARTLINE T "__import__(\"dnnuke.init.callbacks.on_user_create.tabs.framehold\", fromlist=\[\"currentFrameButton\"]).currentFrameButton()"}
 addUserKnob {26 ""}
 addUserKnob {4 get_show_shot_from l "get show/shot from" t "Which should be used to retrieve info from the database? Default is <b>environment</b>, which uses \$SHOW and \$SHOT. If you want to use this node's input, use <b>metadata</b>, which will grab the input/filename value. Or, you can type it in manually with <b>specify</b>.," M {environment metadata specify}}
 addUserKnob {6 always_refresh l "always refresh" t "If unchecked, use locally-cached frame range information if available. If checked, always refresh from the database no matter what. Certain actions will cause locally-cached frame range info to become stale and override this preference, such as changing the <i>get show/shot from</i> value." -STARTLINE}
 addUserKnob {1 hidden_foce_startline +HIDDEN}
 addUserKnob {26 show -STARTLINE +HIDDEN T " "}
 addUserKnob {26 shot -STARTLINE +HIDDEN T " "}
 addUserKnob {1 show_specify l show +HIDDEN}
 show_specify " "
 addUserKnob {1 shot_specify l shot +HIDDEN}
 shot_specify " "
 addUserKnob {26 cut_range l "cut range" +HIDDEN T " "}
 addUserKnob {26 comp_range l "comp range" +HIDDEN T " "}
 addUserKnob {26 hero_frame_value l "hero frame" +HIDDEN T " "}
 addUserKnob {6 hidden_is_stale l "" -STARTLINE +HIDDEN}
 addUserKnob {1 cut_in_specify +HIDDEN}
 addUserKnob {1 cut_out_specify +HIDDEN}
 addUserKnob {1 comp_first_specify +HIDDEN}
 addUserKnob {1 comp_last_specify +HIDDEN}
 addUserKnob {1 hero_frame_specify +HIDDEN}
}
push $N1bd176e0
FrameHold {
 first_frame 1077
 name FrameHold3
 xpos 4786
 ypos -1592
 addUserKnob {20 dneg l DNeg}
 addUserKnob {26 _version l "" +STARTLINE +INVISIBLE T 1.1}
 addUserKnob {22 documentation l Documentation -STARTLINE T nukescripts.start('http://dnet/x/PwBDBg')}
 addUserKnob {26 ""}
 addUserKnob {3 first_frame_dup l "first frame" t "The first frame to use. If increment is set to 0, first frame is used at every frame of the input clip.\n\n<b>NOTE:</b> This is a duplicate of the knob on the first tab, here for convenience. Any change here will set the knob on the first tab."}
 first_frame_dup 1077
 addUserKnob {3 increment_dup l increment t "The increment to use when rendering every certain number of frames from the input clip. For example, if this is set to 5 and first frame is set to 1, Nuke only uses frames 1, 6, 11, 16, and so on from the input.\n\n<b>NOTE:</b> This is a duplicate of the knob on the first tab, here for convenience. Any change here will set the knob on the first tab."}
 addUserKnob {26 ""}
 addUserKnob {22 comp_first l "comp first" t "Set the hold frame to the comp first frame, a.k.a. in Nuke parlance, root.first_frame, or in Shotgun parlance, 'sg_head_in'" -STARTLINE T "__import__(\"dnnuke.init.callbacks.on_user_create.tabs.framehold\", fromlist=\[\"compFirstButton\"]).compFirstButton()"}
 addUserKnob {22 cut_in l "cut in" t "Set the hold frame to the cut in frame, which is the comp first frame plus head handles, or in Shotgun parlance, 'sg_cut_in'" -STARTLINE T "__import__(\"dnnuke.init.callbacks.on_user_create.tabs.framehold\", fromlist=\[\"cutInButton\"]).cutInButton()"}
 addUserKnob {22 cut_out l "cut out" t "Set the hold frame to the cut out frame, which is the comp last frame minus tail handles, or in Shotgun parlance, 'sg_cut_out'" -STARTLINE T "__import__(\"dnnuke.init.callbacks.on_user_create.tabs.framehold\", fromlist=\[\"cutOutButton\"]).cutOutButton()"}
 addUserKnob {22 comp_last l "comp last" t "Set the hold frame to the comp last frame, a.k.a. in Nuke parlance, root.last_frame, or in Shotgun parlance, 'sg_tail_out'" -STARTLINE T "__import__(\"dnnuke.init.callbacks.on_user_create.tabs.framehold\", fromlist=\[\"compLastButton\"]).compLastButton()"}
 addUserKnob {26 "" -STARTLINE T " "}
 addUserKnob {22 hero_frame l "hero frame" t "Set the hold frame to the hero frame from Shotgun, a.k.a. 'sg_hero_frame'. Beware that this may not always be set by the sequence supervisor. If not, go bug him or her!" T "__import__(\"dnnuke.init.callbacks.on_user_create.tabs.framehold\", fromlist=\[\"getHeroFrameButton\"]).getHeroFrameButton()" +STARTLINE}
 addUserKnob {22 middle_frame l "middle frame" t "Set the hold frame to the frame between the cut in and cut out." -STARTLINE T "__import__(\"dnnuke.init.callbacks.on_user_create.tabs.framehold\", fromlist=\[\"middleFrameButton\"]).middleFrameButton()"}
 addUserKnob {22 current_frame l "current frame" t "Set the hold frame to the current frame as in the active viewer's timeline, a.k.a. nuke.frame()." -STARTLINE T "__import__(\"dnnuke.init.callbacks.on_user_create.tabs.framehold\", fromlist=\[\"currentFrameButton\"]).currentFrameButton()"}
 addUserKnob {26 ""}
 addUserKnob {4 get_show_shot_from l "get show/shot from" t "Which should be used to retrieve info from the database? Default is <b>environment</b>, which uses \$SHOW and \$SHOT. If you want to use this node's input, use <b>metadata</b>, which will grab the input/filename value. Or, you can type it in manually with <b>specify</b>.," M {environment metadata specify}}
 addUserKnob {6 always_refresh l "always refresh" t "If unchecked, use locally-cached frame range information if available. If checked, always refresh from the database no matter what. Certain actions will cause locally-cached frame range info to become stale and override this preference, such as changing the <i>get show/shot from</i> value." -STARTLINE}
 addUserKnob {1 hidden_foce_startline +HIDDEN}
 addUserKnob {26 show -STARTLINE +HIDDEN T " "}
 addUserKnob {26 shot -STARTLINE +HIDDEN T " "}
 addUserKnob {1 show_specify l show +HIDDEN}
 show_specify " "
 addUserKnob {1 shot_specify l shot +HIDDEN}
 shot_specify " "
 addUserKnob {26 cut_range l "cut range" +HIDDEN T " "}
 addUserKnob {26 comp_range l "comp range" +HIDDEN T " "}
 addUserKnob {26 hero_frame_value l "hero frame" +HIDDEN T " "}
 addUserKnob {6 hidden_is_stale l "" -STARTLINE +HIDDEN}
 addUserKnob {1 cut_in_specify +HIDDEN}
 addUserKnob {1 cut_out_specify +HIDDEN}
 addUserKnob {1 comp_first_specify +HIDDEN}
 addUserKnob {1 comp_last_specify +HIDDEN}
 addUserKnob {1 hero_frame_specify +HIDDEN}
}
Constant {
 inputs 0
 channels rgb
 format "1920 1080 0 0 1920 1080 1 Canon 5D mkIII HD"
 name Constant8
 xpos 5428
 ypos -1803
}
Noise {
 opacity 0.5
 size 2000
 zoffset {{frame/200}}
 octaves 2
 nyquist false
 lacunarity 50
 gain 10000
 gamma 1
 center {1112 774}
 color {7231.5 20000 2.498626709 1}
 name Noise15
 xpos 5428
 ypos -1702
}
Grade {
 channels rgba
 white 1e+12
 name Grade34
 xpos 5428
 ypos -1666
}
FilterErode {
 channels all
 size 20
 filter gaussian
 name FilterErode17
 xpos 5428
 ypos -1633
}
Matrix {
 matrix {
     {-36.23 {matrix.0} {matrix.0} {matrix.0} {matrix.0}}
     {{matrix.0} {"-matrix.0 * mult"} {matrix.6} {matrix.6} {matrix.0}}
     {{matrix.0} {matrix.6} -291.2 {matrix.6} {matrix.0}}
     {{matrix.0} {matrix.6} {matrix.6} {matrix.6} {matrix.0}}
     {{matrix.0} {matrix.0} {matrix.0} {matrix.0} {matrix.0}}
   }
 name Matrix4
 xpos 5428
 ypos -1569
 addUserKnob {20 User}
 addUserKnob {7 mult}
 mult 3
}
Constant {
 inputs 0
 channels rgb
 format "1920 1080 0 0 1920 1080 1 Canon 5D mkIII HD"
 name Constant9
 xpos 5593
 ypos -1805
}
Noise {
 opacity 0.5
 type turbulence
 size 100
 zoffset {{frame/500000}}
 octaves 1
 nyquist false
 lacunarity 1
 gain 1
 gamma 1
 center {1112 774}
 color {7231.5 20000 2.498626709 1}
 name Noise16
 xpos 5593
 ypos -1703
}
Grade {
 channels rgba
 white 1000000
 gamma 7
 name Grade35
 xpos 5593
 ypos -1672
}
FilterErode {
 channels all
 size 40
 filter triangle
 name FilterErode18
 xpos 5593
 ypos -1628
}
Matrix {
 matrix {
     {-36.63 {matrix.0} {matrix.0} {matrix.0} {matrix.0}}
     {{matrix.0} {"-matrix.0 * mult"} {matrix.6} {matrix.6} {matrix.0}}
     {{matrix.0} {matrix.6} -293.2 {matrix.6} {matrix.0}}
     {{matrix.0} {matrix.6} {matrix.6} {matrix.6} {matrix.0}}
     {{matrix.0} {matrix.0} {matrix.0} {matrix.0} {matrix.0}}
   }
 name Matrix5
 xpos 5593
 ypos -1567
 addUserKnob {20 User}
 addUserKnob {7 mult}
 mult 2.999
}
Shuffle {
 red alpha
 green alpha
 blue alpha
 name Shuffle12
 xpos 5593
 ypos -1531
}
Constant {
 inputs 0
 channels rgb
 format "1920 1080 0 0 1920 1080 1 Canon 5D mkIII HD"
 name Constant7
 xpos 5154
 ypos -1809
}
Noise {
 opacity 0.5
 size 200
 zoffset {{frame/200}}
 octaves 2
 nyquist false
 lacunarity 5
 gain 0
 gamma 0.1
 center {1112 774}
 color {7231.5 20000 2.498627 1}
 name Noise13
 xpos 5154
 ypos -1711
}
Grade {
 channels rgba
 white 1e+12
 name Grade36
 xpos 5154
 ypos -1672
}
FilterErode {
 channels all
 size 20
 filter gaussian
 name FilterErode16
 xpos 5154
 ypos -1639
}
Matrix {
 matrix {
     {-36.23 {matrix.0} {matrix.0} {matrix.0} {matrix.0}}
     {{matrix.0} {"-matrix.0 * mult"} {matrix.6} {matrix.6} {matrix.0}}
     {{matrix.0} {matrix.6} -291.2 {matrix.6} {matrix.0}}
     {{matrix.0} {matrix.6} {matrix.6} {matrix.6} {matrix.0}}
     {{matrix.0} {matrix.0} {matrix.0} {matrix.0} {matrix.0}}
   }
 name Matrix3
 xpos 5154
 ypos -1569
 addUserKnob {20 User}
 addUserKnob {7 mult}
 mult 3
}
Constant {
 inputs 0
 channels rgb
 format "1920 1080 0 0 1920 1080 1 Canon 5D mkIII HD"
 name Constant6
 xpos 5812
 ypos -1800
}
Dot {
 name Dot37
 xpos 5840
 ypos -1701
}
Noise {
 opacity 0.5
 type turbulence
 size 32000
 zoffset {{frame/200}}
 octaves 3
 nyquist false
 lacunarity 8
 gain 3
 gamma 0.2
 center {1112 774}
 color {20000 20000 20000 1}
 name Noise14
 xpos 5812
 ypos -1645
}
set N1be39180 [stack 0]
TimeEcho {
 framesbehind 35
 frmaesfade 0
 name TimeEcho2
 xpos 5812
 ypos -1604
}
Matrix {
 matrix {
     {-20 {matrix.0} {matrix.0} {matrix.0} {matrix.0}}
     {{matrix.0} {"-matrix.0 * mult"} {matrix.6} {matrix.6} {matrix.0}}
     {{matrix.0} {matrix.6} 79 {matrix.6} {matrix.0}}
     {{matrix.0} {matrix.6} {matrix.6} {matrix.6} {matrix.0}}
     {{matrix.0} {matrix.0} {matrix.0} {matrix.0} {matrix.0}}
   }
 name Matrix2
 xpos 5812
 ypos -1555
 addUserKnob {20 User}
 addUserKnob {7 mult}
 mult 1.51
}
Invert {
 name Invert1
 xpos 5812
 ypos -1519
}
Noise {
 inputs 0
 type turbulence
 size 50
 lacunarity 1
 center {1112 774}
 name Noise3
 xpos 6108
 ypos -1782
}
Glint {
 repeat 12
 length 710
 rotation 10
 from_color -1
 to_color 1
 steps 10
 effect_only true
 name Glint2
 xpos 6108
 ypos -1758
}
Noise {
 inputs 0
 type turbulence
 size 10
 zoffset {{frame/20}}
 lacunarity 1
 gamma 0
 center {1112 774}
 name Noise4
 xpos 6385
 ypos -1814
}
Blur {
 size 50
 filter box
 name Blur6
 xpos 6385
 ypos -1770
}
Grade {
 channels rgba
 white 100
 gamma 5
 name Grade32
 xpos 6385
 ypos -1734
}
Clamp {
 name Clamp8
 xpos 6385
 ypos -1703
}
EdgeDetectWrapper {
 name EdgeDetect14
 xpos 6385
 ypos -1667
}
Noise {
 inputs 0
 type turbulence
 size 10
 zoffset {{frame/20}}
 lacunarity 1
 gain 0.3
 gamma 0.1
 center {1112 774}
 name Noise2
 xpos 6625
 ypos -1802
}
Glint {
 repeat 5
 length 10
 rotation 33
 from_color -1
 to_color 1
 name Glint9
 xpos 6625
 ypos -1737
}
Glint {
 repeat 5
 length 10
 rotation 33
 from_color -1
 to_color 1
 name Glint10
 xpos 6625
 ypos -1701
}
Glint {
 repeat 5
 length 10
 rotation 33
 from_color -1
 to_color 1
 name Glint11
 xpos 6625
 ypos -1665
}
Glint {
 repeat 5
 length 20
 rotation 58
 from_color -1
 to_color 1
 name Glint12
 xpos 6625
 ypos -1629
}
Glint {
 repeat 5
 length 30
 rotation 58
 from_color -1
 to_color 1
 name Glint13
 xpos 6625
 ypos -1593
}
Glint {
 repeat 5
 length 40
 rotation 58
 from_color -1
 to_color 1
 name Glint14
 xpos 6625
 ypos -1557
}
Glint {
 repeat 5
 rotation 58
 from_color -1
 to_color 1
 name Glint15
 xpos 6625
 ypos -1521
}
Glint {
 repeat 5
 length 60
 rotation 58
 from_color -1
 to_color 1
 name Glint16
 xpos 6625
 ypos -1485
}
Glint {
 repeat 5
 length 70
 rotation 58
 from_color -1
 to_color 1
 name Glint17
 xpos 6625
 ypos -1437
}
Grade {
 channels alpha
 white 0.08
 name Grade31
 xpos 6625
 ypos -1401
}
EdgeDetectWrapper {
 channels alpha
 name EdgeDetect15
 xpos 6625
 ypos -1365
}
Constant {
 inputs 0
 channels rgb
 format "1920 1080 0 0 1920 1080 1 Canon 5D mkIII HD"
 name Constant4
 xpos 6905
 ypos -1807
}
Dot {
 name Dot36
 xpos 6933
 ypos -1708
}
Noise {
 opacity 0.5
 type turbulence
 size 300
 zoffset {{frame/200}}
 octaves 2
 nyquist false
 gain 2
 gamma 0.1
 center {1112 774}
 color {10 9.45824337 5.332558155 1}
 name Noise12
 xpos 6905
 ypos -1609
}
FilterErode {
 channels all
 size 100
 filter gaussian
 name FilterErode15
 xpos 6905
 ypos -1570
}
Grade {
 channels all
 white 26000
 gamma 0
 black_clamp false
 name Grade33
 xpos 6905
 ypos -1515
}
Dot {
 name Dot45
 xpos 6933
 ypos -1443
}
set N1bfe14c0 [stack 0]
push $N1bfe14c0
Blur {
 size 1
 name Blur10
 xpos 7023
 ypos -1390
}
Merge2 {
 inputs 2
 operation from
 name Merge7
 xpos 6905
 ypos -1384
}
Constant {
 inputs 0
 channels rgb
 name Constant5
 xpos 7267
 ypos -1810
}
Dot {
 name Dot44
 xpos 7293
 ypos -1724
}
set N1c00c540 [stack 0]
Noise {
 size 19
 zoffset 2.58
 octaves 3
 nyquist false
 lacunarity 2.06
 gain 0.71
 gamma 0.41
 center {1024 778}
 name Noise24
 xpos 7265
 ypos -1667
}
LevelSet {
 name LevelSet14
 xpos 7265
 ypos -1643
}
Expression {
 channel0 {forward.u -forward.v}
 expr0 "a * (-forward.u)"
 channel1 {-forward.u forward.v}
 expr1 "a * (-forward.v)"
 name Expression34
 xpos 7265
 ypos -1607
}
push $N1c00c540
Dot {
 name Dot43
 xpos 7399
 ypos -1724
}
Noise {
 output {rgba.red rgba.green rgba.blue -rgba.alpha}
 type turbulence
 size 100
 zoffset {{frame/30}}
 octaves 1
 nyquist false
 center {1024 778}
 ramp linear
 color {0.3654305935 0.6137256622 1 1}
 color0 {0.008500000462 0.008500000462 0.008500000462 0}
 name Noise23
 xpos 7371
 ypos -1554
}
Copy {
 inputs 2
 from0 forward.u
 to0 forward.u
 from1 forward.v
 to1 forward.v
 name Copy11
 xpos 7265
 ypos -1566
}
IDistort {
 uv motion
 uv_scale 10
 blur_scale 0
 name IDistort2
 xpos 7265
 ypos -1518
}
Camera2 {
 inputs 0
 translate {0 0 7}
 focal 24.6
 name Camera8
 xpos 7868
 ypos -1588
 addUserKnob {20 DNeg}
 addUserKnob {26 _version l "" +STARTLINE +INVISIBLE T 1.0}
 addUserKnob {41 "horiz aperture" T haperture}
 addUserKnob {41 "vert aperture" T vaperture}
 addUserKnob {4 setApertureValues l "" t "Set aperture values based on registered camera sensor data. The 'read from file' knob needs to be disabled and any potential curves deleted." +STARTLINE M {"Set Aperture Values" ANNI/Delivery "Alexa 65/Full" "Alexa 65/Half Res" "Alexa MINI/4:3 Full Ana" "Alexa MINI/16:9 Full" "Alexa MINI/OpenGate" "Alexa MINI/16:9 1.78 Ana" "Alexa Mini/OpenGate" "Alexa XT/OpenGate" "Alexa XT/4:3 Full Ana" "Alexa XT/16:9 1.78" "Alexa XT/16:9 1.78 Ana" "Alexa XT/4:3 Full" "Alexa XT/Open Gate" "Alexa XT/Open Gate TC" "Alexa XT/SuperOpenGate" "Alexa XT/SuperOpenGate Cropped" "Arri 65/6k 1.3 ana" "Arri 65/6k 2.11" BF/Delivery "BOND /Anamorphic" "Blackmagic Prod 4K/4K" "Canon 5D mkIII/HD" "Canon C300/16:9" "Delivery Extractions/Arri 65 1.3 ana Working" "Delivery Extractions/Arri 65 Working" "Extractions/CFW Delivery" "Film 35mm/Cinemascope Centred" "Film 35mm/Full Aperture" "Generic/1080p HD" Generic/Anamorphic Generic/Spherical "GoPro/Generic 16:9" HERC/Alexa IMAX/8K "Internal Movie Extractions/TRAINVFX Working" "Internal Movie Extractions/Alexa XT OpenGate" "Internal Movie Extractions/Previs" "Internal Movie Extractions/Arri 65 1.3 ana Working" "Internal Movie Extractions/MLOU Delivery" "Internal Movie Extractions/MAGIC Working" "Movie Extractions/Alexa XT OpenGate" "Movie Extractions/Alexa XT 4:3 Full Ana" "Movie Extractions/Alexa MINI 4:3 Full Ana" "Movie Extractions/Alexa MINI 16:9 1.78" "Movie Extractions/Alexa XT 16:9 1.78" "Movie Extractions/Alexa MINI OpenGate" "Movie Extractions/Alexa XT 16:9 1.78 Ana" "Movie Extractions/Alexa MINI 16:9 1.78 Ana" "Movie Extractions/Phantom Flex 4k" "Movie Extractions/MAE Working 2" "Movie Extractions/TS Anamorphic 4K" "Movie Extractions/EXO Working" "Movie Extractions/Previs" "Movie Extractions/MAGIC Working" "Movie Extractions/DOTN Working" "Phantom Flex/4k" Previs/Anamorphic Previs/Spherical "Red Epic/5K" "Red Epic Dragon/6K HD" "Red Epic Dragon/5K Full" "Red Epic Dragon/5K FullFrame Scaled" "TM/Alexa MINI 4:3 Full Ana" "Working Extractions/Arri 65 6k 1.3 ana" "Working Extractions/Alexa XT 4:3 Full Ana" "Working Extractions/Alexa XT OpenGate" "Working Extractions/Alexa XT 16:9 1.78" "Working Extractions/Alexa MINI 4:3 Full Ana" "Working Extractions/Alexa MINI OpenGate" "Working Extractions/Alexa MINI 16:9 1.78" "Working Extractions/Phantom Flex 4k" "Working Extractions/Alexa XT 16:9 1.78 Ana" "Working Extractions/Alexa MINI 16:9 1.78 Ana" "Working Extractions/EXO Working" "Working Extractions/EXO Working 2" "Working Extractions/Arri 65 6k" "Working Extractions/Alexa LF 4.5k OpenGate" "Working Extractions/DOTN Working" "internal Movie Extractions/Red Epic Dragon 5k FullFrame Scaled" "internal Movie Extractions/Red Epic Dragon 5K FullFrame" "internal Movie Extractions/IMAX 6K" "internal Movie Extractions/IMAX 8K" "Alexa LF/4.5k OpenGate" "Digital SLR/Full Frame" "Digital SLR/Full Frame Portrait" "Digital SLR/APS-C" "Digital SLR/APS-C Portrait" Generic/HD LatLong/360 LatLong/180}}
 addUserKnob {26 ""}
 addUserKnob {22 makeProjector l "Make Projector..." T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeProjectorNode']).makeProjectorNode()" +STARTLINE}
 addUserKnob {22 makeLinkedProjector l "Make Linked Projector..." -STARTLINE T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeProjectorNode']).makeLinkedProjectorNode()"}
 addUserKnob {26 ""}
 addUserKnob {7 hshake l "hero horiz shake" R -1 1}
 addUserKnob {7 vshake l "hero vert shake" R -1 1}
 addUserKnob {7 shakeroll l "hero shake roll" R -180 180}
 addUserKnob {7 ahshake l "ambient horiz shake" R -1 1}
 addUserKnob {7 avshake l "ambient vert shake" R -1 1}
 addUserKnob {7 ashakeroll l "ambient shake roll" R -180 180}
 addUserKnob {26 ""}
 addUserKnob {22 makeShakeCamera l "Make Shake Camera" T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeAmbientHeroShakeCamera']).makeAmbientHeroShakeCamera()" +STARTLINE}
 addUserKnob {22 makeShakeTransform l "Make Shake Transform" -STARTLINE T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeAmbientHeroShakeTransform']).makeAmbientHeroShakeTransform()"}
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 addUserKnob {1 leaf_label l Leaf}
 addUserKnob {1 ivy_version l Version}
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
Group {
 inputs 0
 name Point_Plane
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 xpos 7709
 ypos -1796
 addUserKnob {20 User}
 addUserKnob {26 info_header l "" +STARTLINE T "Card Generator v1.1\n"}
 addUserKnob {26 info_basic l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {14 whx l "Point Density" t "The number of points in each axis.\nNote: Nuke can't handle images that are 1 in height or width, and as such you can't set this to 1. \nA workaround is that you can set the count to 2 and set the scale to 0 opposite axis." R 0 100}
 whx {130 {whx.w}}
 addUserKnob {26 _1 l "<b><font color=#7DADF9>Transform</font><b>"}
 addUserKnob {4 orientation l Orientation t "The orientation that the plane should face." M {XY XZ YZ ""}}
 addUserKnob {41 translate l Translate T Axis1.translate}
 addUserKnob {41 rotate l Rotate T Axis1.rotate}
 addUserKnob {14 scale l Scale R 0 100}
 scale {3.5 2}
 addUserKnob {41 uniform_scale l "Uniform scale" T Axis1.uniform_scale}
 addUserKnob {26 info_offsets l "<b><font color=#7DADF9>Offset Settings</font><b>"}
 addUserKnob {6 bool_enableOffset l "Enable Offset" t "Offset every other point, to create some variation in the look of the points.\nThis can look quite interesting when combined with the wire rendering mode." +STARTLINE}
 addUserKnob {7 float_offsetX l "Offset X"}
 float_offsetX 0.65
 addUserKnob {7 float_offsetY l "Offset Y"}
 float_offsetY 0.34
 addUserKnob {26 info_gab l "Gab Settings"}
 addUserKnob {6 bool_enableGab l "Enable Gab" t "Add gabs between rows of points." +STARTLINE}
 addUserKnob {7 float_gabSize l "Gab Size"}
 float_gabSize 0.075
 addUserKnob {7 float_gabFrequency l "Gab Frequency"}
 float_gabFrequency 0.06
}
 Reformat {
  inputs 0
  type "to box"
  format "256 256 0 0 256 256 1 square_256"
  box_width {{parent.whx.w}}
  box_height {{parent.whx.h}}
  box_fixed true
  scale 0.08
  black_outside true
  name Reformat8
  xpos -586
  ypos 17
 }
 Expression {
  expr0 x
  expr1 y
  name Expression2
  xpos -586
  ypos 61
 }
 Expression {
  expr0 r+fmod(g,2)/multR
  expr1 g+fmod(r,2)/multG
  expr2 b
  name Expression4
  xpos -586
  ypos 107
  disable {{!parent.bool_enableOffset}}
  addUserKnob {20 User}
  addUserKnob {7 multR R 0 5}
  multR {{(pow(10,parent.float_offsetX))-0.99999999}}
  addUserKnob {7 multG R 0 5}
  multG {{(pow(10,parent.float_offsetY))-0.9999999}}
 }
 Expression {
  temp_name0 _size
  temp_expr0 size
  temp_name1 _delta
  temp_expr1 delta
  channel0 {-rgba.red -rgba.green -rgba.blue none}
  expr0 ((r+(_size-fmod(r,_size))/_delta)-(_size/_delta))*1.048
  expr1 ((g+(_size-fmod(g,_size))/_delta)-(_size/_delta))*1.048
  expr2 ((b+(_size-fmod(b,_size))/_delta)-(_size/_delta))*1.048
  name Expression3
  xpos -586
  ypos 144
  disable {{!parent.bool_enableGab}}
  addUserKnob {20 User}
  addUserKnob {7 size R 0 10}
  size {{parent.float_gabFrequency*100}}
  addUserKnob {7 delta R 0 10}
  delta {{pow(40,parent.float_gabSize)}}
 }
 Expression {
  expr0 ((r/width)-.5)*2
  expr1 ((g/height)-.5)*2
  expr2 ((b/height)-.5)*2
  expr3 1
  name Expression1
  xpos -586
  ypos 221
 }
 Grade {
  white {{parent.scale.w} {parent.scale.h} 1 1}
  black_clamp false
  name Grade1
  xpos -586
  ypos 262
 }
set N1c0ec210 [stack 0]
 Shuffle {
  red blue
  green red
  blue green
  name Shuffle1
  xpos -480
  ypos 277
 }
 Grade {
  add {1 0 0 0}
  add_panelDropped true
  black_clamp false
  name Grade3
  xpos -480
  ypos 301
 }
push $N1c0ec210
 Shuffle {
  red green
  green blue
  blue red
  name Shuffle5
  xpos -703
  ypos 287
 }
 Grade {
  add {0 1 0 0}
  add_panelDropped true
  black_clamp false
  name Grade2
  xpos -703
  ypos 311
 }
push $N1c0ec210
 Grade {
  add {0 0 1 0}
  add_panelDropped true
  black_clamp false
  name Grade4
  xpos -586
  ypos 303
 }
 Switch {
  inputs 3
  which {{parent.orientation}}
  name Switch1
  xpos -586
  ypos 339
 }
 ColorMatrix {
  matrix {
      {{parent.Axis1.world_matrix.0} {parent.Axis1.world_matrix.1} {parent.Axis1.world_matrix.2}}
      {{parent.Axis1.world_matrix.4} {parent.Axis1.world_matrix.5} {parent.Axis1.world_matrix.6}}
      {{parent.Axis1.world_matrix.8} {parent.Axis1.world_matrix.9} {parent.Axis1.world_matrix.10}}
    }
  name ColorMatrix1
  xpos -586
  ypos 363
 }
 Grade {
  add {{parent.Axis1.world_matrix.3} {parent.Axis1.world_matrix.7} {parent.Axis1.world_matrix.11} 0}
  black_clamp false
  name Grade5
  xpos -586
  ypos 387
 }
 Shuffle {
  black white
  white white
  red2 white
  green2 white
  out pos
  out2 rgba
  name Shuffle2
  xpos -586
  ypos 424
 }
 ModifyMetaData {
  metadata {
   {set pointrender/n_points "\[expr \[value parent.whx.h]*\[value parent.whx.w]]"}
   {set pointrender/gen_type 1}
  }
  name SetMetaData
  xpos -586
  ypos 448
 }
 Grade {
  white {{1/((parent.whx.w*parent.whx.h)/40000)}}
  black_clamp false
  name Grade9
  xpos -586
  ypos 472
 }
 Crop {
  box {0 0 {parent.whx.w} {parent.whx.h}}
  crop false
  name Crop1
  xpos -586
  ypos 509
 }
 Output {
  name Output1
  xpos -586
  ypos 554
 }
 Axis2 {
  inputs 0
  name Axis1
  selected true
  xpos -424
  ypos 341
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  addUserKnob {1 leaf_label l Leaf}
  addUserKnob {1 ivy_version l Version}
  addUserKnob {43 ivy_notes l Notes}
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
end_group
Group {
 name PointFractal1
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 xpos 7709
 ypos -1684
 addUserKnob {20 User t test}
 addUserKnob {26 info l "" +STARTLINE T "Point Fractal 1.11\n"}
 addUserKnob {26 devider_noise l "<b><font color=#7DADF9>Noise Settings</font><b>"}
 addUserKnob {6 EnableOffset l "Enable Offset Input" t "Put a map into the \"Offset\" input of this node to modulate the noise based on the luminance of the map.\n\nThe red channal controls the low frequencies while the green channel controls the high frequencies.\n\nYou can for example use this to create a radially shaped noise." +STARTLINE}
 addUserKnob {6 Noise_Absolute l "Absolute Noise" t "Negative values in the noise offset is made positive." -STARTLINE}
 addUserKnob {3 Noise_Octaves l Octaves}
 Noise_Octaves 8
 addUserKnob {7 Noise_Gain l Gain}
 Noise_Gain 0.5
 addUserKnob {7 Noise_Lacunarity l Lacunarity R 0 4}
 Noise_Lacunarity 0.5
 addUserKnob {18 Amplitude}
 Amplitude 0.5
 addUserKnob {6 Amplitude_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {3 Itterations l Iterations}
 Itterations 1
 addUserKnob {26 invis_devider_noise l "" +STARTLINE T " "}
 addUserKnob {26 Devider_Frequency l "<b><font color=#7DADF9>Freq Control</font><b>"}
 addUserKnob {19 Freq_Offset l "General Offset" t "This is like a 3D translation, letting you move the current noise pattern in the X, Y, Z and W (4th dimention)" R 0 10}
 Freq_Offset {0 0 0 0}
 addUserKnob {6 Freq_Offset_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_GeneralScale l "Genral Scale" t "This lets you control the scale of each individual noise axis."}
 Freq_GeneralScale 1
 addUserKnob {6 Freq_GeneralScale_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq l "" +STARTLINE T " "}
 addUserKnob {19 Freq_EvolveLow l "Evolve Low" t "This lets you evolve (auto animate) the noise in a particular direction. The \"Low\" part means that this only affects the low frequencies.\n\nTo avoid a \"scrolling\" effect you can use the 4th dimention to break up the spatial cohearence." R 0 10}
 Freq_EvolveLow {0.7 0 0 0.5}
 addUserKnob {6 Freq_EvolveLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_EvolveHigh l "Evolve High" t "This lets you evolve (auto animate) the noise in a particular direction. The \"High\" part means that this only affects the high frequencies.\n\nTo avoid a \"scrolling\" effect you can use the 4th dimention to break up the spatial cohearence."}
 Freq_EvolveHigh {0 0 0 0}
 addUserKnob {6 Freq_EvolveHigh_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq2 l "" +STARTLINE T " "}
 addUserKnob {19 Freq_ScaleLow l "Scale Low" t "This lets you scale the noise in a particular axis. The \"Low\" part means that this only affects the low frequencies."}
 Freq_ScaleLow {1 1 1 1}
 addUserKnob {6 Freq_ScaleLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_ScaleHigh l "Scale High" t "This lets you scale the noise in a particular axis. The \"High\" part means that this only affects the high frequencies."}
 Freq_ScaleHigh {1 1 1 1}
 addUserKnob {6 Freq_ScaleHigh_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq3 l "" +STARTLINE T " "}
 addUserKnob {26 Curve l "<b><font color=#7DADF9>Curve Noise</font><b>"}
 addUserKnob {6 CurveNoise_Enable l Enable t "Adds a gamma curve to the noise intensity making noise near the \"Offset\" value more flat. This is a experimental feature." +STARTLINE}
 addUserKnob {6 CurveNoise_Invert l Invert t "Inverts the effect of the curved noise." -STARTLINE}
 addUserKnob {7 CurveGain l "Curve Gain" R -10 10}
 CurveGain 3
 addUserKnob {7 CurveOffset l "Curve Offset" R -2 2}
 addUserKnob {26 gabgen l "" +STARTLINE T "\n"}
 addUserKnob {26 info_mask l "<b><font color=#7DADF9>Mask</font><b>"}
 addUserKnob {41 maskChannelMask l "" t "If a node is connected to the mask input, this will let you mask off the effect of the noise.\nIts recommended that you use the Point_Texture node to ensure a correct aspect and size." -STARTLINE T Merge1.maskChannelMask}
 addUserKnob {41 inject -STARTLINE T Merge1.inject}
 addUserKnob {41 invert_mask l invert -STARTLINE T Merge1.invert_mask}
 addUserKnob {41 fringe -STARTLINE T Merge1.fringe}
 addUserKnob {41 mix T Merge1.mix}
}
 Input {
  inputs 0
  name InputMask
  xpos -714
  ypos 297
  number 1
 }
 Reformat {
  type "to box"
  box_width {{parent.InputFormat.box.r}}
  box_height {{parent.InputFormat.box.t}}
  box_fixed true
  resize distort
  name Reformat2
  xpos -714
  ypos 396
 }
 Shuffle {
  name Shuffle3
  xpos -714
  ypos 420
 }
 Input {
  inputs 0
  name InputOffset
  xpos -208
  ypos 61
  number 2
 }
 Dot {
  name Dot2
  xpos -174
  ypos 153
 }
 Input {
  inputs 0
  name InputData
  xpos -582
  ypos 73
 }
 Dot {
  name Dot1
  xpos -548
  ypos 114
 }
set N1c208240 [stack 0]
 Shuffle {
  in pos
  name Shuffle1
  xpos -470
  ypos 110
 }
set N1c20cd40 [stack 0]
 Multiply {
  value 0
  name Multiply1
  xpos -338
  ypos 106
 }
 Merge2 {
  inputs 2
  operation copy
  name Merge2
  xpos -338
  ypos 150
 }
push $N1c20cd40
 BlinkScript {
  inputs 2
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/Fractal_v08.cpp
  recompileCount 64
  ProgramGroup 1
  KernelDescription "2 \"Noise4D\" iterate pixelWise be1f493003df1b115acb2d181bf4caa997e214937eb46d4cd65a56edf3425cad 3 \"src\" Read Point \"modix\" Read Point \"dst\" Write Point 19 \"absNoise\" Bool 1 AA== \"curveNoise\" Bool 1 AA== \"curveInvert\" Bool 1 AA== \"radialNoise\" Bool 1 AA== \"curveGain\" Float 1 AACAPw== \"curveOffset\" Float 1 AACAPw== \"Octaves\" Int 1 CgAAAA== \"Gain\" Float 1 AAAAPw== \"Lacunarity\" Float 1 AAAAQA== \"Gamma\" Float 1 AAAAPw== \"amplitude\" Float 3 AAAAPwAAAD8AAAA/AAAAAA== \"itterations\" Int 1 AQAAAA== \"Offset\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Scale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"suboffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topoffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"subscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"center\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== 19 \"absNoise\" 1 1 \"curveNoise\" 1 1 \"curveInvert\" 1 1 \"radialNoise\" 1 1 \"curveGain\" 1 1 \"curveOffset\" 1 1 \"octaves\" 1 1 \"gain\" 1 1 \"lacunarity\" 1 1 \"gamma\" 1 1 \"amplitude\" 3 1 \"itterations\" 1 1 \"offset\" 4 1 \"scale\" 4 1 \"suboffset\" 4 1 \"topoffset\" 4 1 \"subscale\" 4 1 \"topscale\" 4 1 \"center\" 3 1 0"
  kernelSource "//Based on https://github.com/Draradech/csworldgen/blob/master/simplexnoise.cpp\n//Ported by Mads Hagbarth Lund 2014\n\n/* Copyright (c) 2007-2012 Eliot Eshelman\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n\nint fastfloor( const float x ) \{ return x > 0 ? (int) x : (int) x - 1; \}\ninline float raw_noise_4d( const float x, const float y, const float z, const float w ) \n\{\nint simplex\[64]\[4] = \{\n    \{0,1,2,3\},\{0,1,3,2\},\{0,0,0,0\},\{0,2,3,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,2,3,0\},\n    \{0,2,1,3\},\{0,0,0,0\},\{0,3,1,2\},\{0,3,2,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,3,2,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{1,2,0,3\},\{0,0,0,0\},\{1,3,0,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,3,0,1\},\{2,3,1,0\},\n    \{1,0,2,3\},\{1,0,3,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,0,3,1\},\{0,0,0,0\},\{2,1,3,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{2,0,1,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,0,1,2\},\{3,0,2,1\},\{0,0,0,0\},\{3,1,2,0\},\n    \{2,1,0,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,1,0,2\},\{0,0,0,0\},\{3,2,0,1\},\{3,2,1,0\}\n\};\n    int perm\[512] = \{\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n    \};\n   int grad4\[32]\[4]= \{\n    \{0,1,1,1\},  \{0,1,1,-1\},  \{0,1,-1,1\},  \{0,1,-1,-1\},\n    \{0,-1,1,1\}, \{0,-1,1,-1\}, \{0,-1,-1,1\}, \{0,-1,-1,-1\},\n    \{1,0,1,1\},  \{1,0,1,-1\},  \{1,0,-1,1\},  \{1,0,-1,-1\},\n    \{-1,0,1,1\}, \{-1,0,1,-1\}, \{-1,0,-1,1\}, \{-1,0,-1,-1\},\n    \{1,1,0,1\},  \{1,1,0,-1\},  \{1,-1,0,1\},  \{1,-1,0,-1\},\n    \{-1,1,0,1\}, \{-1,1,0,-1\}, \{-1,-1,0,1\}, \{-1,-1,0,-1\},\n    \{1,1,1,0\},  \{1,1,-1,0\},  \{1,-1,1,0\},  \{1,-1,-1,0\},\n    \{-1,1,1,0\}, \{-1,1,-1,0\}, \{-1,-1,1,0\}, \{-1,-1,-1,0\}\n   \};\n    float F4 = (sqrt(5.0f)-1.0f)/4.0f;\n    float G4 = (5.0f-sqrt(5.0f))/20.0f;\n    float n0, n1, n2, n3, n4;\n    float s = (x + y + z + w) * F4;\n    int i = fastfloor(x + s);\n    int j = fastfloor(y + s);\n    int k = fastfloor(z + s);\n    int l = fastfloor(w + s);\n    float t = (i + j + k + l) * G4;\n    float X0 = i - t;\n    float Y0 = j - t;\n    float Z0 = k - t;\n    float W0 = l - t;\n\n    float x0 = x - X0;\n    float y0 = y - Y0;\n    float z0 = z - Z0;\n    float w0 = w - W0;\n    int c1 = (x0 > y0) ? 32 : 0;\n    int c2 = (x0 > z0) ? 16 : 0;\n    int c3 = (y0 > z0) ? 8 : 0;\n    int c4 = (x0 > w0) ? 4 : 0;\n    int c5 = (y0 > w0) ? 2 : 0;\n    int c6 = (z0 > w0) ? 1 : 0;\n    int c = c1 + c2 + c3 + c4 + c5 + c6;\n\n    int i1, j1, k1, l1;\n    int i2, j2, k2, l2;\n    int i3, j3, k3, l3;\n    i1 = simplex\[c]\[0]>=3 ? 1 : 0;\n    j1 = simplex\[c]\[1]>=3 ? 1 : 0;\n    k1 = simplex\[c]\[2]>=3 ? 1 : 0;\n    l1 = simplex\[c]\[3]>=3 ? 1 : 0;\n    i2 = simplex\[c]\[0]>=2 ? 1 : 0;\n    j2 = simplex\[c]\[1]>=2 ? 1 : 0;\n    k2 = simplex\[c]\[2]>=2 ? 1 : 0;\n    l2 = simplex\[c]\[3]>=2 ? 1 : 0;\n    i3 = simplex\[c]\[0]>=1 ? 1 : 0;\n    j3 = simplex\[c]\[1]>=1 ? 1 : 0;\n    k3 = simplex\[c]\[2]>=1 ? 1 : 0;\n    l3 = simplex\[c]\[3]>=1 ? 1 : 0;\n    float x1 = x0 - i1 + G4;\n    float y1 = y0 - j1 + G4;\n    float z1 = z0 - k1 + G4;\n    float w1 = w0 - l1 + G4;\n    float x2 = x0 - i2 + 2.0*G4;\n    float y2 = y0 - j2 + 2.0*G4;\n    float z2 = z0 - k2 + 2.0*G4;\n    float w2 = w0 - l2 + 2.0*G4;\n    float x3 = x0 - i3 + 3.0*G4;\n    float y3 = y0 - j3 + 3.0*G4;\n    float z3 = z0 - k3 + 3.0*G4;\n    float w3 = w0 - l3 + 3.0*G4;\n    float x4 = x0 - 1.0 + 4.0*G4;\n    float y4 = y0 - 1.0 + 4.0*G4;\n    float z4 = z0 - 1.0 + 4.0*G4;\n    float w4 = w0 - 1.0 + 4.0*G4;\n    int ii = i & 255;\n    int jj = j & 255;\n    int kk = k & 255;\n    int ll = l & 255;\n    int gi0 = perm\[ii+perm\[jj+perm\[kk+perm\[ll]]]] % 32;\n    int gi1 = perm\[ii+i1+perm\[jj+j1+perm\[kk+k1+perm\[ll+l1]]]] % 32;\n    int gi2 = perm\[ii+i2+perm\[jj+j2+perm\[kk+k2+perm\[ll+l2]]]] % 32;\n    int gi3 = perm\[ii+i3+perm\[jj+j3+perm\[kk+k3+perm\[ll+l3]]]] % 32;\n    int gi4 = perm\[ii+1+perm\[jj+1+perm\[kk+1+perm\[ll+1]]]] % 32;\n    float t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;\n    if(t0<0) n0 = 0.0;\n    else \{\n        t0 *= t0;\n        n0 = t0 * t0 * dot(float4(grad4\[gi0]\[0],grad4\[gi0]\[2],grad4\[gi0]\[3],grad4\[gi0]\[3]), float4(x0, y0, z0, w0));\n    \}\n    float t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;\n    if(t1<0) n1 = 0.0;\n    else \{\n        t1 *= t1;\n        n1 = t1 * t1 * dot(float4(grad4\[gi1]\[0],grad4\[gi1]\[2],grad4\[gi1]\[3],grad4\[gi1]\[3]), float4(x1, y1, z1, w1));\n    \}\n    float t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;\n    if(t2<0) n2 = 0.0;\n    else \{\n        t2 *= t2;\n        n2 = t2 * t2 * dot(float4(grad4\[gi2]\[0],grad4\[gi2]\[2],grad4\[gi2]\[3],grad4\[gi2]\[3]), float4(x2, y2, z2, w2));\n    \}\n    float t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;\n    if(t3<0) n3 = 0.0;\n    else \{\n        t3 *= t3;\n        n3 = t3 * t3 * dot(float4(grad4\[gi3]\[0],grad4\[gi3]\[2],grad4\[gi3]\[3],grad4\[gi3]\[3]), float4(x3, y3, z3, w3));\n    \}\n    float t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;\n    if(t4<0) n4 = 0.0;\n    else \{\n        t4 *= t4;\n        n4 = t4 * t4 * dot(float4(grad4\[gi4]\[0],grad4\[gi4]\[2],grad4\[gi4]\[3],grad4\[gi4]\[3]), float4(x4, y4, z4, w4));\n    \}\n    return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\}\n\n\n\n\nkernel Noise4D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n    Image<eRead, eAccessPoint, eEdgeClamped> modix;\n  Image<eWrite, eAccessPoint> dst;\nparam:\n    bool absNoise;\n    bool curveNoise;\n    bool curveInvert;\n    bool radialNoise;\n    float curveGain;\n    float curveOffset;\n    int octaves;\n    float gain;\n    float lacunarity;\n    float gamma;\n    float3 amplitude;\n    int itterations;\n    float4 offset;\n    float4 scale;\n    float4 suboffset;\n    float4 topoffset;\n    float4 subscale;\n    float4 topscale;\n    float3 center;\n\n\n  void define() \{\n        defineParam (absNoise, \"absNoise\", false);    \n        defineParam (curveNoise, \"curveNoise\", false);    \n        defineParam (curveInvert, \"curveInvert\", false);   \n        defineParam (radialNoise, \"radialNoise\", false);   //Used for radial noise\n        defineParam (curveGain, \"curveGain\", 1.0f);\n        defineParam (curveOffset, \"curveOffset\", 1.0f);\n        defineParam (octaves, \"Octaves\", 10);\n        defineParam (gain, \"Gain\", 0.5f);\n        defineParam (lacunarity, \"Lacunarity\", 2.0f);\n        defineParam (gamma, \"Gamma\", 0.5f);\n        defineParam (amplitude, \"amplitude\", float3(0.5f));\n        defineParam (itterations, \"itterations\", 1);\n        defineParam(offset, \"Offset\", float4(0.0f, 0.0f, 0.0f,0.0f));\n        defineParam(scale, \"Scale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(suboffset, \"suboffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topoffset, \"topoffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(subscale, \"subscale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topscale, \"topscale\", float4(1.0f, 1.0f, 1.0f,1.0f));   \n        defineParam(center, \"center\", float3(0.0f,0.0f,0.0f));   //Center for the radial noise      \n  \}\n\nfloat4 sphericalTransform( const float4 cartesian) \n\{\n    return float4(\n(atan2(cartesian.x-center.x,cartesian.y-center.y)+ PI)/+ (PI*2.0f),\n(atan2(cartesian.x-center.x,cartesian.z-center.z)+ PI)/+ (PI*2.0f),\n(atan2(cartesian.z-center.z,cartesian.y-center.y)+ PI)/+ (PI*2.0f),\ncartesian.w\n);\n\}\n\nfloat octave_noise_4d( float4 modulix, const float octaves, const float persistence, const float scale, const float x, const float y, const float z, const float w ) \n\{\n    float total = 0.0f;\n    float current;\n    float last = 1.0f;\n    float frequency = scale;\n    float amplitude = 1.0f;\n    float maxAmplitude = 0.0f;\n    float4 Tempoffset;\n    float4 Tempscale;\n\n\n    for( int i=0; i < octaves; i++ ) \{\n\n        /*\n        if (i == 0) \{\n            total += (float)raw_noise_4d( (x+suboffset.x) * frequency, (y+suboffset.y) * frequency, (z+suboffset.z) * frequency, (w+suboffset.w) * frequency ) * amplitude;\n        \}\n        else if (i == octaves-1) \{\n            total += (float)raw_noise_4d( (x+topoffset.x) * frequency, (y+topoffset.y) * frequency, (z+topoffset.z) * frequency, (w+topoffset.w) * frequency ) * amplitude;\n        \}\n        else \{\n            total += (float)raw_noise_4d( x * frequency, y * frequency, z * frequency, w * frequency ) * amplitude;\n        \}\n        */\n\n\n        Tempscale = (topscale * (i/(octaves-1.0f)))+(subscale * (1-(i/(octaves-1.0f))));       \n        Tempoffset = ((topoffset+modulix.y) * (i/(octaves-1.0f)))+((suboffset+modulix.x) * (1-(i/(octaves-1.0f))));\n        current = (float)raw_noise_4d(   ((x*Tempscale.x)+Tempoffset.x) * frequency, \n                                        ((y*Tempscale.y)+Tempoffset.y) * frequency, \n                                        ((z*Tempscale.z)+Tempoffset.z) * frequency, \n                                        ((w*Tempscale.w)+Tempoffset.w) * frequency \n                                        ) * amplitude;\n        if (i == 0 && curveNoise)\{\n            if (curveInvert)\{\n                last = 0.5f-current;  \n            \}\n            else\{\n                last = current;  \n            \}\n               \n        \}\n        current = curveNoise?current*((last+curveOffset)*curveGain):current;\n        total += absNoise?fabs(current):current;\n        frequency *= 2.0f;\n        maxAmplitude += amplitude;\n        amplitude *= persistence;\n\n    \}\n    return float(total / maxAmplitude);\n\}\n\n\n\n\n  void process() \{\n    float4 srcSample = float4(src(0),src(1),src(2),src(3));\n    float4 srcSampleModix = modix();\n    float sampleR,sampleG,sampleB;\n    if (radialNoise)\{\n        srcSample = sphericalTransform(srcSample);\n    \}\n\n    for( int i=0; i < itterations; i++ ) \{\n        sampleR = (float)octave_noise_4d(srcSampleModix,float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w) * amplitude.x;\n        sampleG = (float)octave_noise_4d(srcSampleModix,float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w - 100.0f) * amplitude.y;\n        sampleB = (float)octave_noise_4d(srcSampleModix,float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w + 200.0f) * amplitude.z;\n        srcSample = float4(srcSample.x+sampleR,srcSample.y+sampleG,srcSample.z+sampleB,srcSample.w);\n    \}\n    dst() = float4(srcSample.x,srcSample.y,srcSample.z,1.0f);\n\}\n\};"
  rebuild ""
  Noise4D_curveNoise {{parent.CurveNoise_Enable}}
  Noise4D_curveInvert {{parent.CurveNoise_Invert}}
  Noise4D_curveGain {{parent.CurveGain}}
  Noise4D_curveOffset {{parent.CurveOffset}}
  Noise4D_Octaves {{parent.Noise_Octaves}}
  Noise4D_Gain {{parent.Noise_Gain}}
  Noise4D_Lacunarity {{parent.Noise_Lacunarity}}
  Noise4D_Gamma 0.79
  Noise4D_amplitude {{parent.Amplitude.r} {parent.Amplitude.g} {parent.Amplitude.b}}
  Noise4D_itterations {{parent.Itterations}}
  Noise4D_Offset {{parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset}}
  Noise4D_Scale {{parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale}}
  Noise4D_suboffset {{(frame*parent.Freq_EvolveLow.r)/50} {(frame*parent.Freq_EvolveLow.g)/50} {(frame*parent.Freq_EvolveLow.b)/50} {(frame*parent.Freq_EvolveLow.a)/50}}
  Noise4D_topoffset {{(frame*parent.Freq_EvolveHigh.r)/10} {(frame*parent.Freq_EvolveHigh.g)/10} {(frame*parent.Freq_EvolveHigh.b)/10} {(frame*parent.Freq_EvolveHigh.a)/10}}
  Noise4D_subscale {{parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow}}
  Noise4D_topscale {{parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh}}
  rebuild_finalise ""
  name Noise4D2
  xpos -338
  ypos 321
 }
push $N1c20cd40
 BlinkScript {
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/Fractal_v06.cpp
  recompileCount 60
  ProgramGroup 1
  KernelDescription "2 \"Noise4D\" iterate pixelWise d54284af3e5573ad197bef9032773e8653de2cad590694fcc9fd5af993e97da3 2 \"src\" Read Point \"dst\" Write Point 17 \"absNoise\" Bool 1 AA== \"curveNoise\" Bool 1 AA== \"curveInvert\" Bool 1 AA== \"curveGain\" Float 1 AACAPw== \"curveOffset\" Float 1 AACAPw== \"Octaves\" Int 1 CgAAAA== \"Gain\" Float 1 AAAAPw== \"Lacunarity\" Float 1 AAAAQA== \"Gamma\" Float 1 AAAAPw== \"amplitude\" Float 3 AAAAPwAAAD8AAAA/AAAAAA== \"itterations\" Int 1 AQAAAA== \"Offset\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Scale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"suboffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topoffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"subscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== 17 \"absNoise\" 1 1 \"curveNoise\" 1 1 \"curveInvert\" 1 1 \"curveGain\" 1 1 \"curveOffset\" 1 1 \"octaves\" 1 1 \"gain\" 1 1 \"lacunarity\" 1 1 \"gamma\" 1 1 \"amplitude\" 3 1 \"itterations\" 1 1 \"offset\" 4 1 \"scale\" 4 1 \"suboffset\" 4 1 \"topoffset\" 4 1 \"subscale\" 4 1 \"topscale\" 4 1 0"
  kernelSource "//Based on https://github.com/Draradech/csworldgen/blob/master/simplexnoise.cpp\n//Ported by Mads Hagbarth Lund 2014\n\n/* Copyright (c) 2007-2012 Eliot Eshelman\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n\nint fastfloor( const float x ) \{ return x > 0 ? (int) x : (int) x - 1; \}\ninline float raw_noise_4d( const float x, const float y, const float z, const float w ) \n\{\nint simplex\[64]\[4] = \{\n    \{0,1,2,3\},\{0,1,3,2\},\{0,0,0,0\},\{0,2,3,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,2,3,0\},\n    \{0,2,1,3\},\{0,0,0,0\},\{0,3,1,2\},\{0,3,2,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,3,2,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{1,2,0,3\},\{0,0,0,0\},\{1,3,0,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,3,0,1\},\{2,3,1,0\},\n    \{1,0,2,3\},\{1,0,3,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,0,3,1\},\{0,0,0,0\},\{2,1,3,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{2,0,1,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,0,1,2\},\{3,0,2,1\},\{0,0,0,0\},\{3,1,2,0\},\n    \{2,1,0,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,1,0,2\},\{0,0,0,0\},\{3,2,0,1\},\{3,2,1,0\}\n\};\n    int perm\[512] = \{\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n    \};\n   int grad4\[32]\[4]= \{\n    \{0,1,1,1\},  \{0,1,1,-1\},  \{0,1,-1,1\},  \{0,1,-1,-1\},\n    \{0,-1,1,1\}, \{0,-1,1,-1\}, \{0,-1,-1,1\}, \{0,-1,-1,-1\},\n    \{1,0,1,1\},  \{1,0,1,-1\},  \{1,0,-1,1\},  \{1,0,-1,-1\},\n    \{-1,0,1,1\}, \{-1,0,1,-1\}, \{-1,0,-1,1\}, \{-1,0,-1,-1\},\n    \{1,1,0,1\},  \{1,1,0,-1\},  \{1,-1,0,1\},  \{1,-1,0,-1\},\n    \{-1,1,0,1\}, \{-1,1,0,-1\}, \{-1,-1,0,1\}, \{-1,-1,0,-1\},\n    \{1,1,1,0\},  \{1,1,-1,0\},  \{1,-1,1,0\},  \{1,-1,-1,0\},\n    \{-1,1,1,0\}, \{-1,1,-1,0\}, \{-1,-1,1,0\}, \{-1,-1,-1,0\}\n   \};\n    float F4 = (sqrt(5.0f)-1.0f)/4.0f;\n    float G4 = (5.0f-sqrt(5.0f))/20.0f;\n    float n0, n1, n2, n3, n4;\n    float s = (x + y + z + w) * F4;\n    int i = fastfloor(x + s);\n    int j = fastfloor(y + s);\n    int k = fastfloor(z + s);\n    int l = fastfloor(w + s);\n    float t = (i + j + k + l) * G4;\n    float X0 = i - t;\n    float Y0 = j - t;\n    float Z0 = k - t;\n    float W0 = l - t;\n\n    float x0 = x - X0;\n    float y0 = y - Y0;\n    float z0 = z - Z0;\n    float w0 = w - W0;\n    int c1 = (x0 > y0) ? 32 : 0;\n    int c2 = (x0 > z0) ? 16 : 0;\n    int c3 = (y0 > z0) ? 8 : 0;\n    int c4 = (x0 > w0) ? 4 : 0;\n    int c5 = (y0 > w0) ? 2 : 0;\n    int c6 = (z0 > w0) ? 1 : 0;\n    int c = c1 + c2 + c3 + c4 + c5 + c6;\n\n    int i1, j1, k1, l1;\n    int i2, j2, k2, l2;\n    int i3, j3, k3, l3;\n    i1 = simplex\[c]\[0]>=3 ? 1 : 0;\n    j1 = simplex\[c]\[1]>=3 ? 1 : 0;\n    k1 = simplex\[c]\[2]>=3 ? 1 : 0;\n    l1 = simplex\[c]\[3]>=3 ? 1 : 0;\n    i2 = simplex\[c]\[0]>=2 ? 1 : 0;\n    j2 = simplex\[c]\[1]>=2 ? 1 : 0;\n    k2 = simplex\[c]\[2]>=2 ? 1 : 0;\n    l2 = simplex\[c]\[3]>=2 ? 1 : 0;\n    i3 = simplex\[c]\[0]>=1 ? 1 : 0;\n    j3 = simplex\[c]\[1]>=1 ? 1 : 0;\n    k3 = simplex\[c]\[2]>=1 ? 1 : 0;\n    l3 = simplex\[c]\[3]>=1 ? 1 : 0;\n    float x1 = x0 - i1 + G4;\n    float y1 = y0 - j1 + G4;\n    float z1 = z0 - k1 + G4;\n    float w1 = w0 - l1 + G4;\n    float x2 = x0 - i2 + 2.0*G4;\n    float y2 = y0 - j2 + 2.0*G4;\n    float z2 = z0 - k2 + 2.0*G4;\n    float w2 = w0 - l2 + 2.0*G4;\n    float x3 = x0 - i3 + 3.0*G4;\n    float y3 = y0 - j3 + 3.0*G4;\n    float z3 = z0 - k3 + 3.0*G4;\n    float w3 = w0 - l3 + 3.0*G4;\n    float x4 = x0 - 1.0 + 4.0*G4;\n    float y4 = y0 - 1.0 + 4.0*G4;\n    float z4 = z0 - 1.0 + 4.0*G4;\n    float w4 = w0 - 1.0 + 4.0*G4;\n    int ii = i & 255;\n    int jj = j & 255;\n    int kk = k & 255;\n    int ll = l & 255;\n    int gi0 = perm\[ii+perm\[jj+perm\[kk+perm\[ll]]]] % 32;\n    int gi1 = perm\[ii+i1+perm\[jj+j1+perm\[kk+k1+perm\[ll+l1]]]] % 32;\n    int gi2 = perm\[ii+i2+perm\[jj+j2+perm\[kk+k2+perm\[ll+l2]]]] % 32;\n    int gi3 = perm\[ii+i3+perm\[jj+j3+perm\[kk+k3+perm\[ll+l3]]]] % 32;\n    int gi4 = perm\[ii+1+perm\[jj+1+perm\[kk+1+perm\[ll+1]]]] % 32;\n    float t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;\n    if(t0<0) n0 = 0.0;\n    else \{\n        t0 *= t0;\n        n0 = t0 * t0 * dot(float4(grad4\[gi0]\[0],grad4\[gi0]\[2],grad4\[gi0]\[3],grad4\[gi0]\[3]), float4(x0, y0, z0, w0));\n    \}\n    float t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;\n    if(t1<0) n1 = 0.0;\n    else \{\n        t1 *= t1;\n        n1 = t1 * t1 * dot(float4(grad4\[gi1]\[0],grad4\[gi1]\[2],grad4\[gi1]\[3],grad4\[gi1]\[3]), float4(x1, y1, z1, w1));\n    \}\n    float t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;\n    if(t2<0) n2 = 0.0;\n    else \{\n        t2 *= t2;\n        n2 = t2 * t2 * dot(float4(grad4\[gi2]\[0],grad4\[gi2]\[2],grad4\[gi2]\[3],grad4\[gi2]\[3]), float4(x2, y2, z2, w2));\n    \}\n    float t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;\n    if(t3<0) n3 = 0.0;\n    else \{\n        t3 *= t3;\n        n3 = t3 * t3 * dot(float4(grad4\[gi3]\[0],grad4\[gi3]\[2],grad4\[gi3]\[3],grad4\[gi3]\[3]), float4(x3, y3, z3, w3));\n    \}\n    float t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;\n    if(t4<0) n4 = 0.0;\n    else \{\n        t4 *= t4;\n        n4 = t4 * t4 * dot(float4(grad4\[gi4]\[0],grad4\[gi4]\[2],grad4\[gi4]\[3],grad4\[gi4]\[3]), float4(x4, y4, z4, w4));\n    \}\n    return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\}\n\n\n\n\nkernel Noise4D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite, eAccessPoint> dst;\nparam:\n    bool absNoise;\n    bool curveNoise;\n    bool curveInvert;\n    float curveGain;\n    float curveOffset;\n    int octaves;\n    float gain;\n    float lacunarity;\n    float gamma;\n    float3 amplitude;\n    int itterations;\n    float4 offset;\n    float4 scale;\n    float4 suboffset;\n    float4 topoffset;\n    float4 subscale;\n    float4 topscale;\n\n\n  void define() \{\n        defineParam (absNoise, \"absNoise\", false);    \n        defineParam (curveNoise, \"curveNoise\", false);    \n        defineParam (curveInvert, \"curveInvert\", false);   \n        defineParam (curveGain, \"curveGain\", 1.0f);\n        defineParam (curveOffset, \"curveOffset\", 1.0f);\n        defineParam (octaves, \"Octaves\", 10);\n        defineParam (gain, \"Gain\", 0.5f);\n        defineParam (lacunarity, \"Lacunarity\", 2.0f);\n        defineParam (gamma, \"Gamma\", 0.5f);\n        defineParam (amplitude, \"amplitude\", float3(0.5f));\n        defineParam (itterations, \"itterations\", 1);\n        defineParam(offset, \"Offset\", float4(0.0f, 0.0f, 0.0f,0.0f));\n        defineParam(scale, \"Scale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(suboffset, \"suboffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topoffset, \"topoffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(subscale, \"subscale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topscale, \"topscale\", float4(1.0f, 1.0f, 1.0f,1.0f));        \n  \}\n\nfloat octave_noise_4d( const float octaves, const float persistence, const float scale, const float x, const float y, const float z, const float w ) \n\{\n    float total = 0.0f;\n    float current;\n    float last = 1.0f;\n    float frequency = scale;\n    float amplitude = 1.0f;\n    float maxAmplitude = 0.0f;\n    float4 Tempoffset;\n    float4 Tempscale;\n\n\n    for( int i=0; i < octaves; i++ ) \{\n\n        /*\n        if (i == 0) \{\n            total += (float)raw_noise_4d( (x+suboffset.x) * frequency, (y+suboffset.y) * frequency, (z+suboffset.z) * frequency, (w+suboffset.w) * frequency ) * amplitude;\n        \}\n        else if (i == octaves-1) \{\n            total += (float)raw_noise_4d( (x+topoffset.x) * frequency, (y+topoffset.y) * frequency, (z+topoffset.z) * frequency, (w+topoffset.w) * frequency ) * amplitude;\n        \}\n        else \{\n            total += (float)raw_noise_4d( x * frequency, y * frequency, z * frequency, w * frequency ) * amplitude;\n        \}\n        */\n\n\n        Tempscale = (topscale * (i/(octaves-1.0f)))+(subscale * (1-(i/(octaves-1.0f))));       \n        Tempoffset = (topoffset * (i/(octaves-1.0f)))+(suboffset * (1-(i/(octaves-1.0f))));\n        current = (float)raw_noise_4d(   ((x*Tempscale.x)+Tempoffset.x) * frequency, \n                                        ((y*Tempscale.y)+Tempoffset.y) * frequency, \n                                        ((z*Tempscale.z)+Tempoffset.z) * frequency, \n                                        ((w*Tempscale.w)+Tempoffset.w) * frequency \n                                        ) * amplitude;\n        if (i == 0 && curveNoise)\{\n            if (curveInvert)\{\n                last = 0.5f-current;  \n            \}\n            else\{\n                last = current;  \n            \}\n               \n        \}\n        current = curveNoise?current*((last+curveOffset)*curveGain):current;\n        total += absNoise?fabs(current):current;\n        frequency *= 2.0f;\n        maxAmplitude += amplitude;\n        amplitude *= persistence;\n\n    \}\n    return float(total / maxAmplitude);\n\}\n\n\n\n\n  void process() \{\n    float4 srcSample = float4(src(0),src(1),src(2),src(3));\n    float sampleR,sampleG,sampleB;\n    for( int i=0; i < itterations; i++ ) \{\n        sampleR = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w) * amplitude.x;\n        sampleG = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w - 100.0f) * amplitude.y;\n        sampleB = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w + 200.0f) * amplitude.z;\n        srcSample = float4(srcSample.x+sampleR,srcSample.y+sampleG,srcSample.z+sampleB,srcSample.w);\n    \}\n    dst() = float4(srcSample.x,srcSample.y,srcSample.z,1.0f);\n\}\n\};"
  rebuild ""
  Noise4D_curveNoise {{parent.CurveNoise_Enable}}
  Noise4D_curveInvert {{parent.CurveNoise_Invert}}
  Noise4D_curveGain {{parent.CurveGain}}
  Noise4D_curveOffset {{parent.CurveOffset}}
  Noise4D_Octaves {{parent.Noise_Octaves}}
  Noise4D_Gain {{parent.Noise_Gain}}
  Noise4D_Lacunarity {{parent.Noise_Lacunarity}}
  Noise4D_Gamma 0.79
  Noise4D_amplitude {{parent.Amplitude.r} {parent.Amplitude.g} {parent.Amplitude.b}}
  Noise4D_itterations {{parent.Itterations}}
  Noise4D_Offset {{parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset}}
  Noise4D_Scale {{parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale}}
  Noise4D_suboffset {{(frame*parent.Freq_EvolveLow.r)/50} {(frame*parent.Freq_EvolveLow.g)/50} {(frame*parent.Freq_EvolveLow.b)/50} {(frame*parent.Freq_EvolveLow.a)/50}}
  Noise4D_topoffset {{(frame*parent.Freq_EvolveHigh.r)/10} {(frame*parent.Freq_EvolveHigh.g)/10} {(frame*parent.Freq_EvolveHigh.b)/10} {(frame*parent.Freq_EvolveHigh.a)/10}}
  Noise4D_subscale {{parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow}}
  Noise4D_topscale {{parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh}}
  rebuild_finalise ""
  name Noise4D1
  xpos -470
  ypos 267
 }
 Switch {
  inputs 2
  which {{parent.EnableOffset}}
  name Switch1
  xpos -470
  ypos 325
 }
 Expression {
  expr0 abs(r)
  expr1 abs(g)
  expr2 abs(b)
  name Expression2
  xpos -470
  ypos 349
  disable {{!parent.Noise_Absolute}}
 }
 Shuffle {
  out pos
  name Shuffle2
  xpos -470
  ypos 420
 }
push $N1c208240
 Merge2 {
  inputs 2+1
  operation copy
  bbox B
  Achannels {pos.red pos.green pos.blue -pos.alpha}
  Bchannels {pos.red pos.green pos.blue -pos.alpha}
  output {pos.red pos.green pos.blue -pos.alpha}
  maskChannelMask -rgba.alpha
  name Merge1
  xpos -582
  ypos 416
 }
 Output {
  name Output1
  xpos -582
  ypos 587
 }
push $N1c208240
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -713
  ypos 111
 }
 StickyNote {
  inputs 0
  name StickyNote1
  label "These two noise scripts are alsmost identical.\nThe problem is that adding 1 extra input does eat up a lot of performence,\nso when we don't need the input we should avoid using it."
  xpos -239
  ypos 269
 }
end_group
Group {
 name Point_FractalMask
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 xpos 7709
 ypos -1655
 disable true
 addUserKnob {20 User}
 addUserKnob {26 info l "" +STARTLINE T "Point Fractal Mask v1.0\n\nThis node generates a fractal mask that can be used to reveal the object."}
 addUserKnob {26 DeviderGeneral l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {41 distance l "Masking Offset" T Expression2.distance}
 addUserKnob {41 select_axis l "Masking Axis" T Expression2.select_axis}
 addUserKnob {4 _mode l Mode -STARTLINE M {Normal "Normal (abs)" "Hard Edge" "Hard Edge (abs)" "" "" "" "" ""}}
 _mode "Hard Edge"
 addUserKnob {41 _invert l Invert -STARTLINE T Expression2._invert}
 addUserKnob {41 position l "Radial Center" T Expression1.position}
 addUserKnob {26 devider_fractal l "<b><font color=#7DADF9>Fractal</font><b>"}
 addUserKnob {41 _rnd_mag l "Fractal Expansion" T Expression2._rnd_mag}
 addUserKnob {41 _rnd_scale l "Fractal Scale" -STARTLINE T Expression2._rnd_scale}
 addUserKnob {41 _rnd_axis l INVISIBLE +INVISIBLE T Expression2._rnd_axis}
 addUserKnob {26 devider_subsettings l "" +STARTLINE T " "}
 addUserKnob {13 noise_offset l Offset}
 addUserKnob {3 Octaves}
 Octaves 10
 addUserKnob {7 Lacunarity R 0 10}
 Lacunarity 1.9
 addUserKnob {7 noise_gain l Gain}
 noise_gain 0.5
}
 BackdropNode {
  inputs 0
  name BackdropNode3
  tile_color 0x388e8e00
  label Offset
  note_font_size 42
  xpos -648
  ypos 316
  bdwidth 224
  bdheight 161
 }
 Input {
  inputs 0
  name Input1
  xpos -580
  ypos 50
 }
 Shuffle {
  in pos
  name Shuffle5
  xpos -580
  ypos 120
 }
 Dot {
  name Dot7
  xpos -546
  ypos 242
 }
 Expression {
  temp_name0 xd
  temp_expr0 r-position.x
  temp_name1 yd
  temp_expr1 g-position.y
  temp_name2 zd
  temp_expr2 b-position.z
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr3 Distance
  name Expression1
  xpos -580
  ypos 292
  addUserKnob {20 User}
  addUserKnob {13 position}
 }
 Expression {
  temp_name0 value
  temp_expr0 select_axis==0?r:select_axis==1?g:select_axis==2?b:a
  temp_name1 rnd
  temp_expr1 _rnd_axis==0?random(r*_rnd_scale)*_rnd_mag:_rnd_axis==1?random(g*_rnd_scale)*_rnd_mag:_rnd_axis==2?random(b*_rnd_scale)*_rnd_mag:fBm(r*_rnd_scale+parent.noise_offset.x,g*_rnd_scale+parent.noise_offset.y,b*_rnd_scale+parent.noise_offset.z,parent.Octaves,parent.Lacunarity,parent.noise_gain)*_rnd_mag
  temp_name3 _distance
  temp_expr3 distance+(rnd)
  expr3 _invert?(-(value-_distance)):((value-_distance))
  name Expression2
  xpos -580
  ypos 355
  addUserKnob {20 User}
  addUserKnob {4 select_axis M {X Y Z Radial}}
  select_axis Radial
  addUserKnob {7 distance R -10 10}
  distance 1
  addUserKnob {6 _invert +STARTLINE}
  addUserKnob {7 _rnd_mag R 0 10}
  _rnd_mag 0.3
  addUserKnob {7 _rnd_scale R 0 10}
  _rnd_scale 2
  addUserKnob {4 _rnd_axis M {X Y Z Radial ""}}
  _rnd_axis Radial
 }
 Expression {
  expr0 _mode==0?max(0,a):_mode==1?abs(a):_mode==2?max(0,1/a):max(0,1/abs(a))
  name Expression3
  selected true
  xpos -580
  ypos 398
  addUserKnob {20 User}
  addUserKnob {3 _mode}
  _mode {{parent._mode}}
 }
 Shuffle {
  green red
  blue red
  alpha red
  name Shuffle1
  xpos -580
  ypos 446
 }
 Dot {
  name Dot8
  xpos -546
  ypos 530
 }
 Output {
  name Output1
  xpos -580
  ypos 686
 }
end_group
Group {
 inputs 2
 name Point_Render6
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 xpos 7709
 ypos -1567
 addUserKnob {20 User l "Point Render" t dd}
 addUserKnob {26 info_header l "" +STARTLINE T "Point Render v1.2"}
 addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {4 RenderMode l "Render Mode" t "Some generators support multiple render modes other than just point rendering. This should be considered a experimental feature, but can be used to great effect.\n\nIn the Render Settings tab you can find more controls relating to Wire and Facet rendering modes.\n\nNote that Facet Render can be slow when really close to a object. " M {"Point Render" "Wire Render" "Facet Render (experimental)" "" "" ""}}
 addUserKnob {7 FocalLength l "Focal Length" t "The point render does not take the focal length from the input camera, so if you want to match it to a camera you should link the focal length from the camera to this." +INVISIBLE R 0 200}
 FocalLength 40
 addUserKnob {7 horizontalApeture l "Horiz Apeture" +INVISIBLE R 0 100}
 horizontalApeture 24.576
 addUserKnob {14 overscan l Overscan R 0 100}
 addUserKnob {7 AlphaMultiplier l Exposure t "This is a general exposure modifier that lets you adjust the overall brightness of the render." R 0 2}
 AlphaMultiplier 3
 addUserKnob {6 OutputZdepth l "Output Z-depth" t "Will output a Z-depth channel. This will cause reduced rendering performence." +STARTLINE}
 addUserKnob {6 UseOcclusionMap l "Use Occlusion Map" t "Enable the Occlusion map input. This lets you use a depth map as a holdout.\n\nNote:\nThe Red channal should contain the depth (absolute distance, not 1/depth)\nThe Alpha channal must be 1 for the areas that you want to holdout." +STARTLINE}
 addUserKnob {4 occ_method l "" t "Real Depth - input RGB should be the distance to the camera, and A should be the alpha (White occlude, Black ingore).\n\n1/depth.z (Scanline Render) - Will use the depth.Z channal from the scanline render and convert to real depth internally. Alpha is still required." -STARTLINE M {"Real Depth" "1/depth.z (Scanline Render)" ""}}
 occ_method "1/depth.z (Scanline Render)"
 addUserKnob {26 devider_cc l "<b><font color=#7DADF9>Preview</font><b>"}
 addUserKnob {6 FastPreview l "Fast Preview" t "Reduce the number of points for a quick preview of the final render." +STARTLINE}
 addUserKnob {6 HighlightCompression l "Hilight Compression" t "Compresses the highlights to make it easier to see bright details." +STARTLINE}
 addUserKnob {7 HighlightCeiling l "Highlight Ceiling" t "Adjust the cealing for the highlight compression." R 1 10}
 HighlightCeiling 1.15
 addUserKnob {7 Compression t "The compression amount." -STARTLINE R 0 5}
 Compression 1
 addUserKnob {26 devider_format l "<b><font color=#7DADF9>Format</font><b>"}
 addUserKnob {41 format l "output format" T Settings_Format.format}
 addUserKnob {20 WireRender l "Render Settings"}
 addUserKnob {26 devider_wirerender l "<b><font color=#7DADF9>Wire Rendering</font><b>"}
 addUserKnob {4 wire_type l "Connection Mode" t "*Normal\nConnect lines between the local neigbours of the 2d position map\n\n*Nearest\nConnect lines to the nearest points (in 3D space). This mode is limited to 100x100 points for performence reasons!" M {Normal Nearest "" "" "" "" "" "" "" ""}}
 addUserKnob {26 text l "Normal Mode Wires" T " "}
 addUserKnob {6 connect_x l x t "Connect wires in the (uv) X axis." -STARTLINE}
 connect_x true
 addUserKnob {6 connect_xy l xy t "Connect wires in the (uv) XY axis." -STARTLINE}
 connect_xy true
 addUserKnob {6 connect_y l y t "Connect wires in the (uv) Y axis." -STARTLINE}
 connect_y true
 addUserKnob {6 connect_aux l aux t "If you input a vector map into the Aux input for this node, and enable this option, you will get a wire from each point along that vector." -STARTLINE}
 addUserKnob {7 wire_maxdistance l "Max Distance" t "The maximum distance that the wires connect." R 0 10}
 wire_maxdistance 6
 addUserKnob {7 wire_Threshold l "Distance Threshold" t "Control the max distance threshold" R 0 2}
 wire_Threshold 0.5
 addUserKnob {3 wire_connections l "Max Connections" t "The maximum number of connections (Not Yet Implemented)"}
 wire_connections 4
 addUserKnob {7 maxSamples l "Max Line Samples" t "The maximum length of a line. Once a line is longer than this, it will start break up. \nThis can also be used as a creative effect if you set it low, try setting it to 10 in wire mode to get dotted lines" R 0 10000}
 maxSamples 10000
 addUserKnob {7 lineoffset l "Line Offset" t "Expand or contract the lines."}
 lineoffset 1
 addUserKnob {7 inGain l "In Gain" t "Gain the brightness of the in-point of the lines"}
 inGain 1
 addUserKnob {7 outGain l "Out Gain" t "Gain the brightness of the out-point of the lines" -STARTLINE}
 outGain 1
 addUserKnob {26 devider_facet l "<b><font color=#7DADF9>Facet Rendering</font><b>"}
 addUserKnob {4 renderMode l "Render Mode" t "Pick the desidered render mode." M {Diffuse "Local ST" Normal "Facing Ratio" UV ST "View Normal" "World Position" "" ""}}
 addUserKnob {6 facet_flatShading l "Flat Shading" t "Flat shading" +STARTLINE}
 addUserKnob {6 facet_depth l "Depth Buffer" t "Enable depth sorting to avoid additive surfaces." -STARTLINE}
 addUserKnob {6 facet_front l "Front Face" t "Render front facing facets" +STARTLINE}
 facet_front true
 addUserKnob {6 facet_backface l "Back Face" t "Render backfacing faces" -STARTLINE}
 facet_backface true
 addUserKnob {26 _1 l "<b><font color=#7DADF9>Other</font><b>"}
 addUserKnob {6 CloseX l "Close X" t "On spheres or round objects this closes the loop" +STARTLINE}
 addUserKnob {6 CloseY l "Close Y" t "On spheres or round objects this closes the loop" -STARTLINE}
 addUserKnob {20 Fog_1 l Fog}
 addUserKnob {26 Devider_Fog l "<b><font color=#7DADF9>Fog</font><b>"}
 addUserKnob {6 Fog t "Fog reduces the brightness of poins far from the camera." +STARTLINE}
 Fog true
 addUserKnob {7 FogNear l "Fog Near" R 0 200}
 FogNear 7
 addUserKnob {7 FogFar l "Fog Far" R 0 200}
 FogFar 10
 addUserKnob {7 FogExponent l "Fog Exponent" R 0 8}
 FogExponent 7
 addUserKnob {20 DepthOfField l "Depth of Field"}
 addUserKnob {26 devider_dof l "<b><font color=#7DADF9>Depth Of Field</font><b>"}
 addUserKnob {6 dof_enable l Enable +STARTLINE}
 addUserKnob {7 dof_focaldepth l "Focal Depth" R 0 40}
 dof_focaldepth 24.1
 addUserKnob {7 dof_dof l "Depth of Field" R 0 10}
 dof_dof 1
 addUserKnob {7 dof_maxSize l "Max Size"}
 dof_maxSize 0.6
 addUserKnob {7 dof_Aspect l "Aspect Ratio"}
 dof_Aspect 1
 addUserKnob {7 dof_bias l Bias R -3 3}
 dof_bias -0.2
 addUserKnob {4 Dof_Quality l Quality M {Low Medium High Extreme}}
 addUserKnob {20 MotionBlur}
 addUserKnob {26 devider_MotionBlur l "<b><font color=#7DADF9>Motion Blur</font><b>"}
 addUserKnob {6 mb_enable l Enable +STARTLINE}
 mb_enable true
 addUserKnob {6 Fast l "Fast (Interpolated)" -STARTLINE}
 Fast true
 addUserKnob {3 Samples}
 Samples 60
 addUserKnob {7 Shutter R 0 2}
 Shutter 30
 addUserKnob {4 pulldown l "Shutter Offset" M {Centered Start End ""}}
 addUserKnob {20 preview_3d l "3D Preview"}
 addUserKnob {6 Enable3DPreview l "Enable 3D Preview" t "Display a preview of the points in the Nuke 3D view." +STARTLINE}
 addUserKnob {41 pointSize l "point size" T PreviewNode.pointSize}
 addUserKnob {41 detail l "point detail" T PreviewNode.detail}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x388e8e00
  label "Output Format Manager"
  note_font_size 22
  xpos -1079
  ypos 117
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode10
  tile_color 0x388e8e00
  label "AUX Input"
  note_font_size 22
  xpos -385
  ypos 178
  bdwidth 207
  bdheight 178
 }
 BackdropNode {
  inputs 0
  name BackdropNode11
  tile_color 0x388e8e00
  label "Point Render"
  note_font_size 22
  xpos -96
  ypos 99
  bdwidth 203
  bdheight 131
 }
 BackdropNode {
  inputs 0
  name BackdropNode12
  tile_color 0x388e8e00
  label "Normal Generator\nFor Vertex Normals"
  note_font_size 22
  xpos -616
  ypos 243
  bdwidth 191
  bdheight 122
 }
 BackdropNode {
  inputs 0
  name BackdropNode13
  tile_color 0x388e8e00
  label "Ensure output format"
  note_font_size 22
  xpos -622
  ypos -41
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode14
  tile_color 0x388e8e00
  label "Motion Blur"
  note_font_size 22
  xpos -85
  ypos 255
  bdwidth 264
  bdheight 96
 }
 BackdropNode {
  inputs 0
  name BackdropNode15
  tile_color 0x388e8e00
  label "Soft Preview"
  note_font_size 22
  xpos -83
  ypos 601
  bdwidth 191
  bdheight 94
 }
 BackdropNode {
  inputs 0
  name BackdropNode16
  tile_color 0x388e8e00
  label "Final format"
  note_font_size 22
  xpos -84
  ypos 482
  bdwidth 192
  bdheight 95
 }
 BackdropNode {
  inputs 0
  name BackdropNode17
  tile_color 0x388e8e00
  label "No Clue =)"
  note_font_size 22
  xpos -385
  ypos -41
  bdwidth 160
  bdheight 87
 }
 BackdropNode {
  inputs 0
  name BackdropNode18
  tile_color 0x388e8e00
  label "Z-Depth Shuffle"
  note_font_size 22
  xpos -85
  ypos 367
  bdwidth 264
  bdheight 96
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0x388e8e00
  label Motionblur
  note_font_size 22
  xpos -672
  ypos -781
  bdwidth 258
  bdheight 246
 }
 BackdropNode {
  inputs 0
  name BackdropNode3
  tile_color 0x388e8e00
  label "Fast Preview"
  note_font_size 22
  xpos -669
  ypos -971
  bdwidth 254
  bdheight 138
 }
 BackdropNode {
  inputs 0
  name BackdropNode4
  tile_color 0x388e8e00
  label "Nearest Wire Mode Clamp"
  note_font_size 22
  xpos -666
  ypos -1184
  bdwidth 253
  bdheight 111
 }
 BackdropNode {
  inputs 0
  name BackdropNode5
  tile_color 0x388e8e00
  label Occlusion
  note_font_size 22
  xpos 208
  ypos 27
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode6
  tile_color 0x388e8e00
  label "Input Camera Container"
  note_font_size 22
  xpos -1357
  ypos 121
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode7
  tile_color 0x388e8e00
  label "3D Preview"
  note_font_size 22
  xpos -88
  ypos -45
  bdwidth 207
  bdheight 102
 }
 BackdropNode {
  inputs 0
  name BackdropNode8
  tile_color 0x388e8e00
  label "Input Format Manager"
  note_font_size 22
  xpos -526
  ypos -459
  bdwidth 208
  bdheight 97
 }
 BackdropNode {
  inputs 0
  name BackdropNode9
  tile_color 0x388e8e00
  label FOG
  note_font_size 22
  xpos -602
  ypos -253
  bdwidth 370
  bdheight 152
 }
 Input {
  inputs 0
  name InputPointData
  xpos -584
  ypos -1321
 }
 Dot {
  name Dot4
  xpos -550
  ypos -1234
 }
set N1c3dbcc0 [stack 0]
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize fill
  filter Impulse
  black_outside true
  name Reformat5
  xpos -584
  ypos -906
  disable {{!parent.FastPreview==1}}
 }
 Grade {
  white 10
  name Grade2
  xpos -584
  ypos -874
  disable {{!parent.FastPreview}}
 }
 Dot {
  name Dot2
  xpos -550
  ypos -712
 }
set N1c400300 [stack 0]
 Group {
  name FrameHold3
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -501
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame+1}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot6
  xpos -467
  ypos -659
 }
set N1c4202e0 [stack 0]
push $N1c400300
 Group {
  name FrameHold2
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -660
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot5
  xpos -626
  ypos -659
 }
set N1c440150 [stack 0]
 Dissolve {
  inputs 2
  which {{frame-floor(frame)}}
  name Dissolve1
  xpos -582
  ypos -666
  disable {{1-parent.mb_enable}}
 }
set N1c444cb0 [stack 0]
push $N1c400300
 Switch {
  inputs 2
  which {{parent.Fast}}
  name Switch2
  xpos -584
  ypos -567
 }
 Dot {
  name DataFetch
  label "data fetch\t"
  note_font_color 0xff21ff
  xpos -550
  ypos -513
  addUserKnob {20 User}
  addUserKnob {3 n_particles l "Number of Particles"}
  addUserKnob {3 gentype l "Type Of Generator"}
  addUserKnob {26 info l "" -STARTLINE T "0 = unknown, 1 = Card, 2 = Sphere, 3 = Grid"}
 }
set N1c458060 [stack 0]
 Dot {
  name Dot3
  xpos -635
  ypos -513
 }
 Dot {
  name Dot1
  xpos -635
  ypos 863
 }
 Reformat {
  inputs 0
  format "1920 1080 0 0 1920 1080 1 HD_1080"
  resize distort
  center false
  black_outside true
  name Settings_Format
  xpos -992
  ypos 209
 }
 AdjBBox {
  numpixels {{parent.overscan} {parent.overscan}}
  name AdjBBox2
  xpos -992
  ypos 241
 }
 Input {
  inputs 0
  name InputOcclusion
  xpos 238
  ypos 75
  number 2
 }
 Expression {
  expr0 depth.Z>0?1/depth.Z:0
  name Expression2
  xpos 238
  ypos 104
  disable {{!parent.occ_method}}
 }
 Constant {
  inputs 0
  channels rgb
  color 1
  format {{{parent.Settings_Format.format}}}
  name Empty
  xpos 371
  ypos 139
 }
 Switch {
  inputs 2
  which {{parent.UseOcclusionMap}}
  name Switch1
  xpos 238
  ypos 163
 }
 AdjBBox {
  numpixels {{parent.overscan} {parent.overscan}}
  name AdjBBox1
  xpos 118
  ypos 163
 }
set N1c4a1ab0 [stack 0]
 Input {
  inputs 0
  name Aux
  xpos -324
  ypos 214
  number 3
 }
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter Impulse
  black_outside true
  name Reformat2
  xpos -324
  ypos 238
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop1
  xpos -324
  ypos 462
 }
push $N1c458060
 Shuffle {
  in pos
  name Shuffle1
  xpos -584
  ypos -192
 }
set N1c4c8540 [stack 0]
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter Impulse
  black_outside true
  name Reformat4
  xpos -584
  ypos 18
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop2
  xpos -584
  ypos 48
 }
 Dot {
  name Dot8
  xpos -550
  ypos 166
 }
set N1c4f27d0 [stack 0]
 Group {
  name Point_Normal2
  tile_color 0x434343ff
  note_font_color 0x55ffffff
  xpos -584
  ypos 498
  disable {{!(renderMode==2&&RenderMode==2)}}
  addUserKnob {20 User}
  addUserKnob {26 info l "" +STARTLINE T "Point Normal v1.0"}
  addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
  addUserKnob {26 info_1 l "" +STARTLINE T "well, not much to do here =)"}
 }
  Input {
   inputs 0
   name Input1
   xpos 389
   ypos 207
  }
  Shuffle {
   in pos
   name Shuffle1
   xpos 389
   ypos 294
  }
  BlinkScript {
   kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/BasicLight.cpp
   recompileCount 69
   ProgramGroup 1
   KernelDescription "2 \"PointRender3D\" iterate pixelWise d5452fe7b684561fcfa5182d0c789025a037cc4fe4474c24e065e3fa53fcd8ce 2 \"ppos\" Read Random \"dst\" Write Point 9 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"Zoom\" Float 1 AACAPw== \"half Lambert\" Bool 1 AQ== \"light Mode\" Int 1 AAAAAA== \"light_position\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"light_color\" Float 3 AACAPwAAgD8AAIA/AAAAAA== 9 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"zoom\" 1 1 \"halfLambert\" 1 1 \"lightMode\" 1 1 \"lightPos\" 3 1 \"lightcolor\" 3 1 10 \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"namount\" Float 1 1 AAAAAA=="
   kernelSource "inline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}\n\ninline float saturate(float _in)\n\{\n    return max(0.0f,min(1.0f,_in));\n\}\n\ninline float3 reflect(float3 incidence,float3 normal)\n\{\n  return incidence - 2.f * dot(incidence, normal) * normal;\n\}\n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n    \n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    if (fabs(pScreen.x) > canvasWidth || fabs(pScreen.y) > canvasHeight) \n         return false; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eWrite> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    bool halfLambert;\n    int lightMode;\n    float3 lightPos;\n    float3 lightcolor;\n\n\n  local: //Local variables\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n    float namount; //dither amount\n\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(halfLambert, \"half Lambert\", true);\n    defineParam(lightMode, \"light Mode\", 0);\n    defineParam(lightPos,      \"light_position\", float3(0,0,0));  \n    defineParam(lightcolor,      \"light_color\", float3(1.0,1.0,1.0)); \n  \}\n\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n    namount = 0.0001; //dither amount\n  \}\n\n\n\nfloat3 Reconsile3D(float3 _PointPos)\{\n    vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n    int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    return tRaster;\n\}\n\n\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nfloat3 facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos;\n    float4 V0_Sample,V1_Sample,V2_Sample;\n    float3 normal0,normal1,normal2;\n\n    //for area calculation\n    float area;\n    float3 V0,V1,V2;\n    float3 output = float3(0.0f);\n  if (insideX) \{\n    V2_Sample = ppos(pos.x+1,pos.y);\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(pos.x+1,pos.y-1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n            float3 Normal = CalculateVertexNormals(_vWorld,V2_wPos,V1_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          //write output\n          output +=  float3(Normal.x,Normal.y,Normal.z);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,pos.y+1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n          float3 Normal = CalculateVertexNormals(_vWorld,V1_wPos,V2_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          output += float3(Normal.x,Normal.y,Normal.z);\n\n        \}\n      \}\n    \}\n  \}\n  return output;\n\}\n\n\n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 hitNormal = cross((V1 - V0),(V2 - V0)); \n        return hitNormal;\n\}\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float3 output = float3(0.0f);\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float3 point_pos = float3(_sample.x,_sample.y,_sample.z);\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n      dst() = float4(0.0f);\n      output+=facet_render(pos,float3(_sample.x,_sample.y,_sample.z))*2.0f;\n      _sample = ppos(pos.x-1,pos.y); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x-1,pos.y+1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y+1),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x,pos.y-1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x,pos.y-1),float3(_sample.x,_sample.y,_sample.z));\n\n      output = normalize(output);\n      float3 normal = -output;\n\n      \n\n\n      dst() = float4(normal.x,normal.y,normal.z,1.0f);\n    \}\n  \} //----> process\n\};\n"
   rebuild ""
   "PointRender3D_half Lambert" false
   PointRender3D_light_position {{parent.Axis1.translate} {parent.Axis1.translate} {parent.Axis1.translate}}
   PointRender3D_light_color {0 0 0}
   rebuild_finalise ""
   name BlinkScript1
   xpos 389
   ypos 344
  }
  Grade {
   multiply 0.5
   add 0.5
   black_clamp false
   name Grade1
   xpos 389
   ypos 376
   disable true
  }
  Output {
   name Output1
   xpos 389
   ypos 459
  }
  Axis2 {
   inputs 0
   translate {0.5 0.5 0.5}
   name Axis1
   xpos 661
   ypos 318
   addUserKnob {20 Ivy}
   addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
   addUserKnob {26 divider4 l "" +STARTLINE}
   addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
   _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
   addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
   addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
   addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
   _expressions {{curve}}
   addUserKnob {26 divider0 l "" +STARTLINE}
   addUserKnob {20 dbinfo l "DB Info" n 1}
   dbinfo 0
   addUserKnob {1 twig_dnuuid l "Twig Id"}
   addUserKnob {1 stalk_dnuuid l "Stalk Id"}
   addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
   addUserKnob {1 leaf_dnuuid l "Leaf Id"}
   addUserKnob {26 divider1 l "" +STARTLINE}
   addUserKnob {1 twigtype l "Twig Type"}
   addUserKnob {1 leaf_label l Leaf}
   addUserKnob {1 ivy_version l Version}
   addUserKnob {43 ivy_notes l Notes}
   addUserKnob {26 divider2 l "" +STARTLINE}
   addUserKnob {1 build_label l "Build Label"}
   addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
  }
 end_group
 Switch {
  inputs 2
  which {{parent.connect_aux}}
  name Switch3
  xpos -324
  ypos 498
 }
set N1c569c90 [stack 0]
push $N1c4c8540
 Expression {
  temp_name0 xd
  temp_expr0 red-Camera1.world_matrix.3
  temp_name1 yd
  temp_expr1 green-Camera1.world_matrix.7
  temp_name2 zd
  temp_expr2 blue-Camera1.world_matrix.11
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  expr3 Distance
  name Expression1
  xpos -456
  ypos -192
 }
 Grade {
  channels rgba
  blackpoint {{parent.FogFar}}
  whitepoint {{parent.FogNear}}
  gamma {{1/(parent.FogExponent+0.000000001)}}
  white_clamp true
  name Grade1
  xpos -456
  ypos -168
 }
push $N1c458060
 Dot {
  name Dot7
  xpos -307
  ypos -513
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge1
  xpos -341
  ypos -168
  disable {{!parent.Fog}}
 }
 Shuffle {
  name Shuffle3
  xpos -341
  ypos 8
 }
set N1c5a6110 [stack 0]
 Shuffle {
  red white
  green white
  blue white
  name Shuffle2
  xpos -28
  ypos 76
 }
push $N1c4f27d0
 BlinkScript {
  inputs 4
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Render/3D_PointRender_v18.cpp
  recompileCount 806
  ProgramGroup 1
  KernelDescription "2 \"PointRender3D\" iterate pixelWise b6c79b641c58390f32c944e2b5792a8702107f9cfc926636430288e7e0e1b392 5 \"ppos\" Read Random \"src\" Read Random \"normals\" Read Random \"occlusion\" Read Random \"dst\" Write Random 50 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"vertexformat\" Int 2 CgAAAAoAAAA= \"Zoom\" Float 1 AACAPw== \"Filtering Method\" Int 1 AQAAAA== \"_alphaMultiplier\" Float 1 AACAPw== \"_pointRender\" Bool 1 AQ== \"_wireRender\" Bool 1 AQ== \"_facetRender\" Bool 1 AQ== \"_maxLDistance\" Float 1 AACAPw== \"_maxLConnections\" Int 1 AQAAAA== \"_maxPlexType\" Int 1 AAAAAA== \"_plexLinedefXY\" Bool 1 AA== \"_plexLinedefX\" Bool 1 AA== \"_plexLinedefY\" Bool 1 AA== \"_plexLinedefXtoY\" Bool 1 AA== \"_plexLinedefAUX\" Bool 1 AA== \"_plexConnectX\" Bool 1 AA== \"_plexConnectY\" Bool 1 AA== \"_L_gamma\" Float 1 AACAPw== \"Enable Depth of Field\" Bool 1 AA== \"samples\" Int 1 AwAAAA== \"rings\" Int 1 BQAAAA== \"focalDepth\" Float 1 AACAPw== \"_depthOfField\" Float 1 AACAQA== \"_depthMult\" Float 1 zczMPQ== \"_maxDofSize\" Float 1 AAAAQQ== \"dof_aspect\" Float 1 AACAPw== \"dof_threshold\" Float 1 AACAPw== \"dof_gain\" Float 1 AAAAAA== \"dof_bias\" Float 1 AAAAwA== \"dof_fringe\" Float 1 AAAAAA== \"_flatshading\" Bool 1 AQ== \"_backfacing\" Bool 1 AQ== \"_frontfacing\" Bool 1 AQ== \"_vertexMode\" Int 1 AAAAAA== \"_depthBuffer\" Bool 1 AQ== \"_texoffset\" Float 2 AAAAPwAAAD8= \"_pointSize\" Int 1 AQAAAA== \"_gaussigma\" Float 1 AACAPw== \"_depthOcclusion\" Bool 1 AQ== \"depthMultiplier\" Float 1 AACAPw== \"_maxLineSteps\" Float 1 AAB6RQ== \"_lineOffset\" Float 1 AACAPw== \"_lineInMultiplier\" Float 1 AACAPw== \"_lineOutMultiplier\" Float 1 AACAPw== \"_overscan\" Float 2 AAAAAAAAAAA= \"isDepth\" Bool 1 AA== 50 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"Vformat\" 2 1 \"zoom\" 1 1 \"_filtering\" 1 1 \"_alphaMultiplier\" 1 1 \"_pointRender\" 1 1 \"_wireRender\" 1 1 \"_facetRender\" 1 1 \"_maxPlexDistance\" 1 1 \"_maxPlexConnections\" 1 1 \"_maxPlexType\" 1 1 \"_plexLinedefXY\" 1 1 \"_plexLinedefX\" 1 1 \"_plexLinedefY\" 1 1 \"_plexLinedefXtoY\" 1 1 \"_plexLinedefAUX\" 1 1 \"_plexConnectX\" 1 1 \"_plexConnectY\" 1 1 \"_plex_gamma\" 1 1 \"_dof_enable\" 1 1 \"_dof_samples\" 1 1 \"_dof_rings\" 1 1 \"focalDepth\" 1 1 \"_depthOfField\" 1 1 \"_depthMult\" 1 1 \"_maxDofSize\" 1 1 \"dof_aspect\" 1 1 \"dof_threshold\" 1 1 \"dof_gain\" 1 1 \"dof_bias\" 1 1 \"dof_fringe\" 1 1 \"_flatshading\" 1 1 \"_backfacing\" 1 1 \"_frontfacing\" 1 1 \"_vertexMode\" 1 1 \"_depthBuffer\" 1 1 \"_texoffset\" 2 1 \"_pointSize\" 1 1 \"_gaussigma\" 1 1 \"_depthOcclusion\" 1 1 \"depthMultiplier\" 1 1 \"_maxLineSteps\" 1 1 \"_lineOffset\" 1 1 \"_lineInMultiplier\" 1 1 \"_lineOutMultiplier\" 1 1 \"_overscan\" 2 1 \"isDepth\" 1 1 10 \"max_line_connections\" Int 1 1 AAAAAA== \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "//Some basic generic functions.\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float3 Cross(float3 A,float3 B)\n\{\n    return float3(A.y*B.z - A.z*B.y,A.z*B.x - A.x*B.z,A.x*B.y - A.y*B.x);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}     \n\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\ninline float mix(float _X,float _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}                                                                                              \n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n\n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight,\n    float2 overscan\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f-overscan.x || pRaster.x > imageWidth+overscan.x || \n       pRaster.y < 0.0f-overscan.y || pRaster.y > imageHeight+overscan.y || pRaster.z < 0.0f) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eRead, eAccessRandom, eEdgeClamped> src;     //The texture map\n  Image<eRead, eAccessRandom, eEdgeClamped> normals;     //The texture map  \n  Image<eRead, eAccessRandom, eEdgeClamped> occlusion;     //The texture map \n  Image<eWrite, eAccessRandom> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat,Vformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    int _filtering;        //Filter method\n    float _alphaMultiplier; //Additive multiplier\n    bool _pointRender,_wireRender,_facetRender;\n    float _maxPlexDistance; //Additive multiplier\n    int _maxPlexConnections;\n    int _maxPlexType; // 0==Grid, -1==Nearest\n    bool _plexLinedefXY,_plexLinedefX,_plexLinedefY,_plexLinedefXtoY,_plexLinedefAUX; // Define what connections NOT to include\n    bool _plexConnectX,_plexConnectY; //Connect from the edge of x to 0, or edge of y to 0, usually for spheres\n    float _plex_gamma; //The threshold making shorter paths bright and longer paths dark\n    bool _dof_enable; // Enable DOF\n    int _dof_samples; // How many samples per DOF ring\n    int _dof_rings; // How many rings \n    float focalDepth,_depthOfField,_depthMult,_maxDofSize; //DOF Settings\n    float dof_aspect; //Pixel aspect ratio\n    float dof_threshold;\n    float dof_gain;\n    float dof_bias; //bokeh edge bias\n    float dof_fringe; //bokeh chromatic aberration/fringing\n    bool _flatshading,_backfacing,_frontfacing; //Vertex rendering settings\n    int _vertexMode;  //The rendering output mode, (think AOV)\n    bool _depthBuffer; //Non-additive, only render front most pixel\n    float2 _texoffset;\n    int _pointSize;\n    float _gaussigma;\n    bool _depthOcclusion;\n    float depthMultiplier;\n    float _maxLineSteps; //cap the line length to avoid process lock\n    float _lineOffset; //Alow you to shrink or extend the lines\n    float _lineInMultiplier,_lineOutMultiplier; //Control the brightness of the wires at the tips.\n    float2 _overscan; //This will allow you to render some extra outside the bounds of the image.\n    bool isDepth; //This will allow you to render some extra outside the bounds of the image.\n\n  local: //Local variables\n    int max_line_connections;\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(Vformat,      \"vertexformat\", int2(10,10));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(_filtering, \"Filtering Method\", 1); \n    defineParam(_alphaMultiplier, \"_alphaMultiplier\", 1.0f);     \n    defineParam(_pointRender, \"_pointRender\", true);  \n    defineParam(_wireRender, \"_wireRender\", true);\n    defineParam(_facetRender, \"_facetRender\", true);\n    defineParam(_maxPlexDistance, \"_maxLDistance\", 1.0f);    \n    defineParam(_maxPlexConnections, \"_maxLConnections\", 1);    \n    defineParam(_maxPlexType, \"_maxPlexType\", 0); \n    defineParam(_plexLinedefXY, \"_plexLinedefXY\", false);      \n    defineParam(_plexLinedefXtoY, \"_plexLinedefXtoY\", false); //NYI\n    defineParam(_plexLinedefAUX, \"_plexLinedefAUX\", false); \n    defineParam(_plexLinedefX, \"_plexLinedefX\", false);  \n    defineParam(_plexLinedefY, \"_plexLinedefY\", false);  \n    defineParam(_plexConnectX, \"_plexConnectX\", false);      \n    defineParam(_plexConnectY, \"_plexConnectY\", false);   \n    defineParam(_plex_gamma, \"_L_gamma\", 1.0f);\n    //DOF SETTINGS   \n    defineParam(_dof_enable, \"Enable Depth of Field\", false);   \n    defineParam(_dof_samples, \"samples\", 3);    \n    defineParam(_dof_rings, \"rings\", 5);   \n    defineParam(focalDepth, \"focalDepth\", 1.0f);  \n    defineParam(_depthOfField, \"_depthOfField\", 4.0f);  \n    defineParam(_depthMult, \"_depthMult\", 0.1f);  \n    defineParam(_maxDofSize, \"_maxDofSize\", 8.0f);  \n    defineParam(dof_aspect, \"dof_aspect\", 1.0f);  \n    defineParam(dof_threshold, \"dof_threshold\", 1.0f);  \n    defineParam(dof_gain, \"dof_gain\", 0.0f);  \n    defineParam(dof_bias, \"dof_bias\", -2.0f);  \n    defineParam(dof_fringe, \"dof_fringe\", 0.0f); \n    //SHADING SETTINGS \n    defineParam(_flatshading, \"_flatshading\", true);  \n    defineParam(_vertexMode, \"_vertexMode\", 0);  \n    defineParam(_backfacing, \"_backfacing\", true);    \n    defineParam(_frontfacing, \"_frontfacing\", true);        \n    defineParam(_depthBuffer, \"_depthBuffer\", true);  \n    defineParam(_texoffset, \"_texoffset\", float2(0.5f,0.5f)); \n    defineParam(_pointSize, \"_pointSize\", 1); \n    defineParam(_gaussigma, \"_gaussigma\", 1.0f); \n    defineParam(_depthOcclusion, \"_depthOcclusion\", true); \n    defineParam(depthMultiplier, \"depthMultiplier\", 1.0f); \n    defineParam(_maxLineSteps, \"_maxLineSteps\", 4000.0f); \n    defineParam(_lineOffset, \"_lineOffset\", 1.0f); \n    defineParam(_lineInMultiplier, \"_lineInMultiplier\", 1.0f);   \n    defineParam(_lineOutMultiplier, \"_lineOutMultiplier\", 1.0f);     \n    defineParam(_overscan, \"_overscan\",float2(0.0f,0.0f));    \n\n  \}\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    max_line_connections = 80;\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n  \}\n\n  //Convert a 3d point position into a 2d raster position.\n  float3 Reconsile3D(float3 _PointPos)\{\n      vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      return tRaster;\n  \}\n\n//------------------------------\n//-------DRAW FUNCTIONS---------\n//------------------------------\n  //Write pixels to output.\n  void writepixel(float posx,float posy, float4 color,int index,float weight=1.0f)\n  \{ \n      if (_depthOcclusion)\{\n        float4 depthSample = occlusion(posx,posy);\n        if (depthSample.x<=vRaster.z && depthSample.w>0.0f)\{\n\n          float depth = (vRaster.z-depthSample.x);\n          color = color*(1.0f-depthSample.w);\n          color = color / (((depth*depth)*depthMultiplier)+1.0f);\n          //return;\n        \}\n      \}\n      float4 finalOutput; //This is used to store the final output\n      float4 dstSample; //This is used to store a sample of the destination\n      if ( dst.bounds.inside( posx, posy ) ) \{ //Test if the pixel written to is inside the output image. \n        if (_depthBuffer) \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          if ((dstSample.w>color.w)||dstSample.w==0.0f) \{\n            dst(posx,posy) = color;\n          \}\n        \}\n        else \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          finalOutput = dstSample + (color*_alphaMultiplier*weight);\n          finalOutput.w = dstSample.w + ((color.w*_alphaMultiplier*weight));\n\n          finalOutput.w = (dstSample.w + ((color.w*_alphaMultiplier*weight)))-(dstSample.w * ((color.w*_alphaMultiplier*weight)));\n\n          dst(posx,posy) = finalOutput;\n        \}\n      \} \n  \}\n\n  //Calculate a Bilinear Plot\n  void bilinear_Plot(float2 temppos,float4 color,int index)\n  \{\n    float2 p;\n    p.x=Frac(temppos.x);\n    p.y=Frac(temppos.y);\n    float weights\[] = \{(1.0f-p.x)*(1.0f-p.y), p.x*(1.0f-p.y), (1.0f-p.x)*p.y, p.x*p.y\};\n    int2 _position = int2(floor(temppos.x)-0,floor(temppos.y)-0); \n    writepixel(_position.x,_position.y,color,index,weights\[0]);\n    writepixel(_position.x+1,_position.y,color,index,weights\[1]);\n    writepixel(_position.x,_position.y+1,color,index,weights\[2]);\n    writepixel(_position.x+1,_position.y+1,color,index,weights\[3]);\n  \}\n\n  //NYI, unused!\n  void gaussian(float2 temppos,float4 color,int index)\{\n    float in_x = temppos.x;\n    float in_y = temppos.y;\n    int kernelSize = (_pointSize+1)*2;\n    int subsize = (kernelSize /2)-1;\n    float gKernel\[64]\[64];\n    float sigma = _gaussigma;\n    float intSigma = float(_pointSize);\n    float r, s = intSigma * sigma * sigma;\n\n    float sum = 0.0f;\n\n    // generate 5x5 kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            r = float(sqrt(x*x + y*y));\n            gKernel\[x + subsize]\[y + subsize] = (exp(-(r*r)/s))/(3.141592654f * s);\n            sum += gKernel\[x + subsize]\[y + subsize];\n        \}\n    \}\n\n    // normalize the Kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            gKernel\[x + subsize]\[y + subsize] /= sum;\n            writepixel(in_x+x,in_y+y,color,index,gKernel\[x + subsize]\[y + subsize]);\n        \}\n    \}\n  \}\n\n//-------------------------------------\n// DrawLine\n// ----------\n// Draw a line between two points, \n// x,y being 2d screenspace pos and z being depth.\n//-------------------------------------\n  void DrawLine(float3 origin, float3 endpoint,float4 _colorA,float4 _colorB) \{\n    float4 _color;\n    float3 delta = origin-endpoint;\n    float3 curPoint = origin;\n    float mag = sqrt(delta.x*delta.x+delta.y*delta.y);\n    mag = min(mag,_maxLineSteps); //Lets not go crazy, we cap it at 10.000 to avoid insane unwated processing time \n    for( float a = 0; a < mag*_lineOffset; a = a + 1.0f )\{\n      curPoint -= (delta/mag);\n      _color = (_colorA*(1.0f-(a/mag*1.0f)))+(_colorB*(a/mag*1.00f));\n      if (_dof_enable)\{\n        Bokeh(curPoint,_color);\n      \}\n      else \{\n        if (_depthBuffer && isDepth) \{_color = float4(1.0f,1.0f,1.0f,curPoint.z);\} //Added\n        bilinear_Plot(float2(curPoint.x,curPoint.y),_color,1);\n      \}\n      \n    \}\n  \}\n\n//-------------------------------------\n// Point_Render\n//-------------------------------------\nvoid point_render(int2 pos, float3 screen_pos)\{\n  float4 color = src(pos.x,pos.y);\n\n  if (_filtering == 1)\{\n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        if (_depthBuffer) \{color.w = screen_pos.z;\} //Added\n        bilinear_Plot(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  /*\n  //THIS PART NEEDS TO BE RE-WRITTEN.\n  else if (_filtering == 2)\{ \n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        gaussian(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  */\n  else \{\n      int2 _position = int2(floor(screen_pos.x),floor(screen_pos.y)); \n      if (_depthBuffer) \{color.w = screen_pos.z;\}\n      writepixel(_position.x,_position.y, color,1,1.0f); //OutputSample\n  \}\n\n\}\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nvoid facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x+1,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos,V0_N,V1_N,V2_N;\n    float2 V0_ST,V1_ST,V2_ST;\n    float4 V1_Sample,V2_Sample;\n    float4 _tn;\n    float3 normal0,normal1,normal2;\n    float2 UV_Format = float2(Vformat.x,Vformat.y);\n\n\n    int2 P0 = int2(pos.x-1,pos.y-1);\n    int2 P1 = int2(pos.x+1,pos.y+1);\n    if (_plexConnectX && pos.x == int(Vformat.x))\{\n      insideX == true;\n      P1 = int2(0.0f,pos.y+1);\n    \}\n    if (_plexConnectY && pos.y == int(Vformat.y))\{\n      insideYtop == true;\n      P1 = int2(pos.x+1,0);\n    \} \n\n    if (_plexConnectY && pos.y == 0)\{\n      insideY == true;\n      P0 = int2(pos.x-1,int(UV_Format.y));\n    \} \n\n    if (!_flatshading) \{\n      _tn = normals(pos.x,pos.y);\n      V0_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n    V0_ST = float2(pos.x,pos.y)/UV_Format;\n\n  if (insideX) \{\n    V2_Sample = ppos(P1.x,pos.y);\n    V2_ST = float2(P1.x,pos.y)/UV_Format;\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (!_flatshading) \{\n      _tn = normals(P1.x,pos.y);\n      V2_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n        \n\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(P1.x,P0.y);\n        V1_ST = float2(P1.x,P0.y)/UV_Format;\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(P1.x,P0.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}\n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V2_Pos,V1_Pos,_vWorld,V2_wPos,V1_wPos,V0_N,V2_N,V1_N,V0_ST,V2_ST,V1_ST);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,P1.y);\n        V1_ST = float2(pos.x,P1.y)/UV_Format;        \n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(pos.x,P1.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}        \n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V1_Pos,V2_Pos,_vWorld,V1_wPos,V2_wPos,V0_N,V1_N,V2_N,V0_ST,V1_ST,V2_ST);\n        \}\n      \}\n    \}\n  \}\n\}\n\n\n\n//This function will calculate if pixel C is inside the triangle\nfloat edgeFunction(float3 a, float3 b, float3 c) \n\{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n\} \n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat Distance(float3 _a,float3 _b)\n\{\n          float xd = _a.x - _b.x;\n          float yd = _a.y - _b.y;\n          float zd = _a.z - _b.z;\n          return sqrt(xd*xd + yd*yd + zd*zd);\n\}\n\nvoid DrawTriangle(float3 V0, float3 V1, float3 V2,float3 WP0, float3 WP1, float3 WP2,float3 N0, float3 N1, float3 N2, float2 st0,float2 st1,float2 st2) \{\n\n  // Precompute reciprocal of vertex z-coordinate \n  V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n\n  float2 st0n = st0 * V0.z;\n  float2 st1n = st1 * V1.z; \n  float2 st2n = st2 * V2.z; //Normal version of ST\n\n  bool inside; \n  float X0 = Fmin(V0.x,V1.x,V2.x)-1.0f;\n  float X1 = Fmax(V0.x,V1.x,V2.x)+1.0f;\n  float Y0 = Fmin(V0.y,V1.y,V2.y)-1.0f;\n  float Y1 = Fmax(V0.y,V1.y,V2.y)+1.0f;\n  float area = edgeFunction(V2, V1, V0);\n\n\n  float2 sampos = float2(st0.x*float(Vformat.x),st0.y*float(Vformat.y));\n  float4 text0 = src(sampos.x,sampos.y);\n  sampos = float2(st1.x*float(Vformat.x),st1.y*float(Vformat.y));\n  float4 text1 = src(sampos.x,sampos.y);\n  sampos = float2(st2.x*float(Vformat.x),st2.y*float(Vformat.y));  //Why do we have to do this? =(\n  float4 text2 = src(sampos.x,sampos.y);\n  sampos = float2(min(min(st0.x,st1.x),st2.x)*float(Vformat.x),min(min(st0.y,st1.y),st2.y)*float(Vformat.y));\n  float4 text3 = src(sampos.x,sampos.y);\n\n\n  for( int x = X0; x < X1 ; x++) \{\n    for( int y = Y0; y < Y1 ; y++) \{\n      float3 pixelSample(x + _texoffset.x, y + _texoffset.y,0.0f); \n\n      //This is the part where we test if the current pixel is inside the triangle\n      //We check both for front facing and back faing options\n      float w0 = edgeFunction(V1, V0, pixelSample); //Front Facing\n      float w1 = edgeFunction(V2, V1, pixelSample); \n      float w2 = edgeFunction(V0, V2, pixelSample); \n      float w3 = edgeFunction(V0, V1, pixelSample); //Back Facing\n      float w4 = edgeFunction(V1, V2, pixelSample); \n      float w5 = edgeFunction(V2, V0, pixelSample);\n\n      //writepixel(x,y, float4(w1),1,1.0f);\n      if ((w0 >= 0 && w1 >= 0 && w2 >= 0 && _frontfacing) || (w3 >= 0 && w4 >= 0 && w5 >= 0 && _backfacing)) \{ //The curent pixel is inside the triangle\n\n       // calculate vectors from point f to vertices p1, p2 and p3:\n       float3 f1 = V0-pixelSample;\n       float3 f2 = V1-pixelSample;\n       float3 f3 = V2-pixelSample;\n       // calculate the areas and factors (order of parameters doesn't matter):\n       float a = length(cross(V0-V1,V0-V2 )); // main triangle area a\n       area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n        w0 /= area; \n        w1 /= area; \n        w2 /= area; \n\n        w3 /= area; \n        w4 /= area; \n        w5 /= area; \n\n       float a1 = length(cross(f2, f3)) / a; // p1's triangle area / a\n       float a2 = length(cross(f3, f1)) / a; // p2's triangle area / a \n       float a3 = length(cross(f1, f2)) / a; // p3's triangle area / a\n       float a_magnitude = a1+a2+a3;\n       a1 = a1/a_magnitude;\n       a2 = a2/a_magnitude;\n       a3 = a3/a_magnitude;\n       float z = 1.0f / (V0.z * a1 + V1.z * a2 + V2.z * a3); \n\n\n        // find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):\n        float2 uv = st0 * a1 + st1 * a2 + st2 * a3;\n        float2 st = st0 * w0 + st1 * w1 + st2 * w2; \n        st *= z;      \n\n\n        //Calculate normals. Eighter we have flat shading, else we calculate a normal per pixel\n        float3 normalB;\n        if (_flatshading) \{\n          normalB = CalculateSurfaceNormals(WP0,WP1,WP2);\n\n        \}\n        else \{\n          float3 c0 = N2/float3(V0.z); \n          float3 c1 = N0/float3(V1.z); \n          float3 c2 = N1/float3(V2.z);  \n\n          normalB.x = w0 * c0.x + w1 * c1.x + w2 * c2.x; \n          normalB.y = w0 * c0.y + w1 * c1.y + w2 * c2.y; \n          normalB.z = w0 * c0.z + w1 * c1.z + w2 * c2.z; \n\n          normalB.x *= z, normalB.y *= z, normalB.z *= z; \n        \}\n        normalB = normalize(normalB);\n\n        //CALCULATE THE OBJECT TEXTURE COORDINATES\n        float zn = 1.0f / (V0.z * w0 + V1.z * w1 + V2.z * w2); \n        st = st0n * w0 + st1n * w1 + st2n * w2; \n        st *= zn;   \n        //--END \n\n        float3 Wpos = WP0*a1 + WP1*a2 + WP2*a3; //World Position.\n        float3 ViewNormal = normalize(float3(cameraToWorld\[3]\[0],cameraToWorld\[3]\[1],cameraToWorld\[3]\[2])-Wpos);\n\n        float nDotView =  dot(normalB,ViewNormal);\n        nDotView = 1.0f-fabs(nDotView); //make sure that the view normal ramps back around when doing backface\n        float4 tempout;\n\n        //Flatshading or regular?\n        if (!_flatshading) \{\n          tempout = text0 * a1 + text1 * a2 + text2 * a3; \n        \}\n        else\{\n          tempout = text3;\n        \}\n\n        //Additional Render Modes\n        if (_vertexMode == 1)\{\n          tempout = float4(a1,a2,a3,1.0f);\n        \}\n        else if (_vertexMode == 2)\{\n          tempout = float4(normalB.x,normalB.y,normalB.z,1.0f);\n        \}\n        else if (_vertexMode == 3)\{\n          tempout = float4(nDotView,nDotView,nDotView,1.0f);\n        \}\n        else if (_vertexMode == 4)\{\n          tempout = float4(uv.x,uv.y,0.0f,1.0f);\n        \}       \n        else if (_vertexMode == 5)\{\n          tempout = float4(st.x,st.y,0.0f,1.0f);\n        \}               \n        else if (_vertexMode == 6)\{\n          tempout = float4(ViewNormal.x,ViewNormal.y,ViewNormal.z,1.0f);\n        \}             \n        else if (_vertexMode == 7)\{\n          tempout = float4(Wpos.x,Wpos.y,Wpos.z,1.0f);\n        \}   \n\n        if (_depthBuffer)\{\n          writepixel(x,y, float4(tempout.x,tempout.y,tempout.z,z),1,1.0f);  \n        \}\n        else \{\n          if (_dof_enable)\{\n            Bokeh(float3(x,y,z),float4(tempout.x,tempout.y,tempout.z,z));\n          \}\n          else \{\n            bilinear_Plot(float2(x,y),float4(tempout.x,tempout.y,tempout.z,z),1);\n          \}\n        \}\n\n      \}  \n\n    \}\n  \}\n\}\n\n//-------------------------------------\n// Wire_Render\n//-------------------------------------\nvoid wire_render(int2 pos) \{\n  float4 temp = float4(0.0f,0.0f,0.0f,FLT_MAX);\n  float4 wire_ref_sample;\n  int2 tempXY = int2(0,0);\n  float4 plexlist\[11] = \{temp,temp,temp,temp,temp,temp,temp,temp,temp,temp,temp\}; \n  int2 plexlistXY\[11] = \{tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY\};\n  int plex_count = 0; //We use this to figure how many points that should connect.\n  float plex_dist;\n  float3 plex_position,plex_position_b;\n  float4 temp_pos, temp_pos_b; //Temporary Position Containers\n  if (_maxPlexType == -1) \{ //Used for random connection types\n    for( int x = 0; x < max_line_connections ; x++)\{ //THIS 80 NUMBER IS THE LIMIT TO AVOID TOO SLOW PROCESSING!\n      for( int y = 0; y < max_line_connections ; y++)\{\n        wire_ref_sample = ppos(x,y);\n        if (wire_ref_sample.w != 0.0f && pos.x!=x && pos.y != y) \{ \n          plex_position = float3(wire_ref_sample.x,wire_ref_sample.y,wire_ref_sample.z)*(zoom);\n          float xd = plex_position.x - vWorld.x;\n          float yd = plex_position.y - vWorld.y;\n          float zd = plex_position.z - vWorld.z;\n          float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n          if (plex_dist<_maxPlexDistance)\{\n            plex_count = min(10,plex_count+1); //Add one to the count\n            for( int h = 0; h < plex_count+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n              if (plex_dist < plexlist\[h].w) \{                  \n                for( int i = plex_count+1; i > h ; i--) \{\n                  plexlist\[i] = plexlist\[i-1];\n                  plexlistXY\[i] = plexlistXY\[i-1];\n                \}\n                plexlist\[h] = float4(plex_position.x,plex_position.y,plex_position.z,plex_dist);\n                plexlistXY\[h] = int2(x,y);\n                break;        \n              \}\n            \}\n          \} \n        \}\n      \}\n    \}\n  \}\n  else\{ //Used for standard connection types\n    float4 temp_pos;\n    bool insideX = !(Vformat.x < pos.x+1);\n    bool insideY = !(Vformat.y < pos.y+1);\n\n\n    if (!_plexLinedefAUX)\{\n      temp_pos = normals(pos.x,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,vWorld+plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideX && !_plexLinedefX) \{\n      temp_pos = ppos(pos.x+1,pos.y );\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && !_plexLinedefX) \{\n      temp_pos = ppos(0,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideY && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\}                          \n    \}\n    else if ( _plexConnectY  && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,0);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    //_plexConnect\n    if ( insideX && insideY && !_plexLinedefXY) \{              \n      temp_pos = ppos(pos.x+1,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && _plexConnectY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && insideY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectY && insideX && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n  \}   \n\n  //now that all the connections have been sorted by distance then we connect the dots.\n  for( int x = 0; x < min(_maxPlexConnections,plex_count) ; x++)\{\n    plex_position = float3(plexlist\[x].x,plexlist\[x].y,plexlist\[x].z);\n    plex_dist = plexlist\[x].w;\n\n\n    float plex_distribution = 1.0f-((plexlist\[x].w-plexlist\[0].w)/((plexlist\[min(_maxPlexConnections,plex_count)].w-plexlist\[0].w)+0.00001f)); //Where does it lie between the best and the worst distance?\n    //plexlistXY\n\n    float4 plex_col = float4(pow(1.0f-(plex_dist/_maxPlexDistance),1.0f/_plex_gamma))*float4(plex_distribution); //This one is quite cool aswell, but does leave the center ones a bit too focused \n    float4 plex_colorA = src(pos.x,pos.y);\n    float4 plex_colorB = src( plexlistXY\[x].x,plexlistXY\[x].y);\n    plex_col *= 0.1f;\n\n    computePixelCoordinates(plex_position, pRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n    if (dst.bounds.inside(int(vRaster.x),int(vRaster.y)) || dst.bounds.inside(int(pRaster.x),int(pRaster.y)))\{\n        DrawLine(vRaster,pRaster,(plex_colorA*plex_col)*_lineInMultiplier,(plex_colorB*plex_col)*_lineOutMultiplier);\n    \}\n  \}\n\}\n\nvoid wire_connection(float3 p_source,float3 p_target, float4 (&p_plexlist)\[11], int2 (&p_plexlistXY)\[11],int &p_plexcount,int2 position) \{\n  float xd = p_target.x - p_source.x;\n  float yd = p_target.y - p_source.y;\n  float zd = p_target.z - p_source.z;\n  float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n  if (plex_dist<_maxPlexDistance)\{\n    p_plexcount = min(11,p_plexcount+1); //Add one to the count\n    for( int h = 0; h < p_plexcount+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n      if (plex_dist < p_plexlist\[h].w) \{                  \n        for( int i = p_plexcount+1; i > h ; i--) \{\n          p_plexlist\[i] = p_plexlist\[i-1];\n          p_plexlistXY\[i] = p_plexlistXY\[i-1];\n        \}\n        p_plexlist\[h] = float4(p_target.x,p_target.y,p_target.z,plex_dist);\n        p_plexlistXY\[h] = int2(position.x,position.y);\n        break;        \n      \}\n    \}  \n  \}\n\}\n//-------END OF WIRE RENDER FUNCTIONS---------\n\n\n\n\n//-------------------------------\n//-------BOKEH FUNCTIONS---------\n//thanks to: http://devlog-martinsh.blogspot.dk/2011/11/glsl-depth-of-field-with-bokeh-v21.html\nfloat2 rand(float2 coord) //generating noise/pattern texture for dithering\n\{\n  float noiseX = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.25)+(Frac(coord.y*(WHformat\[1]/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.75)+(Frac(coord.y*(WHformat\[1]/2.0))*0.25))*2.0-1.0;\n  noiseX = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f))) * 43758.5453f),0.0f,1.0f)*2.0f-1.0f;\n  noiseY = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f)*2.0f)) * 43758.5453f),0.0f,1.0f)*2.0-1.0f;\n  return float2(noiseX,noiseY);\n\}\n//-------------------------------------\n// Bokeh\n//-------------------------------------\nvoid Bokeh(float3 pos,float4 color)\{\n  float blur = 0.0;\n  blur = clamp((fabs(pos.z - focalDepth)/_depthOfField)*100.0f,-_maxDofSize,_maxDofSize);\n  \n  float w = (1.0/WHformat.x)*blur;//+noise.x;\n  float h = (1.0/(WHformat.x*dof_aspect))*blur;//+noise.y;\n  float3 v3_col = float3(color.x,color.y,color.z);\n  int ringsamples;\n  float s = 1.0;  \n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples; \n    for (int j = 0 ; j < ringsamples ; j += 1)  \n    \{ \n      s += (1.0f*mix(1.0f,(float(i))/(float(_dof_rings)),dof_bias)*1.0f); //No need to do this in the loop\n    \}\n  \}\n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples;\n     \n    for (int j = 0 ; j < ringsamples ; j += 1)   \n    \{\n      float step = PI*2.0 / float(ringsamples);\n      float pw = (cos(float(j)*step)*(float(i)/_dof_rings));\n      float ph = (sin(float(j)*step)*(float(i)/_dof_rings));\n      float p = 1.0;\n\n      float posx = pos.x+((pw*w)*blur);\n      float posy = pos.y+((ph*h)*blur);\n\n\n      float3 lumcoeff = float3(0.299,0.587,0.114);\n      float lum = dot(v3_col, lumcoeff);\n      float thresh = max((lum-dof_threshold)*dof_gain, 0.0f);\n      v3_col+mix(float3(0.0),v3_col,thresh*blur);\n\n      float3 col = (v3_col*mix(1.0,(float(i))/(float(_dof_rings)),dof_bias)*p)/s; \n      bilinear_Plot(float2(posx,posy),float4(col.x,col.y,col.z,color.w/(_dof_rings*_dof_rings)),1);\n    \}\n  \}\n\}\n//-------END OF BOKEH FUNCTIONS---------\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float2 posf = float2(pos.x,pos.y);\n\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n\n      //Convert worldspace coordinates to screenspcace coordinates.\n      vWorld = float3(_sample.x,_sample.y,_sample.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, vRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      if (ret) \{ //Only create points that are visible on screen\n        if (_pointRender)\{\n          point_render(pos,vRaster);\n        \}\n      \} //Pointrender over\n\n      if (_wireRender && _maxPlexConnections>=1) \{\n        if (max(pos.x,pos.y)<=max_line_connections || (_maxPlexType==0))\{ // Don't process more wires than allowed in nearest mode.\n          wire_render(pos);\n        \}\n      \} //WireRender over\n\n      if (_facetRender) \{\n        facet_render(pos,float3(_sample.x,_sample.y,_sample.z));\n      \}  //FacetRender over\n      \n    \}\n  \} //----> process\n\};\n"
  useGPUIfAvailable false
  rebuild ""
  PointRender3D_cam_Matrix {
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
    }
  PointRender3D_focallength {{parent.Camera1.focal}}
  PointRender3D_hapeture {{parent.Camera1.haperture}}
  PointRender3D_format {{!proxy?Settings_Format.width:Settings_Format.width*proxy_scale} {!proxy?Settings_Format.height:Settings_Format.height*proxy_scale}}
  PointRender3D_vertexformat {{parent.InputFormat.box.r-1} {parent.InputFormat.box.t-1}}
  PointRender3D__alphaMultiplier {{parent.AlphaMultiplier}}
  PointRender3D__pointRender {{parent.RenderMode==0}}
  PointRender3D__wireRender {{parent.RenderMode==1}}
  PointRender3D__facetRender {{parent.RenderMode==2}}
  PointRender3D__maxLDistance {{parent.wire_maxdistance}}
  PointRender3D__maxLConnections {{parent.wire_connections}}
  PointRender3D__maxPlexType {{-parent.wire_type}}
  PointRender3D__plexLinedefXY {{!parent.connect_xy}}
  PointRender3D__plexLinedefX {{!parent.connect_x}}
  PointRender3D__plexLinedefY {{!parent.connect_y}}
  PointRender3D__plexLinedefAUX {{!connect_aux}}
  PointRender3D__plexConnectX {{parent.CloseX}}
  PointRender3D__plexConnectY {{parent.CloseY}}
  PointRender3D__L_gamma {{parent.wire_Threshold}}
  "PointRender3D_Enable Depth of Field" {{parent.dof_enable}}
  PointRender3D_samples {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_rings {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_focalDepth {{parent.dof_focaldepth}}
  PointRender3D__depthOfField {{parent.dof_dof}}
  PointRender3D__depthMult 0
  PointRender3D__maxDofSize {{parent.dof_maxSize*400}}
  PointRender3D_dof_aspect {{parent.dof_Aspect}}
  PointRender3D_dof_bias {{parent.dof_bias}}
  PointRender3D__flatshading {{parent.facet_flatShading}}
  PointRender3D__backfacing {{parent.facet_backface}}
  PointRender3D__frontfacing {{parent.facet_front}}
  PointRender3D__vertexMode {{parent.renderMode}}
  PointRender3D__texoffset {-0.5 0.5}
  PointRender3D__pointSize 0
  PointRender3D__depthOcclusion {{parent.UseOcclusionMap}}
  PointRender3D__maxLineSteps {{parent.maxSamples}}
  PointRender3D__lineOffset {{parent.lineoffset}}
  PointRender3D__lineInMultiplier {{parent.inGain}}
  PointRender3D__lineOutMultiplier {{parent.outGain}}
  PointRender3D__overscan {{parent.overscan} {parent.overscan}}
  PointRender3D_isDepth true
  format "1280 720 0 0 1280 720 1 HD_720"
  rebuild_finalise ""
  name BlinkScriptZdepth
  label Zdepth
  xpos -28
  ypos 100
 }
 Dot {
  name Dot10
  xpos 97
  ypos 112
 }
 TimeBlur {
  divisions {{parent.Samples}}
  shutter {{parent.Shutter}}
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur1
  xpos 63
  ypos 300
  disable {{1-parent.mb_enable x89 0}}
 }
 Expression {
  expr3 a!=0?a/r:0
  name Expression3
  selected true
  xpos 63
  ypos 324
 }
 Dot {
  name Dot9
  xpos 97
  ypos 414
 }
push $N1c4a1ab0
push $N1c569c90
push $N1c5a6110
push $N1c4f27d0
 BlinkScript {
  inputs 4
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Render/3D_PointRender_v17.cpp
  recompileCount 803
  ProgramGroup 1
  KernelDescription "2 \"PointRender3D\" iterate pixelWise 0c100cf8a634aa2c2e18f544ec8abfd6d5d138cc25ae8f7d7127230910c2e91f 5 \"ppos\" Read Random \"src\" Read Random \"normals\" Read Random \"occlusion\" Read Random \"dst\" Write Random 49 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"vertexformat\" Int 2 CgAAAAoAAAA= \"Zoom\" Float 1 AACAPw== \"Filtering Method\" Int 1 AQAAAA== \"_alphaMultiplier\" Float 1 AACAPw== \"_pointRender\" Bool 1 AQ== \"_wireRender\" Bool 1 AQ== \"_facetRender\" Bool 1 AQ== \"_maxLDistance\" Float 1 AACAPw== \"_maxLConnections\" Int 1 AQAAAA== \"_maxPlexType\" Int 1 AAAAAA== \"_plexLinedefXY\" Bool 1 AA== \"_plexLinedefX\" Bool 1 AA== \"_plexLinedefY\" Bool 1 AA== \"_plexLinedefXtoY\" Bool 1 AA== \"_plexLinedefAUX\" Bool 1 AA== \"_plexConnectX\" Bool 1 AA== \"_plexConnectY\" Bool 1 AA== \"_L_gamma\" Float 1 AACAPw== \"Enable Depth of Field\" Bool 1 AA== \"samples\" Int 1 AwAAAA== \"rings\" Int 1 BQAAAA== \"focalDepth\" Float 1 AACAPw== \"_depthOfField\" Float 1 AACAQA== \"_depthMult\" Float 1 zczMPQ== \"_maxDofSize\" Float 1 AAAAQQ== \"dof_aspect\" Float 1 AACAPw== \"dof_threshold\" Float 1 AACAPw== \"dof_gain\" Float 1 AAAAAA== \"dof_bias\" Float 1 AAAAwA== \"dof_fringe\" Float 1 AAAAAA== \"_flatshading\" Bool 1 AQ== \"_backfacing\" Bool 1 AQ== \"_frontfacing\" Bool 1 AQ== \"_vertexMode\" Int 1 AAAAAA== \"_depthBuffer\" Bool 1 AQ== \"_texoffset\" Float 2 AAAAPwAAAD8= \"_pointSize\" Int 1 AQAAAA== \"_gaussigma\" Float 1 AACAPw== \"_depthOcclusion\" Bool 1 AQ== \"depthMultiplier\" Float 1 AACAPw== \"_maxLineSteps\" Float 1 AAB6RQ== \"_lineOffset\" Float 1 AACAPw== \"_lineInMultiplier\" Float 1 AACAPw== \"_lineOutMultiplier\" Float 1 AACAPw== \"_overscan\" Float 2 AAAAAAAAAAA= 49 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"Vformat\" 2 1 \"zoom\" 1 1 \"_filtering\" 1 1 \"_alphaMultiplier\" 1 1 \"_pointRender\" 1 1 \"_wireRender\" 1 1 \"_facetRender\" 1 1 \"_maxPlexDistance\" 1 1 \"_maxPlexConnections\" 1 1 \"_maxPlexType\" 1 1 \"_plexLinedefXY\" 1 1 \"_plexLinedefX\" 1 1 \"_plexLinedefY\" 1 1 \"_plexLinedefXtoY\" 1 1 \"_plexLinedefAUX\" 1 1 \"_plexConnectX\" 1 1 \"_plexConnectY\" 1 1 \"_plex_gamma\" 1 1 \"_dof_enable\" 1 1 \"_dof_samples\" 1 1 \"_dof_rings\" 1 1 \"focalDepth\" 1 1 \"_depthOfField\" 1 1 \"_depthMult\" 1 1 \"_maxDofSize\" 1 1 \"dof_aspect\" 1 1 \"dof_threshold\" 1 1 \"dof_gain\" 1 1 \"dof_bias\" 1 1 \"dof_fringe\" 1 1 \"_flatshading\" 1 1 \"_backfacing\" 1 1 \"_frontfacing\" 1 1 \"_vertexMode\" 1 1 \"_depthBuffer\" 1 1 \"_texoffset\" 2 1 \"_pointSize\" 1 1 \"_gaussigma\" 1 1 \"_depthOcclusion\" 1 1 \"depthMultiplier\" 1 1 \"_maxLineSteps\" 1 1 \"_lineOffset\" 1 1 \"_lineInMultiplier\" 1 1 \"_lineOutMultiplier\" 1 1 \"_overscan\" 2 1 10 \"max_line_connections\" Int 1 1 AAAAAA== \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "//Some basic generic functions.\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float3 Cross(float3 A,float3 B)\n\{\n    return float3(A.y*B.z - A.z*B.y,A.z*B.x - A.x*B.z,A.x*B.y - A.y*B.x);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}     \n\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\ninline float mix(float _X,float _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}                                                                                              \n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n\n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight,\n    float2 overscan\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f-overscan.x || pRaster.x > imageWidth+overscan.x || \n       pRaster.y < 0.0f-overscan.y || pRaster.y > imageHeight+overscan.y || pRaster.z < 0.0f) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eRead, eAccessRandom, eEdgeClamped> src;     //The texture map\n  Image<eRead, eAccessRandom, eEdgeClamped> normals;     //The texture map  \n  Image<eRead, eAccessRandom, eEdgeClamped> occlusion;     //The texture map \n  Image<eWrite, eAccessRandom> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat,Vformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    int _filtering;        //Filter method\n    float _alphaMultiplier; //Additive multiplier\n    bool _pointRender,_wireRender,_facetRender;\n    float _maxPlexDistance; //Additive multiplier\n    int _maxPlexConnections;\n    int _maxPlexType; // 0==Grid, -1==Nearest\n    bool _plexLinedefXY,_plexLinedefX,_plexLinedefY,_plexLinedefXtoY,_plexLinedefAUX; // Define what connections NOT to include\n    bool _plexConnectX,_plexConnectY; //Connect from the edge of x to 0, or edge of y to 0, usually for spheres\n    float _plex_gamma; //The threshold making shorter paths bright and longer paths dark\n    bool _dof_enable; // Enable DOF\n    int _dof_samples; // How many samples per DOF ring\n    int _dof_rings; // How many rings \n    float focalDepth,_depthOfField,_depthMult,_maxDofSize; //DOF Settings\n    float dof_aspect; //Pixel aspect ratio\n    float dof_threshold;\n    float dof_gain;\n    float dof_bias; //bokeh edge bias\n    float dof_fringe; //bokeh chromatic aberration/fringing\n    bool _flatshading,_backfacing,_frontfacing; //Vertex rendering settings\n    int _vertexMode;  //The rendering output mode, (think AOV)\n    bool _depthBuffer; //Non-additive, only render front most pixel\n    float2 _texoffset;\n    int _pointSize;\n    float _gaussigma;\n    bool _depthOcclusion;\n    float depthMultiplier;\n    float _maxLineSteps; //cap the line length to avoid process lock\n    float _lineOffset; //Alow you to shrink or extend the lines\n    float _lineInMultiplier,_lineOutMultiplier; //Control the brightness of the wires at the tips.\n    float2 _overscan; //This will allow you to render some extra outside the bounds of the image.\n\n  local: //Local variables\n    int max_line_connections;\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(Vformat,      \"vertexformat\", int2(10,10));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(_filtering, \"Filtering Method\", 1); \n    defineParam(_alphaMultiplier, \"_alphaMultiplier\", 1.0f);     \n    defineParam(_pointRender, \"_pointRender\", true);  \n    defineParam(_wireRender, \"_wireRender\", true);\n    defineParam(_facetRender, \"_facetRender\", true);\n    defineParam(_maxPlexDistance, \"_maxLDistance\", 1.0f);    \n    defineParam(_maxPlexConnections, \"_maxLConnections\", 1);    \n    defineParam(_maxPlexType, \"_maxPlexType\", 0); \n    defineParam(_plexLinedefXY, \"_plexLinedefXY\", false);      \n    defineParam(_plexLinedefXtoY, \"_plexLinedefXtoY\", false); //NYI\n    defineParam(_plexLinedefAUX, \"_plexLinedefAUX\", false); \n    defineParam(_plexLinedefX, \"_plexLinedefX\", false);  \n    defineParam(_plexLinedefY, \"_plexLinedefY\", false);  \n    defineParam(_plexConnectX, \"_plexConnectX\", false);      \n    defineParam(_plexConnectY, \"_plexConnectY\", false);   \n    defineParam(_plex_gamma, \"_L_gamma\", 1.0f);\n    //DOF SETTINGS   \n    defineParam(_dof_enable, \"Enable Depth of Field\", false);   \n    defineParam(_dof_samples, \"samples\", 3);    \n    defineParam(_dof_rings, \"rings\", 5);   \n    defineParam(focalDepth, \"focalDepth\", 1.0f);  \n    defineParam(_depthOfField, \"_depthOfField\", 4.0f);  \n    defineParam(_depthMult, \"_depthMult\", 0.1f);  \n    defineParam(_maxDofSize, \"_maxDofSize\", 8.0f);  \n    defineParam(dof_aspect, \"dof_aspect\", 1.0f);  \n    defineParam(dof_threshold, \"dof_threshold\", 1.0f);  \n    defineParam(dof_gain, \"dof_gain\", 0.0f);  \n    defineParam(dof_bias, \"dof_bias\", -2.0f);  \n    defineParam(dof_fringe, \"dof_fringe\", 0.0f); \n    //SHADING SETTINGS \n    defineParam(_flatshading, \"_flatshading\", true);  \n    defineParam(_vertexMode, \"_vertexMode\", 0);  \n    defineParam(_backfacing, \"_backfacing\", true);    \n    defineParam(_frontfacing, \"_frontfacing\", true);        \n    defineParam(_depthBuffer, \"_depthBuffer\", true);  \n    defineParam(_texoffset, \"_texoffset\", float2(0.5f,0.5f)); \n    defineParam(_pointSize, \"_pointSize\", 1); \n    defineParam(_gaussigma, \"_gaussigma\", 1.0f); \n    defineParam(_depthOcclusion, \"_depthOcclusion\", true); \n    defineParam(depthMultiplier, \"depthMultiplier\", 1.0f); \n    defineParam(_maxLineSteps, \"_maxLineSteps\", 4000.0f); \n    defineParam(_lineOffset, \"_lineOffset\", 1.0f); \n    defineParam(_lineInMultiplier, \"_lineInMultiplier\", 1.0f);   \n    defineParam(_lineOutMultiplier, \"_lineOutMultiplier\", 1.0f);     \n    defineParam(_overscan, \"_overscan\",float2(0.0f,0.0f));    \n\n  \}\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    max_line_connections = 80;\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n  \}\n\n  //Convert a 3d point position into a 2d raster position.\n  float3 Reconsile3D(float3 _PointPos)\{\n      vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      return tRaster;\n  \}\n\n//------------------------------\n//-------DRAW FUNCTIONS---------\n//------------------------------\n  //Write pixels to output.\n  void writepixel(float posx,float posy, float4 color,int index,float weight=1.0f)\n  \{ \n      if (_depthOcclusion)\{\n        float4 depthSample = occlusion(posx,posy);\n        if (depthSample.x<=vRaster.z && depthSample.w>0.0f)\{\n\n          float depth = (vRaster.z-depthSample.x);\n          color = color*(1.0f-depthSample.w);\n          color = color / (((depth*depth)*depthMultiplier)+1.0f);\n          //return;\n        \}\n      \}\n      float4 finalOutput; //This is used to store the final output\n      float4 dstSample; //This is used to store a sample of the destination\n      if ( dst.bounds.inside( posx, posy ) ) \{ //Test if the pixel written to is inside the output image. \n        if (_depthBuffer) \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          if ((dstSample.w>color.w)||dstSample.w==0.0f) \{\n            dst(posx,posy) = color;\n          \}\n        \}\n        else \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          finalOutput = dstSample + (color*_alphaMultiplier*weight);\n          finalOutput.w = dstSample.w + ((color.w*_alphaMultiplier*weight));\n\n          finalOutput.w = (dstSample.w + ((color.w*_alphaMultiplier*weight)))-(dstSample.w * ((color.w*_alphaMultiplier*weight)));\n\n          dst(posx,posy) = finalOutput;\n        \}\n      \} \n  \}\n\n  //Calculate a Bilinear Plot\n  void bilinear_Plot(float2 temppos,float4 color,int index)\n  \{\n    float2 p;\n    p.x=Frac(temppos.x);\n    p.y=Frac(temppos.y);\n    float weights\[] = \{(1.0f-p.x)*(1.0f-p.y), p.x*(1.0f-p.y), (1.0f-p.x)*p.y, p.x*p.y\};\n    int2 _position = int2(floor(temppos.x)-0,floor(temppos.y)-0); \n    writepixel(_position.x,_position.y,color,index,weights\[0]);\n    writepixel(_position.x+1,_position.y,color,index,weights\[1]);\n    writepixel(_position.x,_position.y+1,color,index,weights\[2]);\n    writepixel(_position.x+1,_position.y+1,color,index,weights\[3]);\n  \}\n\n  //NYI, unused!\n  void gaussian(float2 temppos,float4 color,int index)\{\n    float in_x = temppos.x;\n    float in_y = temppos.y;\n    int kernelSize = (_pointSize+1)*2;\n    int subsize = (kernelSize /2)-1;\n    float gKernel\[64]\[64];\n    float sigma = _gaussigma;\n    float intSigma = float(_pointSize);\n    float r, s = intSigma * sigma * sigma;\n\n    float sum = 0.0f;\n\n    // generate 5x5 kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            r = float(sqrt(x*x + y*y));\n            gKernel\[x + subsize]\[y + subsize] = (exp(-(r*r)/s))/(3.141592654f * s);\n            sum += gKernel\[x + subsize]\[y + subsize];\n        \}\n    \}\n\n    // normalize the Kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            gKernel\[x + subsize]\[y + subsize] /= sum;\n            writepixel(in_x+x,in_y+y,color,index,gKernel\[x + subsize]\[y + subsize]);\n        \}\n    \}\n  \}\n\n//-------------------------------------\n// DrawLine\n// ----------\n// Draw a line between two points, \n// x,y being 2d screenspace pos and z being depth.\n//-------------------------------------\n  void DrawLine(float3 origin, float3 endpoint,float4 _colorA,float4 _colorB) \{\n    float4 _color;\n    float3 delta = origin-endpoint;\n    float3 curPoint = origin;\n    float mag = sqrt(delta.x*delta.x+delta.y*delta.y);\n    mag = min(mag,_maxLineSteps); //Lets not go crazy, we cap it at 10.000 to avoid insane unwated processing time \n    for( float a = 0; a < mag*_lineOffset; a = a + 1.0f )\{\n      curPoint -= (delta/mag);\n      _color = (_colorA*(1.0f-(a/mag*1.0f)))+(_colorB*(a/mag*1.00f));\n      if (_dof_enable)\{\n        Bokeh(curPoint,_color);\n      \}\n      else \{\n        bilinear_Plot(float2(curPoint.x,curPoint.y),_color,1);\n      \}\n      \n    \}\n  \}\n\n//-------------------------------------\n// Point_Render\n//-------------------------------------\nvoid point_render(int2 pos, float3 screen_pos)\{\n  float4 color = src(pos.x,pos.y);\n\n  if (_filtering == 1)\{\n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        if (_depthBuffer) \{color.w = screen_pos.z;\} //Added\n        bilinear_Plot(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  /*\n  //THIS PART NEEDS TO BE RE-WRITTEN.\n  else if (_filtering == 2)\{ \n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        gaussian(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  */\n  else \{\n      int2 _position = int2(floor(screen_pos.x),floor(screen_pos.y)); \n      if (_depthBuffer) \{color.w = screen_pos.z;\}\n      writepixel(_position.x,_position.y, color,1,1.0f); //OutputSample\n  \}\n\n\}\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nvoid facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x+1,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos,V0_N,V1_N,V2_N;\n    float2 V0_ST,V1_ST,V2_ST;\n    float4 V1_Sample,V2_Sample;\n    float4 _tn;\n    float3 normal0,normal1,normal2;\n    float2 UV_Format = float2(Vformat.x,Vformat.y);\n\n\n    int2 P0 = int2(pos.x-1,pos.y-1);\n    int2 P1 = int2(pos.x+1,pos.y+1);\n    if (_plexConnectX && pos.x == int(Vformat.x))\{\n      insideX == true;\n      P1 = int2(0.0f,pos.y+1);\n    \}\n    if (_plexConnectY && pos.y == int(Vformat.y))\{\n      insideYtop == true;\n      P1 = int2(pos.x+1,0);\n    \} \n\n    if (_plexConnectY && pos.y == 0)\{\n      insideY == true;\n      P0 = int2(pos.x-1,int(UV_Format.y));\n    \} \n\n    if (!_flatshading) \{\n      _tn = normals(pos.x,pos.y);\n      V0_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n    V0_ST = float2(pos.x,pos.y)/UV_Format;\n\n  if (insideX) \{\n    V2_Sample = ppos(P1.x,pos.y);\n    V2_ST = float2(P1.x,pos.y)/UV_Format;\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (!_flatshading) \{\n      _tn = normals(P1.x,pos.y);\n      V2_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n        \n\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(P1.x,P0.y);\n        V1_ST = float2(P1.x,P0.y)/UV_Format;\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(P1.x,P0.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}\n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V2_Pos,V1_Pos,_vWorld,V2_wPos,V1_wPos,V0_N,V2_N,V1_N,V0_ST,V2_ST,V1_ST);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,P1.y);\n        V1_ST = float2(pos.x,P1.y)/UV_Format;        \n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(pos.x,P1.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}        \n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V1_Pos,V2_Pos,_vWorld,V1_wPos,V2_wPos,V0_N,V1_N,V2_N,V0_ST,V1_ST,V2_ST);\n        \}\n      \}\n    \}\n  \}\n\}\n\n\n\n//This function will calculate if pixel C is inside the triangle\nfloat edgeFunction(float3 a, float3 b, float3 c) \n\{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n\} \n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat Distance(float3 _a,float3 _b)\n\{\n          float xd = _a.x - _b.x;\n          float yd = _a.y - _b.y;\n          float zd = _a.z - _b.z;\n          return sqrt(xd*xd + yd*yd + zd*zd);\n\}\n\nvoid DrawTriangle(float3 V0, float3 V1, float3 V2,float3 WP0, float3 WP1, float3 WP2,float3 N0, float3 N1, float3 N2, float2 st0,float2 st1,float2 st2) \{\n\n  // Precompute reciprocal of vertex z-coordinate \n  V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n\n  float2 st0n = st0 * V0.z;\n  float2 st1n = st1 * V1.z; \n  float2 st2n = st2 * V2.z; //Normal version of ST\n\n  bool inside; \n  float X0 = Fmin(V0.x,V1.x,V2.x)-1.0f;\n  float X1 = Fmax(V0.x,V1.x,V2.x)+1.0f;\n  float Y0 = Fmin(V0.y,V1.y,V2.y)-1.0f;\n  float Y1 = Fmax(V0.y,V1.y,V2.y)+1.0f;\n  float area = edgeFunction(V2, V1, V0);\n\n\n  float2 sampos = float2(st0.x*float(Vformat.x),st0.y*float(Vformat.y));\n  float4 text0 = src(sampos.x,sampos.y);\n  sampos = float2(st1.x*float(Vformat.x),st1.y*float(Vformat.y));\n  float4 text1 = src(sampos.x,sampos.y);\n  sampos = float2(st2.x*float(Vformat.x),st2.y*float(Vformat.y));  //Why do we have to do this? =(\n  float4 text2 = src(sampos.x,sampos.y);\n  sampos = float2(min(min(st0.x,st1.x),st2.x)*float(Vformat.x),min(min(st0.y,st1.y),st2.y)*float(Vformat.y));\n  float4 text3 = src(sampos.x,sampos.y);\n\n\n  for( int x = X0; x < X1 ; x++) \{\n    for( int y = Y0; y < Y1 ; y++) \{\n      float3 pixelSample(x + _texoffset.x, y + _texoffset.y,0.0f); \n\n      //This is the part where we test if the current pixel is inside the triangle\n      //We check both for front facing and back faing options\n      float w0 = edgeFunction(V1, V0, pixelSample); //Front Facing\n      float w1 = edgeFunction(V2, V1, pixelSample); \n      float w2 = edgeFunction(V0, V2, pixelSample); \n      float w3 = edgeFunction(V0, V1, pixelSample); //Back Facing\n      float w4 = edgeFunction(V1, V2, pixelSample); \n      float w5 = edgeFunction(V2, V0, pixelSample);\n\n      //writepixel(x,y, float4(w1),1,1.0f);\n      if ((w0 >= 0 && w1 >= 0 && w2 >= 0 && _frontfacing) || (w3 >= 0 && w4 >= 0 && w5 >= 0 && _backfacing)) \{ //The curent pixel is inside the triangle\n\n       // calculate vectors from point f to vertices p1, p2 and p3:\n       float3 f1 = V0-pixelSample;\n       float3 f2 = V1-pixelSample;\n       float3 f3 = V2-pixelSample;\n       // calculate the areas and factors (order of parameters doesn't matter):\n       float a = length(cross(V0-V1,V0-V2 )); // main triangle area a\n       area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n        w0 /= area; \n        w1 /= area; \n        w2 /= area; \n\n        w3 /= area; \n        w4 /= area; \n        w5 /= area; \n\n       float a1 = length(cross(f2, f3)) / a; // p1's triangle area / a\n       float a2 = length(cross(f3, f1)) / a; // p2's triangle area / a \n       float a3 = length(cross(f1, f2)) / a; // p3's triangle area / a\n       float a_magnitude = a1+a2+a3;\n       a1 = a1/a_magnitude;\n       a2 = a2/a_magnitude;\n       a3 = a3/a_magnitude;\n       float z = 1.0f / (V0.z * a1 + V1.z * a2 + V2.z * a3); \n\n\n        // find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):\n        float2 uv = st0 * a1 + st1 * a2 + st2 * a3;\n        float2 st = st0 * w0 + st1 * w1 + st2 * w2; \n        st *= z;      \n\n\n        //Calculate normals. Eighter we have flat shading, else we calculate a normal per pixel\n        float3 normalB;\n        if (_flatshading) \{\n          normalB = CalculateSurfaceNormals(WP0,WP1,WP2);\n\n        \}\n        else \{\n          float3 c0 = N2/float3(V0.z); \n          float3 c1 = N0/float3(V1.z); \n          float3 c2 = N1/float3(V2.z);  \n\n          normalB.x = w0 * c0.x + w1 * c1.x + w2 * c2.x; \n          normalB.y = w0 * c0.y + w1 * c1.y + w2 * c2.y; \n          normalB.z = w0 * c0.z + w1 * c1.z + w2 * c2.z; \n\n          normalB.x *= z, normalB.y *= z, normalB.z *= z; \n        \}\n        normalB = normalize(normalB);\n\n        //CALCULATE THE OBJECT TEXTURE COORDINATES\n        float zn = 1.0f / (V0.z * w0 + V1.z * w1 + V2.z * w2); \n        st = st0n * w0 + st1n * w1 + st2n * w2; \n        st *= zn;   \n        //--END \n\n        float3 Wpos = WP0*a1 + WP1*a2 + WP2*a3; //World Position.\n        float3 ViewNormal = normalize(float3(cameraToWorld\[3]\[0],cameraToWorld\[3]\[1],cameraToWorld\[3]\[2])-Wpos);\n\n        float nDotView =  dot(normalB,ViewNormal);\n        nDotView = 1.0f-fabs(nDotView); //make sure that the view normal ramps back around when doing backface\n        float4 tempout;\n\n        //Flatshading or regular?\n        if (!_flatshading) \{\n          tempout = text0 * a1 + text1 * a2 + text2 * a3; \n        \}\n        else\{\n          tempout = text3;\n        \}\n\n        //Additional Render Modes\n        if (_vertexMode == 1)\{\n          tempout = float4(a1,a2,a3,1.0f);\n        \}\n        else if (_vertexMode == 2)\{\n          tempout = float4(normalB.x,normalB.y,normalB.z,1.0f);\n        \}\n        else if (_vertexMode == 3)\{\n          tempout = float4(nDotView,nDotView,nDotView,1.0f);\n        \}\n        else if (_vertexMode == 4)\{\n          tempout = float4(uv.x,uv.y,0.0f,1.0f);\n        \}       \n        else if (_vertexMode == 5)\{\n          tempout = float4(st.x,st.y,0.0f,1.0f);\n        \}               \n        else if (_vertexMode == 6)\{\n          tempout = float4(ViewNormal.x,ViewNormal.y,ViewNormal.z,1.0f);\n        \}             \n        else if (_vertexMode == 7)\{\n          tempout = float4(Wpos.x,Wpos.y,Wpos.z,1.0f);\n        \}   \n\n        if (_depthBuffer)\{\n          writepixel(x,y, float4(tempout.x,tempout.y,tempout.z,z),1,1.0f);  \n        \}\n        else \{\n          if (_dof_enable)\{\n            Bokeh(float3(x,y,z),float4(tempout.x,tempout.y,tempout.z,z));\n          \}\n          else \{\n            bilinear_Plot(float2(x,y),float4(tempout.x,tempout.y,tempout.z,z),1);\n          \}\n        \}\n\n      \}  \n\n    \}\n  \}\n\}\n\n//-------------------------------------\n// Wire_Render\n//-------------------------------------\nvoid wire_render(int2 pos) \{\n  float4 temp = float4(0.0f,0.0f,0.0f,FLT_MAX);\n  float4 wire_ref_sample;\n  int2 tempXY = int2(0,0);\n  float4 plexlist\[11] = \{temp,temp,temp,temp,temp,temp,temp,temp,temp,temp,temp\}; \n  int2 plexlistXY\[11] = \{tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY\};\n  int plex_count = 0; //We use this to figure how many points that should connect.\n  float plex_dist;\n  float3 plex_position,plex_position_b;\n  float4 temp_pos, temp_pos_b; //Temporary Position Containers\n  if (_maxPlexType == -1) \{ //Used for random connection types\n    for( int x = 0; x < max_line_connections ; x++)\{ //THIS 80 NUMBER IS THE LIMIT TO AVOID TOO SLOW PROCESSING!\n      for( int y = 0; y < max_line_connections ; y++)\{\n        wire_ref_sample = ppos(x,y);\n        if (wire_ref_sample.w != 0.0f && pos.x!=x && pos.y != y) \{ \n          plex_position = float3(wire_ref_sample.x,wire_ref_sample.y,wire_ref_sample.z)*(zoom);\n          float xd = plex_position.x - vWorld.x;\n          float yd = plex_position.y - vWorld.y;\n          float zd = plex_position.z - vWorld.z;\n          float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n          if (plex_dist<_maxPlexDistance)\{\n            plex_count = min(10,plex_count+1); //Add one to the count\n            for( int h = 0; h < plex_count+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n              if (plex_dist < plexlist\[h].w) \{                  \n                for( int i = plex_count+1; i > h ; i--) \{\n                  plexlist\[i] = plexlist\[i-1];\n                  plexlistXY\[i] = plexlistXY\[i-1];\n                \}\n                plexlist\[h] = float4(plex_position.x,plex_position.y,plex_position.z,plex_dist);\n                plexlistXY\[h] = int2(x,y);\n                break;        \n              \}\n            \}\n          \} \n        \}\n      \}\n    \}\n  \}\n  else\{ //Used for standard connection types\n    float4 temp_pos;\n    bool insideX = !(Vformat.x < pos.x+1);\n    bool insideY = !(Vformat.y < pos.y+1);\n\n\n    if (!_plexLinedefAUX)\{\n      temp_pos = normals(pos.x,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,vWorld+plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideX && !_plexLinedefX) \{\n      temp_pos = ppos(pos.x+1,pos.y );\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && !_plexLinedefX) \{\n      temp_pos = ppos(0,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideY && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\}                          \n    \}\n    else if ( _plexConnectY  && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,0);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    //_plexConnect\n    if ( insideX && insideY && !_plexLinedefXY) \{              \n      temp_pos = ppos(pos.x+1,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && _plexConnectY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && insideY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectY && insideX && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n  \}   \n\n  //now that all the connections have been sorted by distance then we connect the dots.\n  for( int x = 0; x < min(_maxPlexConnections,plex_count) ; x++)\{\n    plex_position = float3(plexlist\[x].x,plexlist\[x].y,plexlist\[x].z);\n    plex_dist = plexlist\[x].w;\n\n\n    float plex_distribution = 1.0f-((plexlist\[x].w-plexlist\[0].w)/((plexlist\[min(_maxPlexConnections,plex_count)].w-plexlist\[0].w)+0.00001f)); //Where does it lie between the best and the worst distance?\n    //plexlistXY\n\n    float4 plex_col = float4(pow(1.0f-(plex_dist/_maxPlexDistance),1.0f/_plex_gamma))*float4(plex_distribution); //This one is quite cool aswell, but does leave the center ones a bit too focused \n    float4 plex_colorA = src(pos.x,pos.y);\n    float4 plex_colorB = src( plexlistXY\[x].x,plexlistXY\[x].y);\n    plex_col *= 0.1f;\n\n    computePixelCoordinates(plex_position, pRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n    if (dst.bounds.inside(int(vRaster.x),int(vRaster.y)) || dst.bounds.inside(int(pRaster.x),int(pRaster.y)))\{\n        DrawLine(vRaster,pRaster,(plex_colorA*plex_col)*_lineInMultiplier,(plex_colorB*plex_col)*_lineOutMultiplier);\n    \}\n  \}\n\}\n\nvoid wire_connection(float3 p_source,float3 p_target, float4 (&p_plexlist)\[11], int2 (&p_plexlistXY)\[11],int &p_plexcount,int2 position) \{\n  float xd = p_target.x - p_source.x;\n  float yd = p_target.y - p_source.y;\n  float zd = p_target.z - p_source.z;\n  float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n  if (plex_dist<_maxPlexDistance)\{\n    p_plexcount = min(11,p_plexcount+1); //Add one to the count\n    for( int h = 0; h < p_plexcount+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n      if (plex_dist < p_plexlist\[h].w) \{                  \n        for( int i = p_plexcount+1; i > h ; i--) \{\n          p_plexlist\[i] = p_plexlist\[i-1];\n          p_plexlistXY\[i] = p_plexlistXY\[i-1];\n        \}\n        p_plexlist\[h] = float4(p_target.x,p_target.y,p_target.z,plex_dist);\n        p_plexlistXY\[h] = int2(position.x,position.y);\n        break;        \n      \}\n    \}  \n  \}\n\}\n//-------END OF WIRE RENDER FUNCTIONS---------\n\n\n\n\n//-------------------------------\n//-------BOKEH FUNCTIONS---------\n//thanks to: http://devlog-martinsh.blogspot.dk/2011/11/glsl-depth-of-field-with-bokeh-v21.html\nfloat2 rand(float2 coord) //generating noise/pattern texture for dithering\n\{\n  float noiseX = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.25)+(Frac(coord.y*(WHformat\[1]/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.75)+(Frac(coord.y*(WHformat\[1]/2.0))*0.25))*2.0-1.0;\n  noiseX = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f))) * 43758.5453f),0.0f,1.0f)*2.0f-1.0f;\n  noiseY = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f)*2.0f)) * 43758.5453f),0.0f,1.0f)*2.0-1.0f;\n  return float2(noiseX,noiseY);\n\}\n//-------------------------------------\n// Bokeh\n//-------------------------------------\nvoid Bokeh(float3 pos,float4 color)\{\n  float blur = 0.0;\n  blur = clamp((fabs(pos.z - focalDepth)/_depthOfField)*100.0f,-_maxDofSize,_maxDofSize);\n  \n  float w = (1.0/WHformat.x)*blur;//+noise.x;\n  float h = (1.0/(WHformat.x*dof_aspect))*blur;//+noise.y;\n  float3 v3_col = float3(color.x,color.y,color.z);\n  int ringsamples;\n  float s = 1.0;  \n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples; \n    for (int j = 0 ; j < ringsamples ; j += 1)  \n    \{ \n      s += (1.0f*mix(1.0f,(float(i))/(float(_dof_rings)),dof_bias)*1.0f); //No need to do this in the loop\n    \}\n  \}\n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples;\n     \n    for (int j = 0 ; j < ringsamples ; j += 1)   \n    \{\n      float step = PI*2.0 / float(ringsamples);\n      float pw = (cos(float(j)*step)*(float(i)/_dof_rings));\n      float ph = (sin(float(j)*step)*(float(i)/_dof_rings));\n      float p = 1.0;\n\n      float posx = pos.x+((pw*w)*blur);\n      float posy = pos.y+((ph*h)*blur);\n\n\n      float3 lumcoeff = float3(0.299,0.587,0.114);\n      float lum = dot(v3_col, lumcoeff);\n      float thresh = max((lum-dof_threshold)*dof_gain, 0.0f);\n      v3_col+mix(float3(0.0),v3_col,thresh*blur);\n\n      float3 col = (v3_col*mix(1.0,(float(i))/(float(_dof_rings)),dof_bias)*p)/s; \n      bilinear_Plot(float2(posx,posy),float4(col.x,col.y,col.z,color.w/(_dof_rings*_dof_rings)),1);\n    \}\n  \}\n\}\n//-------END OF BOKEH FUNCTIONS---------\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float2 posf = float2(pos.x,pos.y);\n\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n\n      //Convert worldspace coordinates to screenspcace coordinates.\n      vWorld = float3(_sample.x,_sample.y,_sample.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, vRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      if (ret) \{ //Only create points that are visible on screen\n        if (_pointRender)\{\n          point_render(pos,vRaster);\n        \}\n      \} //Pointrender over\n\n      if (_wireRender && _maxPlexConnections>=1) \{\n        if (max(pos.x,pos.y)<=max_line_connections || (_maxPlexType==0))\{ // Don't process more wires than allowed in nearest mode.\n          wire_render(pos);\n        \}\n      \} //WireRender over\n\n      if (_facetRender) \{\n        facet_render(pos,float3(_sample.x,_sample.y,_sample.z));\n      \}  //FacetRender over\n      \n    \}\n  \} //----> process\n\};\n"
  useGPUIfAvailable false
  rebuild ""
  PointRender3D_cam_Matrix {
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
    }
  PointRender3D_focallength {{parent.Camera1.focal}}
  PointRender3D_hapeture {{parent.Camera1.haperture}}
  PointRender3D_format {{!proxy?Settings_Format.width:Settings_Format.width*proxy_scale} {!proxy?Settings_Format.height:Settings_Format.height*proxy_scale}}
  PointRender3D_vertexformat {{parent.InputFormat.box.r-1} {parent.InputFormat.box.t-1}}
  PointRender3D__alphaMultiplier {{parent.AlphaMultiplier}}
  PointRender3D__pointRender {{parent.RenderMode==0}}
  PointRender3D__wireRender {{parent.RenderMode==1}}
  PointRender3D__facetRender {{parent.RenderMode==2}}
  PointRender3D__maxLDistance {{parent.wire_maxdistance}}
  PointRender3D__maxLConnections {{parent.wire_connections}}
  PointRender3D__maxPlexType {{-parent.wire_type}}
  PointRender3D__plexLinedefXY {{!parent.connect_xy}}
  PointRender3D__plexLinedefX {{!parent.connect_x}}
  PointRender3D__plexLinedefY {{!parent.connect_y}}
  PointRender3D__plexLinedefAUX {{!connect_aux}}
  PointRender3D__plexConnectX {{parent.CloseX}}
  PointRender3D__plexConnectY {{parent.CloseY}}
  PointRender3D__L_gamma {{parent.wire_Threshold}}
  "PointRender3D_Enable Depth of Field" {{parent.dof_enable}}
  PointRender3D_samples {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_rings {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_focalDepth {{parent.dof_focaldepth}}
  PointRender3D__depthOfField {{parent.dof_dof}}
  PointRender3D__depthMult 0
  PointRender3D__maxDofSize {{parent.dof_maxSize*400}}
  PointRender3D_dof_aspect {{parent.dof_Aspect}}
  PointRender3D_dof_bias {{parent.dof_bias}}
  PointRender3D__flatshading {{parent.facet_flatShading}}
  PointRender3D__backfacing {{parent.facet_backface}}
  PointRender3D__frontfacing {{parent.facet_front}}
  PointRender3D__vertexMode {{parent.renderMode}}
  PointRender3D__depthBuffer {{parent.facet_depth}}
  PointRender3D__texoffset {-0.5 0.5}
  PointRender3D__pointSize 0
  PointRender3D__depthOcclusion {{parent.UseOcclusionMap}}
  PointRender3D__maxLineSteps {{parent.maxSamples}}
  PointRender3D__lineOffset {{parent.lineoffset}}
  PointRender3D__lineInMultiplier {{parent.inGain}}
  PointRender3D__lineOutMultiplier {{parent.outGain}}
  PointRender3D__overscan {{parent.overscan} {parent.overscan}}
  format "1280 720 0 0 1280 720 1 HD_720"
  rebuild_finalise ""
  name BlinkScript1
  xpos -27
  ypos 159
 }
set N1c65e600 [stack 0]
 TimeBlur {
  divisions {{parent.Samples}}
  shutter {{parent.Shutter}}
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur
  xpos -27
  ypos 301
  disable {{1-parent.mb_enable x89 0}}
 }
 ShuffleCopy {
  inputs 2
  alpha alpha2
  black alpha
  out2 depth
  name ShuffleCopy2
  xpos -27
  ypos 411
  disable {{!parent.OutputZdepth}}
 }
 CopyBBox {
  inputs 2
  name CopyBBox1
  xpos -27
  ypos 521
 }
 Reformat {
  format {{{Settings_Format.format}}}
  resize none
  center false
  pbb {{max(parent.overscan.w,parent.overscan.h)!=0}}
  name Reformat1
  xpos -27
  ypos 545
 }
 Group {
  name SoftLook
  xpos -27
  ypos 647
  disable {{!parent.HighlightCompression}}
  addUserKnob {20 User}
  addUserKnob {26 ""}
  addUserKnob {7 Add R 0 4}
  Add {{parent.HighlightCeiling}}
  addUserKnob {7 Offset R 0 4}
  Offset {{parent.Compression}}
 }
  Input {
   inputs 0
   name Input1
   xpos -248
   ypos 500
  }
set N1c6fa8e0 [stack 0]
  Expression {
   expr0 r/(r+parent.Offset)*parent.Add
   expr1 g/(g+parent.Offset)*parent.Add
   expr2 b/(b+parent.Offset)*parent.Add
   expr3 a/(a+parent.Offset)*parent.Add
   name Expression1
   xpos -339
   ypos 576
  }
push $N1c6fa8e0
  ShuffleCopy {
   inputs 2
   red red
   green green
   blue blue
   alpha alpha2
   name ShuffleCopy1
   xpos -248
   ypos 576
  }
  Output {
   name Output1
   xpos -248
   ypos 651
  }
 end_group
 ShuffleCopy {
  inputs 2
  in pos
  red red
  green green
  blue blue
  out pos
  name ShuffleCopy1
  xpos -27
  ypos 860
  disable true
 }
 Output {
  name Output1
  xpos -27
  ypos 897
 }
push $N1c5a6110
 PositionToPoints2 {
  display textured
  render_mode textured
  P_channel pos
  detail 0.25
  pointSize 0.6
  name PreviewNode
  xpos -22
  ypos 8
  disable {{!parent.Enable3DPreview}}
 }
push $N1c3dbcc0
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize none
  filter Impulse
  black_outside true
  name Reformat3
  xpos -633
  ypos -1109
  disable {{!wire_type==1}}
 }
push $N1c4202e0
push $N1c440150
push $N1c444cb0
 Merge2 {
  inputs 2
  operation min
  Achannels {-pos.red -pos.green -pos.blue pos.alpha}
  Bchannels {-pos.red -pos.green -pos.blue pos.alpha}
  output {-pos.red -pos.green -pos.blue pos.alpha}
  name Merge4
  xpos -582
  ypos -634
 }
 Merge2 {
  inputs 2
  operation min
  Achannels {-pos.red -pos.green -pos.blue pos.alpha}
  Bchannels {-pos.red -pos.green -pos.blue pos.alpha}
  output {-pos.red -pos.green -pos.blue pos.alpha}
  name Merge5
  xpos -582
  ypos -602
 }
push $N1c458060
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -456
  ypos -402
 }
push $N1c65e600
 Viewer {
  frame 36
  frame_range 1-100
  name Viewer1
  xpos -27
  ypos 325
 }
 Input {
  inputs 0
  name InputCamera
  xpos -1271
  ypos 89
  number 1
 }
 Camera {
  useMatrix true
  matrix {
      {1 0 0 0}
      {0 {1/Settings_Format.actual_format.pixel_aspect} 0 0}
      {0 0 1 0}
      {0 0 0 1}
    }
  projection_mode {{"\[value the_cam]projection_mode"}}
  focal {{"\[value \[value the_cam]focal]"}}
  haperture {{"\[value \[value the_cam]haperture]"}}
  vaperture {{"\[value \[value the_cam]vaperture]"}}
  near {{"\[value \[value the_cam]near]"}}
  far {{"\[value \[value the_cam]far]"}}
  win_translate {{"\[lindex \[value \[value the_cam]win_translate] 0]"} {"\[lindex \[value \[value the_cam]win_translate] 1]"}}
  win_scale {{"\[lindex \[value \[value the_cam]win_scale] 0]"} {"\[lindex \[value \[value the_cam]win_scale] 1]"}}
  winroll {{"\[value \[value the_cam]winroll]"}}
  focal_point {{"\[value \[value the_cam]focal_point]"}}
  fstop {{"\[value \[value the_cam]fstop]"}}
  name Camera1
  help "DummyCam by Adrian Pueyo\n\nCamera that apart from the matrices also grabs all the \"Projection\" values from the upstream camera that it's connected to. Turns into a default Camera if not Camera connected.\n\nCan also be used inside of groups and gizmos, as many levels deep as you want :D\n\nAll using live and super fast TCL.\n\nadrianpueyo.com, 2019"
  onCreate "n = nuke.thisNode()\nfor k in \[\"projection_mode\",\"focal\",\"haperture\",\"vaperture\",\"near\",\"far\",\"win_translate\",\"win_scale\",\"winroll\",\"focal_point\",\"fstop\"]:\n    n\[k].setFlag(0x0000000010000000)"
  label "(thanks to Adrian Pueyo and Ernest Dios)"
  xpos -1261
  ypos 198
  addUserKnob {20 DummyCam l Defaults}
  addUserKnob {43 the_cam +INVISIBLE}
  the_cam "\[\nset the_knob \"focal\"\nset knob_index 0\nset starting_point \"this.input0\"\nset default \"this\"\nset default \[append default \".d_\"]\n\n# If cam has no inputs, return the default...\nif \{\[exists \$starting_point]\} \{\n    set x \[node \$starting_point]\n\} \{ \n    return \$default\n\}\n\nset finished 0\nwhile \{\$finished != 1\} \{\n\n    # First look for a Cam or Input or topnode.\n    while \{\[class \$x] != \"Camera2\" && \[class \$x] != \"Camera\" && \[class \$x] != \"Input\" && \$x != \[topnode \$x]\} \{\n        set x \[node \$x.input0]\n    \}\n\n    # Then, check if node is a cam (and return), and otherwise, if it's an input, see if the parent exists and move to it.\n    if \{\[class \$x]==\"Camera2\"||\[class \$x]==\"Camera\"\} \{\n        set x \[append x \".\"]\n        return \$x\n    \} \{ \n        if \{\[class \$x]==\"Input\"\} \{ \n            set inp \"\$x.parent.input\"\n            set inputNum \[value \$x.number]\n            set inp \[append inp \$inputNum]\n            if \{\[exists \$inp]\} \{\n                set x \[node \$inp]\n            \} \{ \n                set finished 1\n            \}\n        \} \{ \n            set finished 1\n        \}\n    \}\n\}\nreturn \$default\n]"
  addUserKnob {4 d_projection_mode l projection M {perspective orthographic uv spherical ""}}
  addUserKnob {7 d_focal l focal R 0 100}
  d_focal 50
  addUserKnob {7 d_haperture l "horiz aperture" R 0 50}
  d_haperture 24.576
  addUserKnob {7 d_vaperture l "vert aperture" R 0 50}
  d_vaperture 18.672
  addUserKnob {7 d_near l near R 0 10}
  d_near 0.1
  addUserKnob {7 d_far l far R 0 10000}
  d_far 10000
  addUserKnob {12 d_win_translate l "window translate"}
  addUserKnob {12 d_win_scale l "window scale"}
  d_win_scale {1 1}
  addUserKnob {7 d_winroll l "window roll" R 0 45}
  addUserKnob {7 d_focal_point l "focal distance" R 0 10}
  d_focal_point 2
  addUserKnob {7 d_fstop l fstop R 0 30}
  d_fstop 16
  addUserKnob {26 text l " " T "<span style=\"color:#666\"><br/><b>DummyCam v1.0</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2019</span>"}
 }
end_group
StickyNote {
 inputs 0
 name StickyNote5
 label "one of my old experiment which created cells"
 note_font_size 40
 xpos 488
 ypos -2043
}
StickyNote {
 inputs 0
 name StickyNote6
 label "different ways of generating textures and patterns. Some setups \nhave setups have pretty fine balance of parameters and if you \nchange it, the pattern dissapers. In others the are wide ranges \nwhat you can vary on knobs to produce different patterns."
 note_font_size 100
 xpos 3294
 ypos -2711
}
Camera2 {
 inputs 0
 translate {-21.79999924 -1 -10.39999962}
 rotate {0 -113.8716627 0}
 name Camera2
 xpos -2290
 ypos 2296
 addUserKnob {20 DNeg}
 addUserKnob {26 _version l "" +STARTLINE +INVISIBLE T 1.0}
 addUserKnob {41 "horiz aperture" T haperture}
 addUserKnob {41 "vert aperture" T vaperture}
 addUserKnob {4 setApertureValues l "" t "Set aperture values based on registered camera sensor data. The 'read from file' knob needs to be disabled and any potential curves deleted." +STARTLINE M {"Set Aperture Values" ANNI/Delivery "Alexa 65/Full" "Alexa 65/Half Res" "Alexa MINI/4:3 Full Ana" "Alexa MINI/16:9 Full" "Alexa MINI/OpenGate" "Alexa MINI/16:9 1.78 Ana" "Alexa Mini/OpenGate" "Alexa XT/OpenGate" "Alexa XT/4:3 Full Ana" "Alexa XT/16:9 1.78" "Alexa XT/16:9 1.78 Ana" "Alexa XT/4:3 Full" "Alexa XT/Open Gate" "Alexa XT/Open Gate TC" "Alexa XT/SuperOpenGate" "Alexa XT/SuperOpenGate Cropped" "Arri 65/6k 1.3 ana" "Arri 65/6k 2.11" BF/Delivery "BOND /Anamorphic" "Blackmagic Prod 4K/4K" "Canon 5D mkIII/HD" "Canon C300/16:9" "Delivery Extractions/Arri 65 1.3 ana Working" "Delivery Extractions/Arri 65 Working" "Extractions/CFW Delivery" "Film 35mm/Cinemascope Centred" "Film 35mm/Full Aperture" "Generic/1080p HD" Generic/Anamorphic Generic/Spherical "GoPro/Generic 16:9" HERC/Alexa IMAX/8K "Internal Movie Extractions/TRAINVFX Working" "Internal Movie Extractions/Alexa XT OpenGate" "Internal Movie Extractions/Previs" "Internal Movie Extractions/Arri 65 1.3 ana Working" "Internal Movie Extractions/MLOU Delivery" "Internal Movie Extractions/MAGIC Working" "Movie Extractions/Alexa XT OpenGate" "Movie Extractions/Alexa XT 4:3 Full Ana" "Movie Extractions/Alexa MINI 4:3 Full Ana" "Movie Extractions/Alexa MINI 16:9 1.78" "Movie Extractions/Alexa XT 16:9 1.78" "Movie Extractions/Alexa MINI OpenGate" "Movie Extractions/Alexa XT 16:9 1.78 Ana" "Movie Extractions/Alexa MINI 16:9 1.78 Ana" "Movie Extractions/Phantom Flex 4k" "Movie Extractions/MAE Working 2" "Movie Extractions/TS Anamorphic 4K" "Movie Extractions/EXO Working" "Movie Extractions/Previs" "Movie Extractions/MAGIC Working" "Movie Extractions/DOTN Working" "Phantom Flex/4k" Previs/Anamorphic Previs/Spherical "Red Epic/5K" "Red Epic Dragon/6K HD" "Red Epic Dragon/5K Full" "Red Epic Dragon/5K FullFrame Scaled" "TM/Alexa MINI 4:3 Full Ana" "Working Extractions/Arri 65 6k 1.3 ana" "Working Extractions/Alexa XT 4:3 Full Ana" "Working Extractions/Alexa XT OpenGate" "Working Extractions/Alexa XT 16:9 1.78" "Working Extractions/Alexa MINI 4:3 Full Ana" "Working Extractions/Alexa MINI OpenGate" "Working Extractions/Alexa MINI 16:9 1.78" "Working Extractions/Phantom Flex 4k" "Working Extractions/Alexa XT 16:9 1.78 Ana" "Working Extractions/Alexa MINI 16:9 1.78 Ana" "Working Extractions/EXO Working" "Working Extractions/EXO Working 2" "Working Extractions/Arri 65 6k" "Working Extractions/Alexa LF 4.5k OpenGate" "Working Extractions/DOTN Working" "internal Movie Extractions/Red Epic Dragon 5k FullFrame Scaled" "internal Movie Extractions/Red Epic Dragon 5K FullFrame" "internal Movie Extractions/IMAX 6K" "internal Movie Extractions/IMAX 8K" "Alexa LF/4.5k OpenGate" "Digital SLR/Full Frame" "Digital SLR/Full Frame Portrait" "Digital SLR/APS-C" "Digital SLR/APS-C Portrait" Generic/HD LatLong/360 LatLong/180}}
 addUserKnob {26 ""}
 addUserKnob {22 makeProjector l "Make Projector..." T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeProjectorNode']).makeProjectorNode()" +STARTLINE}
 addUserKnob {22 makeLinkedProjector l "Make Linked Projector..." -STARTLINE T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeProjectorNode']).makeLinkedProjectorNode()"}
 addUserKnob {26 ""}
 addUserKnob {7 hshake l "hero horiz shake" R -1 1}
 addUserKnob {7 vshake l "hero vert shake" R -1 1}
 addUserKnob {7 shakeroll l "hero shake roll" R -180 180}
 addUserKnob {7 ahshake l "ambient horiz shake" R -1 1}
 addUserKnob {7 avshake l "ambient vert shake" R -1 1}
 addUserKnob {7 ashakeroll l "ambient shake roll" R -180 180}
 addUserKnob {26 ""}
 addUserKnob {22 makeShakeCamera l "Make Shake Camera" T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeAmbientHeroShakeCamera']).makeAmbientHeroShakeCamera()" +STARTLINE}
 addUserKnob {22 makeShakeTransform l "Make Shake Transform" -STARTLINE T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeAmbientHeroShakeTransform']).makeAmbientHeroShakeTransform()"}
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 addUserKnob {1 leaf_label l Leaf}
 addUserKnob {1 ivy_version l Version}
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
push $N170e0b10
Dot {
 name Dot5
 xpos -2185
 ypos 1861
}
push $Nc142440
Dot {
 name Dot7
 xpos -1764
 ypos 1457
}
set N1c7ef800 [stack 0]
Mask3DV2 {
 name Mask3DV2_3
 note_font "Bitstream Vera Sans"
 xpos -1915
 ypos 1533
 in __position_world
 out rgba.alpha
 unpremultiply false
 matteShape Cube
 center {127.2569733 {curve x1001 27.515973 x1051 0.515973} 38.48317719}
 radius 10
 transform 1
 scaling {10 1 {scaling.x}}
 falloff 0.5
 _class Mask3D
}
push $N1c7ef800
Group {
 inputs 2
 name PointFractal
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 xpos -1792
 ypos 1533
 addUserKnob {20 User t test}
 addUserKnob {26 info l "" +STARTLINE T "Point Fractal 1.11\n"}
 addUserKnob {26 devider_noise l "<b><font color=#7DADF9>Noise Settings</font><b>"}
 addUserKnob {6 EnableOffset l "Enable Offset Input" t "Put a map into the \"Offset\" input of this node to modulate the noise based on the luminance of the map.\n\nThe red channal controls the low frequencies while the green channel controls the high frequencies.\n\nYou can for example use this to create a radially shaped noise." +STARTLINE}
 addUserKnob {6 Noise_Absolute l "Absolute Noise" t "Negative values in the noise offset is made positive." -STARTLINE}
 addUserKnob {3 Noise_Octaves l Octaves}
 Noise_Octaves 8
 addUserKnob {7 Noise_Gain l Gain}
 Noise_Gain 0.5
 addUserKnob {7 Noise_Lacunarity l Lacunarity R 0 4}
 Noise_Lacunarity 0.2
 addUserKnob {18 Amplitude}
 Amplitude {{curve x1001 0.5 x1051 20.5}}
 addUserKnob {6 Amplitude_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {3 Itterations l Iterations}
 Itterations 1
 addUserKnob {26 invis_devider_noise l "" +STARTLINE T " "}
 addUserKnob {26 Devider_Frequency l "<b><font color=#7DADF9>Freq Control</font><b>"}
 addUserKnob {19 Freq_Offset l "General Offset" t "This is like a 3D translation, letting you move the current noise pattern in the X, Y, Z and W (4th dimention)" R 0 10}
 Freq_Offset {0 0 0 0}
 addUserKnob {6 Freq_Offset_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_GeneralScale l "Genral Scale" t "This lets you control the scale of each individual noise axis."}
 Freq_GeneralScale 2
 addUserKnob {6 Freq_GeneralScale_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq l "" +STARTLINE T " "}
 addUserKnob {19 Freq_EvolveLow l "Evolve Low" t "This lets you evolve (auto animate) the noise in a particular direction. The \"Low\" part means that this only affects the low frequencies.\n\nTo avoid a \"scrolling\" effect you can use the 4th dimention to break up the spatial cohearence." R 0 10}
 Freq_EvolveLow {0.5 0 0 0.5}
 addUserKnob {6 Freq_EvolveLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_EvolveHigh l "Evolve High" t "This lets you evolve (auto animate) the noise in a particular direction. The \"High\" part means that this only affects the high frequencies.\n\nTo avoid a \"scrolling\" effect you can use the 4th dimention to break up the spatial cohearence."}
 Freq_EvolveHigh {0 0 0 0}
 addUserKnob {6 Freq_EvolveHigh_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq2 l "" +STARTLINE T " "}
 addUserKnob {19 Freq_ScaleLow l "Scale Low" t "This lets you scale the noise in a particular axis. The \"Low\" part means that this only affects the low frequencies."}
 Freq_ScaleLow {1 1 1 1}
 addUserKnob {6 Freq_ScaleLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_ScaleHigh l "Scale High" t "This lets you scale the noise in a particular axis. The \"High\" part means that this only affects the high frequencies."}
 Freq_ScaleHigh {1 1 1 1}
 addUserKnob {6 Freq_ScaleHigh_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq3 l "" +STARTLINE T " "}
 addUserKnob {26 Curve l "<b><font color=#7DADF9>Curve Noise</font><b>"}
 addUserKnob {6 CurveNoise_Enable l Enable t "Adds a gamma curve to the noise intensity making noise near the \"Offset\" value more flat. This is a experimental feature." +STARTLINE}
 addUserKnob {6 CurveNoise_Invert l Invert t "Inverts the effect of the curved noise." -STARTLINE}
 addUserKnob {7 CurveGain l "Curve Gain" R -10 10}
 CurveGain 3
 addUserKnob {7 CurveOffset l "Curve Offset" R -2 2}
 addUserKnob {26 gabgen l "" +STARTLINE T "\n"}
 addUserKnob {26 info_mask l "<b><font color=#7DADF9>Mask</font><b>"}
 addUserKnob {41 maskChannelMask l "" t "If a node is connected to the mask input, this will let you mask off the effect of the noise.\nIts recommended that you use the Point_Texture node to ensure a correct aspect and size." -STARTLINE T Merge1.maskChannelMask}
 addUserKnob {41 inject -STARTLINE T Merge1.inject}
 addUserKnob {41 invert_mask l invert -STARTLINE T Merge1.invert_mask}
 addUserKnob {41 fringe -STARTLINE T Merge1.fringe}
 addUserKnob {41 mix T Merge1.mix}
}
 Input {
  inputs 0
  name InputMask
  xpos -714
  ypos 297
  number 1
 }
 Reformat {
  type "to box"
  box_width {{parent.InputFormat.box.r}}
  box_height {{parent.InputFormat.box.t}}
  box_fixed true
  resize distort
  name Reformat2
  xpos -714
  ypos 396
 }
 Shuffle {
  name Shuffle3
  xpos -714
  ypos 420
 }
 Input {
  inputs 0
  name InputOffset
  xpos -208
  ypos 61
  number 2
 }
 Dot {
  name Dot2
  xpos -174
  ypos 153
 }
 Input {
  inputs 0
  name InputData
  xpos -582
  ypos 73
 }
 Dot {
  name Dot1
  xpos -548
  ypos 114
 }
set N1ca44d70 [stack 0]
 Shuffle {
  in pos
  name Shuffle1
  xpos -470
  ypos 110
 }
set N1ca49870 [stack 0]
 Multiply {
  value 0
  name Multiply1
  xpos -338
  ypos 106
 }
 Merge2 {
  inputs 2
  operation copy
  name Merge2
  xpos -338
  ypos 150
 }
push $N1ca49870
 BlinkScript {
  inputs 2
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/Fractal_v08.cpp
  recompileCount 64
  ProgramGroup 1
  KernelDescription "2 \"Noise4D\" iterate pixelWise be1f493003df1b115acb2d181bf4caa997e214937eb46d4cd65a56edf3425cad 3 \"src\" Read Point \"modix\" Read Point \"dst\" Write Point 19 \"absNoise\" Bool 1 AA== \"curveNoise\" Bool 1 AA== \"curveInvert\" Bool 1 AA== \"radialNoise\" Bool 1 AA== \"curveGain\" Float 1 AACAPw== \"curveOffset\" Float 1 AACAPw== \"Octaves\" Int 1 CgAAAA== \"Gain\" Float 1 AAAAPw== \"Lacunarity\" Float 1 AAAAQA== \"Gamma\" Float 1 AAAAPw== \"amplitude\" Float 3 AAAAPwAAAD8AAAA/AAAAAA== \"itterations\" Int 1 AQAAAA== \"Offset\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Scale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"suboffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topoffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"subscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"center\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== 19 \"absNoise\" 1 1 \"curveNoise\" 1 1 \"curveInvert\" 1 1 \"radialNoise\" 1 1 \"curveGain\" 1 1 \"curveOffset\" 1 1 \"octaves\" 1 1 \"gain\" 1 1 \"lacunarity\" 1 1 \"gamma\" 1 1 \"amplitude\" 3 1 \"itterations\" 1 1 \"offset\" 4 1 \"scale\" 4 1 \"suboffset\" 4 1 \"topoffset\" 4 1 \"subscale\" 4 1 \"topscale\" 4 1 \"center\" 3 1 0"
  kernelSource "//Based on https://github.com/Draradech/csworldgen/blob/master/simplexnoise.cpp\n//Ported by Mads Hagbarth Lund 2014\n\n/* Copyright (c) 2007-2012 Eliot Eshelman\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n\nint fastfloor( const float x ) \{ return x > 0 ? (int) x : (int) x - 1; \}\ninline float raw_noise_4d( const float x, const float y, const float z, const float w ) \n\{\nint simplex\[64]\[4] = \{\n    \{0,1,2,3\},\{0,1,3,2\},\{0,0,0,0\},\{0,2,3,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,2,3,0\},\n    \{0,2,1,3\},\{0,0,0,0\},\{0,3,1,2\},\{0,3,2,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,3,2,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{1,2,0,3\},\{0,0,0,0\},\{1,3,0,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,3,0,1\},\{2,3,1,0\},\n    \{1,0,2,3\},\{1,0,3,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,0,3,1\},\{0,0,0,0\},\{2,1,3,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{2,0,1,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,0,1,2\},\{3,0,2,1\},\{0,0,0,0\},\{3,1,2,0\},\n    \{2,1,0,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,1,0,2\},\{0,0,0,0\},\{3,2,0,1\},\{3,2,1,0\}\n\};\n    int perm\[512] = \{\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n    \};\n   int grad4\[32]\[4]= \{\n    \{0,1,1,1\},  \{0,1,1,-1\},  \{0,1,-1,1\},  \{0,1,-1,-1\},\n    \{0,-1,1,1\}, \{0,-1,1,-1\}, \{0,-1,-1,1\}, \{0,-1,-1,-1\},\n    \{1,0,1,1\},  \{1,0,1,-1\},  \{1,0,-1,1\},  \{1,0,-1,-1\},\n    \{-1,0,1,1\}, \{-1,0,1,-1\}, \{-1,0,-1,1\}, \{-1,0,-1,-1\},\n    \{1,1,0,1\},  \{1,1,0,-1\},  \{1,-1,0,1\},  \{1,-1,0,-1\},\n    \{-1,1,0,1\}, \{-1,1,0,-1\}, \{-1,-1,0,1\}, \{-1,-1,0,-1\},\n    \{1,1,1,0\},  \{1,1,-1,0\},  \{1,-1,1,0\},  \{1,-1,-1,0\},\n    \{-1,1,1,0\}, \{-1,1,-1,0\}, \{-1,-1,1,0\}, \{-1,-1,-1,0\}\n   \};\n    float F4 = (sqrt(5.0f)-1.0f)/4.0f;\n    float G4 = (5.0f-sqrt(5.0f))/20.0f;\n    float n0, n1, n2, n3, n4;\n    float s = (x + y + z + w) * F4;\n    int i = fastfloor(x + s);\n    int j = fastfloor(y + s);\n    int k = fastfloor(z + s);\n    int l = fastfloor(w + s);\n    float t = (i + j + k + l) * G4;\n    float X0 = i - t;\n    float Y0 = j - t;\n    float Z0 = k - t;\n    float W0 = l - t;\n\n    float x0 = x - X0;\n    float y0 = y - Y0;\n    float z0 = z - Z0;\n    float w0 = w - W0;\n    int c1 = (x0 > y0) ? 32 : 0;\n    int c2 = (x0 > z0) ? 16 : 0;\n    int c3 = (y0 > z0) ? 8 : 0;\n    int c4 = (x0 > w0) ? 4 : 0;\n    int c5 = (y0 > w0) ? 2 : 0;\n    int c6 = (z0 > w0) ? 1 : 0;\n    int c = c1 + c2 + c3 + c4 + c5 + c6;\n\n    int i1, j1, k1, l1;\n    int i2, j2, k2, l2;\n    int i3, j3, k3, l3;\n    i1 = simplex\[c]\[0]>=3 ? 1 : 0;\n    j1 = simplex\[c]\[1]>=3 ? 1 : 0;\n    k1 = simplex\[c]\[2]>=3 ? 1 : 0;\n    l1 = simplex\[c]\[3]>=3 ? 1 : 0;\n    i2 = simplex\[c]\[0]>=2 ? 1 : 0;\n    j2 = simplex\[c]\[1]>=2 ? 1 : 0;\n    k2 = simplex\[c]\[2]>=2 ? 1 : 0;\n    l2 = simplex\[c]\[3]>=2 ? 1 : 0;\n    i3 = simplex\[c]\[0]>=1 ? 1 : 0;\n    j3 = simplex\[c]\[1]>=1 ? 1 : 0;\n    k3 = simplex\[c]\[2]>=1 ? 1 : 0;\n    l3 = simplex\[c]\[3]>=1 ? 1 : 0;\n    float x1 = x0 - i1 + G4;\n    float y1 = y0 - j1 + G4;\n    float z1 = z0 - k1 + G4;\n    float w1 = w0 - l1 + G4;\n    float x2 = x0 - i2 + 2.0*G4;\n    float y2 = y0 - j2 + 2.0*G4;\n    float z2 = z0 - k2 + 2.0*G4;\n    float w2 = w0 - l2 + 2.0*G4;\n    float x3 = x0 - i3 + 3.0*G4;\n    float y3 = y0 - j3 + 3.0*G4;\n    float z3 = z0 - k3 + 3.0*G4;\n    float w3 = w0 - l3 + 3.0*G4;\n    float x4 = x0 - 1.0 + 4.0*G4;\n    float y4 = y0 - 1.0 + 4.0*G4;\n    float z4 = z0 - 1.0 + 4.0*G4;\n    float w4 = w0 - 1.0 + 4.0*G4;\n    int ii = i & 255;\n    int jj = j & 255;\n    int kk = k & 255;\n    int ll = l & 255;\n    int gi0 = perm\[ii+perm\[jj+perm\[kk+perm\[ll]]]] % 32;\n    int gi1 = perm\[ii+i1+perm\[jj+j1+perm\[kk+k1+perm\[ll+l1]]]] % 32;\n    int gi2 = perm\[ii+i2+perm\[jj+j2+perm\[kk+k2+perm\[ll+l2]]]] % 32;\n    int gi3 = perm\[ii+i3+perm\[jj+j3+perm\[kk+k3+perm\[ll+l3]]]] % 32;\n    int gi4 = perm\[ii+1+perm\[jj+1+perm\[kk+1+perm\[ll+1]]]] % 32;\n    float t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;\n    if(t0<0) n0 = 0.0;\n    else \{\n        t0 *= t0;\n        n0 = t0 * t0 * dot(float4(grad4\[gi0]\[0],grad4\[gi0]\[2],grad4\[gi0]\[3],grad4\[gi0]\[3]), float4(x0, y0, z0, w0));\n    \}\n    float t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;\n    if(t1<0) n1 = 0.0;\n    else \{\n        t1 *= t1;\n        n1 = t1 * t1 * dot(float4(grad4\[gi1]\[0],grad4\[gi1]\[2],grad4\[gi1]\[3],grad4\[gi1]\[3]), float4(x1, y1, z1, w1));\n    \}\n    float t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;\n    if(t2<0) n2 = 0.0;\n    else \{\n        t2 *= t2;\n        n2 = t2 * t2 * dot(float4(grad4\[gi2]\[0],grad4\[gi2]\[2],grad4\[gi2]\[3],grad4\[gi2]\[3]), float4(x2, y2, z2, w2));\n    \}\n    float t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;\n    if(t3<0) n3 = 0.0;\n    else \{\n        t3 *= t3;\n        n3 = t3 * t3 * dot(float4(grad4\[gi3]\[0],grad4\[gi3]\[2],grad4\[gi3]\[3],grad4\[gi3]\[3]), float4(x3, y3, z3, w3));\n    \}\n    float t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;\n    if(t4<0) n4 = 0.0;\n    else \{\n        t4 *= t4;\n        n4 = t4 * t4 * dot(float4(grad4\[gi4]\[0],grad4\[gi4]\[2],grad4\[gi4]\[3],grad4\[gi4]\[3]), float4(x4, y4, z4, w4));\n    \}\n    return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\}\n\n\n\n\nkernel Noise4D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n    Image<eRead, eAccessPoint, eEdgeClamped> modix;\n  Image<eWrite, eAccessPoint> dst;\nparam:\n    bool absNoise;\n    bool curveNoise;\n    bool curveInvert;\n    bool radialNoise;\n    float curveGain;\n    float curveOffset;\n    int octaves;\n    float gain;\n    float lacunarity;\n    float gamma;\n    float3 amplitude;\n    int itterations;\n    float4 offset;\n    float4 scale;\n    float4 suboffset;\n    float4 topoffset;\n    float4 subscale;\n    float4 topscale;\n    float3 center;\n\n\n  void define() \{\n        defineParam (absNoise, \"absNoise\", false);    \n        defineParam (curveNoise, \"curveNoise\", false);    \n        defineParam (curveInvert, \"curveInvert\", false);   \n        defineParam (radialNoise, \"radialNoise\", false);   //Used for radial noise\n        defineParam (curveGain, \"curveGain\", 1.0f);\n        defineParam (curveOffset, \"curveOffset\", 1.0f);\n        defineParam (octaves, \"Octaves\", 10);\n        defineParam (gain, \"Gain\", 0.5f);\n        defineParam (lacunarity, \"Lacunarity\", 2.0f);\n        defineParam (gamma, \"Gamma\", 0.5f);\n        defineParam (amplitude, \"amplitude\", float3(0.5f));\n        defineParam (itterations, \"itterations\", 1);\n        defineParam(offset, \"Offset\", float4(0.0f, 0.0f, 0.0f,0.0f));\n        defineParam(scale, \"Scale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(suboffset, \"suboffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topoffset, \"topoffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(subscale, \"subscale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topscale, \"topscale\", float4(1.0f, 1.0f, 1.0f,1.0f));   \n        defineParam(center, \"center\", float3(0.0f,0.0f,0.0f));   //Center for the radial noise      \n  \}\n\nfloat4 sphericalTransform( const float4 cartesian) \n\{\n    return float4(\n(atan2(cartesian.x-center.x,cartesian.y-center.y)+ PI)/+ (PI*2.0f),\n(atan2(cartesian.x-center.x,cartesian.z-center.z)+ PI)/+ (PI*2.0f),\n(atan2(cartesian.z-center.z,cartesian.y-center.y)+ PI)/+ (PI*2.0f),\ncartesian.w\n);\n\}\n\nfloat octave_noise_4d( float4 modulix, const float octaves, const float persistence, const float scale, const float x, const float y, const float z, const float w ) \n\{\n    float total = 0.0f;\n    float current;\n    float last = 1.0f;\n    float frequency = scale;\n    float amplitude = 1.0f;\n    float maxAmplitude = 0.0f;\n    float4 Tempoffset;\n    float4 Tempscale;\n\n\n    for( int i=0; i < octaves; i++ ) \{\n\n        /*\n        if (i == 0) \{\n            total += (float)raw_noise_4d( (x+suboffset.x) * frequency, (y+suboffset.y) * frequency, (z+suboffset.z) * frequency, (w+suboffset.w) * frequency ) * amplitude;\n        \}\n        else if (i == octaves-1) \{\n            total += (float)raw_noise_4d( (x+topoffset.x) * frequency, (y+topoffset.y) * frequency, (z+topoffset.z) * frequency, (w+topoffset.w) * frequency ) * amplitude;\n        \}\n        else \{\n            total += (float)raw_noise_4d( x * frequency, y * frequency, z * frequency, w * frequency ) * amplitude;\n        \}\n        */\n\n\n        Tempscale = (topscale * (i/(octaves-1.0f)))+(subscale * (1-(i/(octaves-1.0f))));       \n        Tempoffset = ((topoffset+modulix.y) * (i/(octaves-1.0f)))+((suboffset+modulix.x) * (1-(i/(octaves-1.0f))));\n        current = (float)raw_noise_4d(   ((x*Tempscale.x)+Tempoffset.x) * frequency, \n                                        ((y*Tempscale.y)+Tempoffset.y) * frequency, \n                                        ((z*Tempscale.z)+Tempoffset.z) * frequency, \n                                        ((w*Tempscale.w)+Tempoffset.w) * frequency \n                                        ) * amplitude;\n        if (i == 0 && curveNoise)\{\n            if (curveInvert)\{\n                last = 0.5f-current;  \n            \}\n            else\{\n                last = current;  \n            \}\n               \n        \}\n        current = curveNoise?current*((last+curveOffset)*curveGain):current;\n        total += absNoise?fabs(current):current;\n        frequency *= 2.0f;\n        maxAmplitude += amplitude;\n        amplitude *= persistence;\n\n    \}\n    return float(total / maxAmplitude);\n\}\n\n\n\n\n  void process() \{\n    float4 srcSample = float4(src(0),src(1),src(2),src(3));\n    float4 srcSampleModix = modix();\n    float sampleR,sampleG,sampleB;\n    if (radialNoise)\{\n        srcSample = sphericalTransform(srcSample);\n    \}\n\n    for( int i=0; i < itterations; i++ ) \{\n        sampleR = (float)octave_noise_4d(srcSampleModix,float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w) * amplitude.x;\n        sampleG = (float)octave_noise_4d(srcSampleModix,float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w - 100.0f) * amplitude.y;\n        sampleB = (float)octave_noise_4d(srcSampleModix,float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w + 200.0f) * amplitude.z;\n        srcSample = float4(srcSample.x+sampleR,srcSample.y+sampleG,srcSample.z+sampleB,srcSample.w);\n    \}\n    dst() = float4(srcSample.x,srcSample.y,srcSample.z,1.0f);\n\}\n\};"
  rebuild ""
  Noise4D_curveNoise {{parent.CurveNoise_Enable}}
  Noise4D_curveInvert {{parent.CurveNoise_Invert}}
  Noise4D_curveGain {{parent.CurveGain}}
  Noise4D_curveOffset {{parent.CurveOffset}}
  Noise4D_Octaves {{parent.Noise_Octaves}}
  Noise4D_Gain {{parent.Noise_Gain}}
  Noise4D_Lacunarity {{parent.Noise_Lacunarity}}
  Noise4D_Gamma 0.79
  Noise4D_amplitude {{parent.Amplitude.r} {parent.Amplitude.g} {parent.Amplitude.b}}
  Noise4D_itterations {{parent.Itterations}}
  Noise4D_Offset {{parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset}}
  Noise4D_Scale {{parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale}}
  Noise4D_suboffset {{(frame*parent.Freq_EvolveLow.r)/50} {(frame*parent.Freq_EvolveLow.g)/50} {(frame*parent.Freq_EvolveLow.b)/50} {(frame*parent.Freq_EvolveLow.a)/50}}
  Noise4D_topoffset {{(frame*parent.Freq_EvolveHigh.r)/10} {(frame*parent.Freq_EvolveHigh.g)/10} {(frame*parent.Freq_EvolveHigh.b)/10} {(frame*parent.Freq_EvolveHigh.a)/10}}
  Noise4D_subscale {{parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow}}
  Noise4D_topscale {{parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh}}
  rebuild_finalise ""
  name Noise4D2
  xpos -338
  ypos 321
 }
push $N1ca49870
 BlinkScript {
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/Fractal_v06.cpp
  recompileCount 60
  ProgramGroup 1
  KernelDescription "2 \"Noise4D\" iterate pixelWise d54284af3e5573ad197bef9032773e8653de2cad590694fcc9fd5af993e97da3 2 \"src\" Read Point \"dst\" Write Point 17 \"absNoise\" Bool 1 AA== \"curveNoise\" Bool 1 AA== \"curveInvert\" Bool 1 AA== \"curveGain\" Float 1 AACAPw== \"curveOffset\" Float 1 AACAPw== \"Octaves\" Int 1 CgAAAA== \"Gain\" Float 1 AAAAPw== \"Lacunarity\" Float 1 AAAAQA== \"Gamma\" Float 1 AAAAPw== \"amplitude\" Float 3 AAAAPwAAAD8AAAA/AAAAAA== \"itterations\" Int 1 AQAAAA== \"Offset\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Scale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"suboffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topoffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"subscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== 17 \"absNoise\" 1 1 \"curveNoise\" 1 1 \"curveInvert\" 1 1 \"curveGain\" 1 1 \"curveOffset\" 1 1 \"octaves\" 1 1 \"gain\" 1 1 \"lacunarity\" 1 1 \"gamma\" 1 1 \"amplitude\" 3 1 \"itterations\" 1 1 \"offset\" 4 1 \"scale\" 4 1 \"suboffset\" 4 1 \"topoffset\" 4 1 \"subscale\" 4 1 \"topscale\" 4 1 0"
  kernelSource "//Based on https://github.com/Draradech/csworldgen/blob/master/simplexnoise.cpp\n//Ported by Mads Hagbarth Lund 2014\n\n/* Copyright (c) 2007-2012 Eliot Eshelman\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n\nint fastfloor( const float x ) \{ return x > 0 ? (int) x : (int) x - 1; \}\ninline float raw_noise_4d( const float x, const float y, const float z, const float w ) \n\{\nint simplex\[64]\[4] = \{\n    \{0,1,2,3\},\{0,1,3,2\},\{0,0,0,0\},\{0,2,3,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,2,3,0\},\n    \{0,2,1,3\},\{0,0,0,0\},\{0,3,1,2\},\{0,3,2,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,3,2,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{1,2,0,3\},\{0,0,0,0\},\{1,3,0,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,3,0,1\},\{2,3,1,0\},\n    \{1,0,2,3\},\{1,0,3,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,0,3,1\},\{0,0,0,0\},\{2,1,3,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{2,0,1,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,0,1,2\},\{3,0,2,1\},\{0,0,0,0\},\{3,1,2,0\},\n    \{2,1,0,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,1,0,2\},\{0,0,0,0\},\{3,2,0,1\},\{3,2,1,0\}\n\};\n    int perm\[512] = \{\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n    \};\n   int grad4\[32]\[4]= \{\n    \{0,1,1,1\},  \{0,1,1,-1\},  \{0,1,-1,1\},  \{0,1,-1,-1\},\n    \{0,-1,1,1\}, \{0,-1,1,-1\}, \{0,-1,-1,1\}, \{0,-1,-1,-1\},\n    \{1,0,1,1\},  \{1,0,1,-1\},  \{1,0,-1,1\},  \{1,0,-1,-1\},\n    \{-1,0,1,1\}, \{-1,0,1,-1\}, \{-1,0,-1,1\}, \{-1,0,-1,-1\},\n    \{1,1,0,1\},  \{1,1,0,-1\},  \{1,-1,0,1\},  \{1,-1,0,-1\},\n    \{-1,1,0,1\}, \{-1,1,0,-1\}, \{-1,-1,0,1\}, \{-1,-1,0,-1\},\n    \{1,1,1,0\},  \{1,1,-1,0\},  \{1,-1,1,0\},  \{1,-1,-1,0\},\n    \{-1,1,1,0\}, \{-1,1,-1,0\}, \{-1,-1,1,0\}, \{-1,-1,-1,0\}\n   \};\n    float F4 = (sqrt(5.0f)-1.0f)/4.0f;\n    float G4 = (5.0f-sqrt(5.0f))/20.0f;\n    float n0, n1, n2, n3, n4;\n    float s = (x + y + z + w) * F4;\n    int i = fastfloor(x + s);\n    int j = fastfloor(y + s);\n    int k = fastfloor(z + s);\n    int l = fastfloor(w + s);\n    float t = (i + j + k + l) * G4;\n    float X0 = i - t;\n    float Y0 = j - t;\n    float Z0 = k - t;\n    float W0 = l - t;\n\n    float x0 = x - X0;\n    float y0 = y - Y0;\n    float z0 = z - Z0;\n    float w0 = w - W0;\n    int c1 = (x0 > y0) ? 32 : 0;\n    int c2 = (x0 > z0) ? 16 : 0;\n    int c3 = (y0 > z0) ? 8 : 0;\n    int c4 = (x0 > w0) ? 4 : 0;\n    int c5 = (y0 > w0) ? 2 : 0;\n    int c6 = (z0 > w0) ? 1 : 0;\n    int c = c1 + c2 + c3 + c4 + c5 + c6;\n\n    int i1, j1, k1, l1;\n    int i2, j2, k2, l2;\n    int i3, j3, k3, l3;\n    i1 = simplex\[c]\[0]>=3 ? 1 : 0;\n    j1 = simplex\[c]\[1]>=3 ? 1 : 0;\n    k1 = simplex\[c]\[2]>=3 ? 1 : 0;\n    l1 = simplex\[c]\[3]>=3 ? 1 : 0;\n    i2 = simplex\[c]\[0]>=2 ? 1 : 0;\n    j2 = simplex\[c]\[1]>=2 ? 1 : 0;\n    k2 = simplex\[c]\[2]>=2 ? 1 : 0;\n    l2 = simplex\[c]\[3]>=2 ? 1 : 0;\n    i3 = simplex\[c]\[0]>=1 ? 1 : 0;\n    j3 = simplex\[c]\[1]>=1 ? 1 : 0;\n    k3 = simplex\[c]\[2]>=1 ? 1 : 0;\n    l3 = simplex\[c]\[3]>=1 ? 1 : 0;\n    float x1 = x0 - i1 + G4;\n    float y1 = y0 - j1 + G4;\n    float z1 = z0 - k1 + G4;\n    float w1 = w0 - l1 + G4;\n    float x2 = x0 - i2 + 2.0*G4;\n    float y2 = y0 - j2 + 2.0*G4;\n    float z2 = z0 - k2 + 2.0*G4;\n    float w2 = w0 - l2 + 2.0*G4;\n    float x3 = x0 - i3 + 3.0*G4;\n    float y3 = y0 - j3 + 3.0*G4;\n    float z3 = z0 - k3 + 3.0*G4;\n    float w3 = w0 - l3 + 3.0*G4;\n    float x4 = x0 - 1.0 + 4.0*G4;\n    float y4 = y0 - 1.0 + 4.0*G4;\n    float z4 = z0 - 1.0 + 4.0*G4;\n    float w4 = w0 - 1.0 + 4.0*G4;\n    int ii = i & 255;\n    int jj = j & 255;\n    int kk = k & 255;\n    int ll = l & 255;\n    int gi0 = perm\[ii+perm\[jj+perm\[kk+perm\[ll]]]] % 32;\n    int gi1 = perm\[ii+i1+perm\[jj+j1+perm\[kk+k1+perm\[ll+l1]]]] % 32;\n    int gi2 = perm\[ii+i2+perm\[jj+j2+perm\[kk+k2+perm\[ll+l2]]]] % 32;\n    int gi3 = perm\[ii+i3+perm\[jj+j3+perm\[kk+k3+perm\[ll+l3]]]] % 32;\n    int gi4 = perm\[ii+1+perm\[jj+1+perm\[kk+1+perm\[ll+1]]]] % 32;\n    float t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;\n    if(t0<0) n0 = 0.0;\n    else \{\n        t0 *= t0;\n        n0 = t0 * t0 * dot(float4(grad4\[gi0]\[0],grad4\[gi0]\[2],grad4\[gi0]\[3],grad4\[gi0]\[3]), float4(x0, y0, z0, w0));\n    \}\n    float t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;\n    if(t1<0) n1 = 0.0;\n    else \{\n        t1 *= t1;\n        n1 = t1 * t1 * dot(float4(grad4\[gi1]\[0],grad4\[gi1]\[2],grad4\[gi1]\[3],grad4\[gi1]\[3]), float4(x1, y1, z1, w1));\n    \}\n    float t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;\n    if(t2<0) n2 = 0.0;\n    else \{\n        t2 *= t2;\n        n2 = t2 * t2 * dot(float4(grad4\[gi2]\[0],grad4\[gi2]\[2],grad4\[gi2]\[3],grad4\[gi2]\[3]), float4(x2, y2, z2, w2));\n    \}\n    float t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;\n    if(t3<0) n3 = 0.0;\n    else \{\n        t3 *= t3;\n        n3 = t3 * t3 * dot(float4(grad4\[gi3]\[0],grad4\[gi3]\[2],grad4\[gi3]\[3],grad4\[gi3]\[3]), float4(x3, y3, z3, w3));\n    \}\n    float t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;\n    if(t4<0) n4 = 0.0;\n    else \{\n        t4 *= t4;\n        n4 = t4 * t4 * dot(float4(grad4\[gi4]\[0],grad4\[gi4]\[2],grad4\[gi4]\[3],grad4\[gi4]\[3]), float4(x4, y4, z4, w4));\n    \}\n    return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\}\n\n\n\n\nkernel Noise4D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite, eAccessPoint> dst;\nparam:\n    bool absNoise;\n    bool curveNoise;\n    bool curveInvert;\n    float curveGain;\n    float curveOffset;\n    int octaves;\n    float gain;\n    float lacunarity;\n    float gamma;\n    float3 amplitude;\n    int itterations;\n    float4 offset;\n    float4 scale;\n    float4 suboffset;\n    float4 topoffset;\n    float4 subscale;\n    float4 topscale;\n\n\n  void define() \{\n        defineParam (absNoise, \"absNoise\", false);    \n        defineParam (curveNoise, \"curveNoise\", false);    \n        defineParam (curveInvert, \"curveInvert\", false);   \n        defineParam (curveGain, \"curveGain\", 1.0f);\n        defineParam (curveOffset, \"curveOffset\", 1.0f);\n        defineParam (octaves, \"Octaves\", 10);\n        defineParam (gain, \"Gain\", 0.5f);\n        defineParam (lacunarity, \"Lacunarity\", 2.0f);\n        defineParam (gamma, \"Gamma\", 0.5f);\n        defineParam (amplitude, \"amplitude\", float3(0.5f));\n        defineParam (itterations, \"itterations\", 1);\n        defineParam(offset, \"Offset\", float4(0.0f, 0.0f, 0.0f,0.0f));\n        defineParam(scale, \"Scale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(suboffset, \"suboffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topoffset, \"topoffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(subscale, \"subscale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topscale, \"topscale\", float4(1.0f, 1.0f, 1.0f,1.0f));        \n  \}\n\nfloat octave_noise_4d( const float octaves, const float persistence, const float scale, const float x, const float y, const float z, const float w ) \n\{\n    float total = 0.0f;\n    float current;\n    float last = 1.0f;\n    float frequency = scale;\n    float amplitude = 1.0f;\n    float maxAmplitude = 0.0f;\n    float4 Tempoffset;\n    float4 Tempscale;\n\n\n    for( int i=0; i < octaves; i++ ) \{\n\n        /*\n        if (i == 0) \{\n            total += (float)raw_noise_4d( (x+suboffset.x) * frequency, (y+suboffset.y) * frequency, (z+suboffset.z) * frequency, (w+suboffset.w) * frequency ) * amplitude;\n        \}\n        else if (i == octaves-1) \{\n            total += (float)raw_noise_4d( (x+topoffset.x) * frequency, (y+topoffset.y) * frequency, (z+topoffset.z) * frequency, (w+topoffset.w) * frequency ) * amplitude;\n        \}\n        else \{\n            total += (float)raw_noise_4d( x * frequency, y * frequency, z * frequency, w * frequency ) * amplitude;\n        \}\n        */\n\n\n        Tempscale = (topscale * (i/(octaves-1.0f)))+(subscale * (1-(i/(octaves-1.0f))));       \n        Tempoffset = (topoffset * (i/(octaves-1.0f)))+(suboffset * (1-(i/(octaves-1.0f))));\n        current = (float)raw_noise_4d(   ((x*Tempscale.x)+Tempoffset.x) * frequency, \n                                        ((y*Tempscale.y)+Tempoffset.y) * frequency, \n                                        ((z*Tempscale.z)+Tempoffset.z) * frequency, \n                                        ((w*Tempscale.w)+Tempoffset.w) * frequency \n                                        ) * amplitude;\n        if (i == 0 && curveNoise)\{\n            if (curveInvert)\{\n                last = 0.5f-current;  \n            \}\n            else\{\n                last = current;  \n            \}\n               \n        \}\n        current = curveNoise?current*((last+curveOffset)*curveGain):current;\n        total += absNoise?fabs(current):current;\n        frequency *= 2.0f;\n        maxAmplitude += amplitude;\n        amplitude *= persistence;\n\n    \}\n    return float(total / maxAmplitude);\n\}\n\n\n\n\n  void process() \{\n    float4 srcSample = float4(src(0),src(1),src(2),src(3));\n    float sampleR,sampleG,sampleB;\n    for( int i=0; i < itterations; i++ ) \{\n        sampleR = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w) * amplitude.x;\n        sampleG = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w - 100.0f) * amplitude.y;\n        sampleB = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w + 200.0f) * amplitude.z;\n        srcSample = float4(srcSample.x+sampleR,srcSample.y+sampleG,srcSample.z+sampleB,srcSample.w);\n    \}\n    dst() = float4(srcSample.x,srcSample.y,srcSample.z,1.0f);\n\}\n\};"
  rebuild ""
  Noise4D_curveNoise {{parent.CurveNoise_Enable}}
  Noise4D_curveInvert {{parent.CurveNoise_Invert}}
  Noise4D_curveGain {{parent.CurveGain}}
  Noise4D_curveOffset {{parent.CurveOffset}}
  Noise4D_Octaves {{parent.Noise_Octaves}}
  Noise4D_Gain {{parent.Noise_Gain}}
  Noise4D_Lacunarity {{parent.Noise_Lacunarity}}
  Noise4D_Gamma 0.79
  Noise4D_amplitude {{parent.Amplitude.r} {parent.Amplitude.g} {parent.Amplitude.b}}
  Noise4D_itterations {{parent.Itterations}}
  Noise4D_Offset {{parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset}}
  Noise4D_Scale {{parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale}}
  Noise4D_suboffset {{(frame*parent.Freq_EvolveLow.r)/50} {(frame*parent.Freq_EvolveLow.g)/50} {(frame*parent.Freq_EvolveLow.b)/50} {(frame*parent.Freq_EvolveLow.a)/50}}
  Noise4D_topoffset {{(frame*parent.Freq_EvolveHigh.r)/10} {(frame*parent.Freq_EvolveHigh.g)/10} {(frame*parent.Freq_EvolveHigh.b)/10} {(frame*parent.Freq_EvolveHigh.a)/10}}
  Noise4D_subscale {{parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow}}
  Noise4D_topscale {{parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh}}
  rebuild_finalise ""
  name Noise4D1
  xpos -470
  ypos 267
 }
 Switch {
  inputs 2
  which {{parent.EnableOffset}}
  name Switch1
  xpos -470
  ypos 325
 }
 Expression {
  expr0 abs(r)
  expr1 abs(g)
  expr2 abs(b)
  name Expression2
  xpos -470
  ypos 349
  disable {{!parent.Noise_Absolute}}
 }
 Shuffle {
  out pos
  name Shuffle2
  xpos -470
  ypos 420
 }
push $N1ca44d70
 Merge2 {
  inputs 2+1
  operation copy
  bbox B
  Achannels {pos.red pos.green pos.blue -pos.alpha}
  Bchannels {pos.red pos.green pos.blue -pos.alpha}
  output {pos.red pos.green pos.blue -pos.alpha}
  name Merge1
  xpos -582
  ypos 416
 }
 Output {
  name Output1
  xpos -582
  ypos 587
 }
push $N1ca44d70
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -713
  ypos 111
 }
 StickyNote {
  inputs 0
  name StickyNote1
  label "These two noise scripts are alsmost identical.\nThe problem is that adding 1 extra input does eat up a lot of performence,\nso when we don't need the input we should avoid using it."
  xpos -239
  ypos 269
 }
end_group
ShuffleCopy {
 inputs 2
 in2 pos
 red red
 green green
 blue blue
 out2 __position_world
 name ShuffleCopy1
 xpos -1792
 ypos 1858
}
Dot {
 name Dot6
 xpos -1764
 ypos 2044
}
set N1cb36c00 [stack 0]
Dot {
 name Dot49
 xpos -2181
 ypos 2044
}
Dot {
 name Dot48
 label "standart nuke tool\nlow quality, few controls"
 note_font_size 31
 xpos -2181
 ypos 2143
}
PositionToPoints2 {
 display textured
 render_mode textured
 P_channel __position_world
 detail 1
 pointSize 1
 name PositionToPoints1
 xpos -2209
 ypos 2272
}
push 0
ScanlineRender {
 inputs 3
 conservative_shader_sampling false
 overscan 150
 shutteroffset centred
 motion_vectors_type distance
 name ScanlineRender1
 xpos -2209
 ypos 2317
}
Axis2 {
 inputs 0
 translate {0 0 6}
 name Axis4
 xpos 690
 ypos 2049
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 addUserKnob {1 leaf_label l Leaf}
 addUserKnob {1 ivy_version l Version}
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
Axis2 {
 inputs 0
 rotate {0 {frame} 0}
 name Axis1
 xpos 616
 ypos 2091
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 addUserKnob {1 leaf_label l Leaf}
 addUserKnob {1 ivy_version l Version}
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
Camera2 {
 translate {0.4 0.6 -5}
 rotate {0 180 0}
 name Camera7
 xpos 627
 ypos 2197
 addUserKnob {20 DNeg}
 addUserKnob {26 _version l "" +STARTLINE +INVISIBLE T 1.0}
 addUserKnob {41 "horiz aperture" T haperture}
 addUserKnob {41 "vert aperture" T vaperture}
 addUserKnob {4 setApertureValues l "" t "Set aperture values based on registered camera sensor data. The 'read from file' knob needs to be disabled and any potential curves deleted." +STARTLINE M {"Set Aperture Values" ANNI/Delivery "Alexa 65/Full" "Alexa 65/Half Res" "Alexa MINI/4:3 Full Ana" "Alexa MINI/16:9 Full" "Alexa MINI/OpenGate" "Alexa MINI/16:9 1.78 Ana" "Alexa Mini/OpenGate" "Alexa XT/OpenGate" "Alexa XT/4:3 Full Ana" "Alexa XT/16:9 1.78" "Alexa XT/16:9 1.78 Ana" "Alexa XT/4:3 Full" "Alexa XT/Open Gate" "Alexa XT/Open Gate TC" "Alexa XT/SuperOpenGate" "Alexa XT/SuperOpenGate Cropped" "Arri 65/6k 1.3 ana" "Arri 65/6k 2.11" BF/Delivery "BOND /Anamorphic" "Blackmagic Prod 4K/4K" "Canon 5D mkIII/HD" "Canon C300/16:9" "Delivery Extractions/Arri 65 1.3 ana Working" "Delivery Extractions/Arri 65 Working" "Extractions/CFW Delivery" "Film 35mm/Cinemascope Centred" "Film 35mm/Full Aperture" "Generic/1080p HD" Generic/Anamorphic Generic/Spherical "GoPro/Generic 16:9" HERC/Alexa IMAX/8K "Internal Movie Extractions/TRAINVFX Working" "Internal Movie Extractions/Alexa XT OpenGate" "Internal Movie Extractions/Previs" "Internal Movie Extractions/Arri 65 1.3 ana Working" "Internal Movie Extractions/MLOU Delivery" "Internal Movie Extractions/MAGIC Working" "Movie Extractions/Alexa XT OpenGate" "Movie Extractions/Alexa XT 4:3 Full Ana" "Movie Extractions/Alexa MINI 4:3 Full Ana" "Movie Extractions/Alexa MINI 16:9 1.78" "Movie Extractions/Alexa XT 16:9 1.78" "Movie Extractions/Alexa MINI OpenGate" "Movie Extractions/Alexa XT 16:9 1.78 Ana" "Movie Extractions/Alexa MINI 16:9 1.78 Ana" "Movie Extractions/Phantom Flex 4k" "Movie Extractions/MAE Working 2" "Movie Extractions/TS Anamorphic 4K" "Movie Extractions/EXO Working" "Movie Extractions/Previs" "Movie Extractions/MAGIC Working" "Movie Extractions/DOTN Working" "Phantom Flex/4k" Previs/Anamorphic Previs/Spherical "Red Epic/5K" "Red Epic Dragon/6K HD" "Red Epic Dragon/5K Full" "Red Epic Dragon/5K FullFrame Scaled" "TM/Alexa MINI 4:3 Full Ana" "Working Extractions/Arri 65 6k 1.3 ana" "Working Extractions/Alexa XT 4:3 Full Ana" "Working Extractions/Alexa XT OpenGate" "Working Extractions/Alexa XT 16:9 1.78" "Working Extractions/Alexa MINI 4:3 Full Ana" "Working Extractions/Alexa MINI OpenGate" "Working Extractions/Alexa MINI 16:9 1.78" "Working Extractions/Phantom Flex 4k" "Working Extractions/Alexa XT 16:9 1.78 Ana" "Working Extractions/Alexa MINI 16:9 1.78 Ana" "Working Extractions/EXO Working" "Working Extractions/EXO Working 2" "Working Extractions/Arri 65 6k" "Working Extractions/Alexa LF 4.5k OpenGate" "Working Extractions/DOTN Working" "internal Movie Extractions/Red Epic Dragon 5k FullFrame Scaled" "internal Movie Extractions/Red Epic Dragon 5K FullFrame" "internal Movie Extractions/IMAX 6K" "internal Movie Extractions/IMAX 8K" "Alexa LF/4.5k OpenGate" "Digital SLR/Full Frame" "Digital SLR/Full Frame Portrait" "Digital SLR/APS-C" "Digital SLR/APS-C Portrait" Generic/HD LatLong/360 LatLong/180}}
 addUserKnob {26 ""}
 addUserKnob {22 makeProjector l "Make Projector..." T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeProjectorNode']).makeProjectorNode()" +STARTLINE}
 addUserKnob {22 makeLinkedProjector l "Make Linked Projector..." -STARTLINE T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeProjectorNode']).makeLinkedProjectorNode()"}
 addUserKnob {26 ""}
 addUserKnob {7 hshake l "hero horiz shake" R -1 1}
 addUserKnob {7 vshake l "hero vert shake" R -1 1}
 addUserKnob {7 shakeroll l "hero shake roll" R -180 180}
 addUserKnob {7 ahshake l "ambient horiz shake" R -1 1}
 addUserKnob {7 avshake l "ambient vert shake" R -1 1}
 addUserKnob {7 ashakeroll l "ambient shake roll" R -180 180}
 addUserKnob {26 ""}
 addUserKnob {22 makeShakeCamera l "Make Shake Camera" T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeAmbientHeroShakeCamera']).makeAmbientHeroShakeCamera()" +STARTLINE}
 addUserKnob {22 makeShakeTransform l "Make Shake Transform" -STARTLINE T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeAmbientHeroShakeTransform']).makeAmbientHeroShakeTransform()"}
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 addUserKnob {1 leaf_label l Leaf}
 addUserKnob {1 ivy_version l Version}
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
set N1d048e50 [stack 0]
ColorWheel {
 inputs 0
 format "256 256 0 0 256 256 1 square_256"
 gamma 0.45
 name ColorWheel2
 xpos 625
 ypos 1318
}
SphericalTransform {
 rx 90
 format "512 512 0 0 512 512 1 square_512"
 fix true
 name SphericalTransform1
 xpos 625
 ypos 1390
}
Transform {
 scale {1 1.1}
 center {1112 0}
 shutteroffset centred
 name Transform1
 xpos 625
 ypos 1426
}
Crop {
 box {0 0 512 512}
 name Crop2
 xpos 625
 ypos 1450
}
Group {
 inputs 0
 name Point_Sphere
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 xpos 452
 ypos 1527
 addUserKnob {20 User}
 addUserKnob {26 info l "" +STARTLINE T "Sphere Generator v1.1\n"}
 addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {14 PointDensity l "Point Density" R 0 100}
 PointDensity {512 {PointDensity.w}}
 addUserKnob {26 divider_transformation l "<b><font color=#7DADF9>Transform</font><b>"}
 addUserKnob {13 offset l Translate}
 addUserKnob {41 rotate l Rotate T Axis1.rotate}
 addUserKnob {41 scaling l Scale T Axis1.scaling}
 addUserKnob {41 uniform_scale l "Uniform Scale" T Axis1.uniform_scale}
 addUserKnob {41 skew l Skew T Axis1.skew}
 addUserKnob {26 devider_completion l "<b><font color=#7DADF9>Completion</font><b>"}
 addUserKnob {7 Width t "Let you peel open the sphere."}
 addUserKnob {7 Height t "Let you peel open the sphere."}
 addUserKnob {26 info_shade l "<b><font color=#7DADF9>Shading</font><b>"}
 addUserKnob {6 poleLight l "Reduce Pole" t "Due to the fact that the point density at the equator and at the poles are the same, the poles will appear brighter. This option will attempt to reduce the brightness of the points at the poles to make them appear just as bright as the equator." +STARTLINE}
 addUserKnob {20 Help}
 addUserKnob {26 info_1 l "" +STARTLINE T "When you render this sphere using the Wire Render mode \nyou will notice a gab where the edges meet.\n\nTo fix this use the \"Close X\" checkbox in the Render Settings of the Point Render node"}
}
 Crop {
  inputs 0
  box {{curve} {curve} {parent.PointDensity.w} {parent.PointDensity.h}}
  reformat true
  crop false
  name Format
  xpos 384
  ypos -295
 }
 Expression {
  expr1 (y)/height
  expr2 (x)/width
  name Generator
  xpos 384
  ypos -271
 }
 Grade {
  channels {rgba.red rgba.green rgba.blue none}
  blackpoint {{-whitepoint+1} {-whitepoint+1} {-whitepoint+1} {-whitepoint+1}}
  blackpoint_panelDropped true
  whitepoint {1 {((pow(parent.Height,2)*10)+1)} {((pow(parent.Width,2)*10)+1)} 1}
  whitepoint_panelDropped true
  add_panelDropped true
  black_clamp false
  name Grade2
  xpos 383
  ypos -228
 }
 Expression {
  expr1 (g+(sin(((x/width)*pi*density))*scale))+offset
  mix 0.095
  name Expression3
  xpos 383
  ypos -197
  disable true
  addUserKnob {20 User}
  addUserKnob {3 density l Density}
  addUserKnob {7 offset l Offset R -2 2}
  offset 77
  addUserKnob {7 scale l Scale}
 }
 Expression {
  expr1 g*height
  expr2 b*width
  name Expression2
  xpos 383
  ypos -166
 }
 Expression {
  temp_name0 lat
  temp_expr0 "g / (parent.PointDensity.h-1) * 180- 90"
  temp_name1 lon
  temp_expr1 "b / (parent.PointDensity.w-0) * 360-180"
  temp_name2 r
  temp_expr2 "cos(0.017453292519943295769236907684886 *  lat)"
  expr0 "(r * cos (0.017453292519943295769236907684886 * lon) +1)*0.5"
  expr1 "(sin (0.017453292519943295769236907684886 * lat)+1)*.5"
  expr2 "(r * sin(0.017453292519943295769236907684886 * lon)+1)*.5"
  name Expression9
  selected true
  xpos 384
  ypos -142
 }
 Grade {
  add 0.5
  reverse true
  black_clamp false
  name Grade3
  xpos 384
  ypos -112
 }
 ColorMatrix {
  matrix {
      {{parent.Axis1.world_matrix.0} {parent.Axis1.world_matrix.1} {parent.Axis1.world_matrix.2}}
      {{parent.Axis1.world_matrix.4} {parent.Axis1.world_matrix.5} {parent.Axis1.world_matrix.6}}
      {{parent.Axis1.world_matrix.8} {parent.Axis1.world_matrix.9} {parent.Axis1.world_matrix.10}}
    }
  name ColorMatrix1
  xpos 384
  ypos -88
 }
 Grade {
  add 0.5
  black_clamp false
  name Grade4
  xpos 384
  ypos -64
 }
 Add {
  value {{-.5+parent.offset} {-.5+parent.offset} {-.5+parent.offset} 0}
  name Add1
  xpos 384
  ypos -32
 }
 Shuffle {
  alpha white
  name Shuffle4
  xpos 384
 }
 Shuffle {
  black white
  white white
  red2 white
  green2 white
  out pos
  out2 rgba
  name Shuffle5
  xpos 384
  ypos 47
 }
 Expression {
  expr0 smoothstep(0,1,1-abs(cy*(width/height)))
  channel1 {-rgba.red rgba.green -rgba.blue none}
  expr1 smoothstep(0,1,1-abs(cy*(width/height)))
  channel2 {-rgba.red -rgba.green rgba.blue none}
  expr2 smoothstep(0,1,1-abs(cy*(width/height)))
  channel3 {none none none -rgba.alpha}
  name Expression1
  xpos 384
  ypos 71
  disable {{!parent.poleLight}}
 }
 ModifyMetaData {
  metadata {
   {set pointrender/n_points "\[expr \[value parent.PointDensity.w]*\[value parent.PointDensity.h]]"}
   {set pointrender/gen_type 2}
  }
  name SetMetaData
  xpos 384
  ypos 105
 }
 Grade {
  white {{1/((parent.PointDensity.w*parent.PointDensity.h)/40000)}}
  black_clamp false
  name Grade9
  xpos 384
  ypos 129
 }
 Crop {
  box {{curve} {curve} {parent.PointDensity.w} {parent.PointDensity.h}}
  crop false
  name Format1
  xpos 384
  ypos 153
 }
 Output {
  name Output1
  xpos 384
  ypos 262
 }
 Axis2 {
  inputs 0
  name Axis1
  xpos 529
  ypos -111
  addUserKnob {20 Ivy}
  addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
  addUserKnob {26 divider4 l "" +STARTLINE}
  addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
  _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
  addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
  addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
  addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
  _expressions {{curve}}
  addUserKnob {26 divider0 l "" +STARTLINE}
  addUserKnob {20 dbinfo l "DB Info" n 1}
  dbinfo 0
  addUserKnob {1 twig_dnuuid l "Twig Id"}
  addUserKnob {1 stalk_dnuuid l "Stalk Id"}
  addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
  addUserKnob {1 leaf_dnuuid l "Leaf Id"}
  addUserKnob {26 divider1 l "" +STARTLINE}
  addUserKnob {1 twigtype l "Twig Type"}
  addUserKnob {1 leaf_label l Leaf}
  addUserKnob {1 ivy_version l Version}
  addUserKnob {43 ivy_notes l Notes}
  addUserKnob {26 divider2 l "" +STARTLINE}
  addUserKnob {1 build_label l "Build Label"}
  addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
 }
end_group
ShuffleCopy {
 inputs 2
 in2 pos
 red red
 green green
 blue blue
 out2 pos
 name ShuffleCopy4
 xpos 625
 ypos 1521
}
set N1d1a79d0 [stack 0]
HueShift {
 channels {-pos.red -pos.green pos.blue pos.alpha}
 hue_rotation {{-frame*5}}
 name HueShift3
 xpos 625
 ypos 1694
}
Colorspace {
 channels pos
 colorspace_in CIE-XYZ
 colorspace_out HSL
 name Colorspace5
 xpos 625
 ypos 1730
}
Colorspace {
 channels pos
 colorspace_in CIE-LCH
 illuminant_in D55
 name Colorspace6
 xpos 625
 ypos 1766
}
HueShift {
 color {-1 0 0}
 hue_rotation {{-frame*5}}
 name HueShift4
 xpos 625
 ypos 1806
}
Crop {
 box {0 0 512 512}
 name Crop4
 xpos 625
 ypos 1841
}
Dot {
 name Dot17
 xpos 653
 ypos 1920
}
set N1d213ae0 [stack 0]
Dot {
 name Dot53
 label "can't update \nwhile in play"
 note_font_size 21
 xpos 499
 ypos 2018
}
Group {
 inputs 2
 name Point_Render3
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 xpos 471
 ypos 2218
 addUserKnob {20 User l "Point Render" t dd}
 addUserKnob {26 info_header l "" +STARTLINE T "Point Render v1.2"}
 addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {4 RenderMode l "Render Mode" t "Some generators support multiple render modes other than just point rendering. This should be considered a experimental feature, but can be used to great effect.\n\nIn the Render Settings tab you can find more controls relating to Wire and Facet rendering modes.\n\nNote that Facet Render can be slow when really close to a object. " M {"Point Render" "Wire Render" "Facet Render (experimental)" "" "" ""}}
 RenderMode "Wire Render"
 addUserKnob {7 FocalLength l "Focal Length" t "The point render does not take the focal length from the input camera, so if you want to match it to a camera you should link the focal length from the camera to this." +INVISIBLE R 0 200}
 FocalLength 40
 addUserKnob {7 horizontalApeture l "Horiz Apeture" +INVISIBLE R 0 100}
 horizontalApeture 24.576
 addUserKnob {14 overscan l Overscan R 0 100}
 addUserKnob {7 AlphaMultiplier l Exposure t "This is a general exposure modifier that lets you adjust the overall brightness of the render." R 0 2}
 AlphaMultiplier 1
 addUserKnob {6 OutputZdepth l "Output Z-depth" t "Will output a Z-depth channel. This will cause reduced rendering performence." +STARTLINE}
 addUserKnob {6 UseOcclusionMap l "Use Occlusion Map" t "Enable the Occlusion map input. This lets you use a depth map as a holdout.\n\nNote:\nThe Red channal should contain the depth (absolute distance, not 1/depth)\nThe Alpha channal must be 1 for the areas that you want to holdout." +STARTLINE}
 addUserKnob {4 occ_method l "" t "Real Depth - input RGB should be the distance to the camera, and A should be the alpha (White occlude, Black ingore).\n\n1/depth.z (Scanline Render) - Will use the depth.Z channal from the scanline render and convert to real depth internally. Alpha is still required." -STARTLINE M {"Real Depth" "1/depth.z (Scanline Render)" ""}}
 occ_method "1/depth.z (Scanline Render)"
 addUserKnob {26 devider_cc l "<b><font color=#7DADF9>Preview</font><b>"}
 addUserKnob {6 FastPreview l "Fast Preview" t "Reduce the number of points for a quick preview of the final render." +STARTLINE}
 addUserKnob {6 HighlightCompression l "Hilight Compression" t "Compresses the highlights to make it easier to see bright details." +STARTLINE}
 addUserKnob {7 HighlightCeiling l "Highlight Ceiling" t "Adjust the cealing for the highlight compression." R 1 10}
 HighlightCeiling 1.15
 addUserKnob {7 Compression t "The compression amount." -STARTLINE R 0 5}
 Compression 1
 addUserKnob {26 devider_format l "<b><font color=#7DADF9>Format</font><b>"}
 addUserKnob {41 format l "output format" T Settings_Format.format}
 addUserKnob {20 WireRender l "Render Settings"}
 addUserKnob {26 devider_wirerender l "<b><font color=#7DADF9>Wire Rendering</font><b>"}
 addUserKnob {4 wire_type l "Connection Mode" t "*Normal\nConnect lines between the local neigbours of the 2d position map\n\n*Nearest\nConnect lines to the nearest points (in 3D space). This mode is limited to 100x100 points for performence reasons!" M {Normal Nearest "" "" "" "" "" "" "" ""}}
 addUserKnob {26 text l "Normal Mode Wires" T " "}
 addUserKnob {6 connect_x l x t "Connect wires in the (uv) X axis." -STARTLINE}
 connect_x true
 addUserKnob {6 connect_xy l xy t "Connect wires in the (uv) XY axis." -STARTLINE}
 connect_xy true
 addUserKnob {6 connect_y l y t "Connect wires in the (uv) Y axis." -STARTLINE}
 connect_y true
 addUserKnob {6 connect_aux l aux t "If you input a vector map into the Aux input for this node, and enable this option, you will get a wire from each point along that vector." -STARTLINE}
 addUserKnob {7 wire_maxdistance l "Max Distance" t "The maximum distance that the wires connect." R 0 10}
 wire_maxdistance 6
 addUserKnob {7 wire_Threshold l "Distance Threshold" t "Control the max distance threshold" R 0 2}
 wire_Threshold 0.5
 addUserKnob {3 wire_connections l "Max Connections" t "The maximum number of connections (Not Yet Implemented)"}
 wire_connections 4
 addUserKnob {7 maxSamples l "Max Line Samples" t "The maximum length of a line. Once a line is longer than this, it will start break up. \nThis can also be used as a creative effect if you set it low, try setting it to 10 in wire mode to get dotted lines" R 0 10000}
 maxSamples 10000
 addUserKnob {7 lineoffset l "Line Offset" t "Expand or contract the lines."}
 lineoffset 1
 addUserKnob {7 inGain l "In Gain" t "Gain the brightness of the in-point of the lines"}
 inGain 1
 addUserKnob {7 outGain l "Out Gain" t "Gain the brightness of the out-point of the lines" -STARTLINE}
 outGain 1
 addUserKnob {26 devider_facet l "<b><font color=#7DADF9>Facet Rendering</font><b>"}
 addUserKnob {4 renderMode l "Render Mode" t "Pick the desidered render mode." M {Diffuse "Local ST" Normal "Facing Ratio" UV ST "View Normal" "World Position" "" ""}}
 addUserKnob {6 facet_flatShading l "Flat Shading" t "Flat shading" +STARTLINE}
 addUserKnob {6 facet_depth l "Depth Buffer" t "Enable depth sorting to avoid additive surfaces." -STARTLINE}
 addUserKnob {6 facet_front l "Front Face" t "Render front facing facets" +STARTLINE}
 facet_front true
 addUserKnob {6 facet_backface l "Back Face" t "Render backfacing faces" -STARTLINE}
 facet_backface true
 addUserKnob {26 _1 l "<b><font color=#7DADF9>Other</font><b>"}
 addUserKnob {6 CloseX l "Close X" t "On spheres or round objects this closes the loop" +STARTLINE}
 addUserKnob {6 CloseY l "Close Y" t "On spheres or round objects this closes the loop" -STARTLINE}
 addUserKnob {20 Fog_1 l Fog}
 addUserKnob {26 Devider_Fog l "<b><font color=#7DADF9>Fog</font><b>"}
 addUserKnob {6 Fog t "Fog reduces the brightness of poins far from the camera." +STARTLINE}
 Fog true
 addUserKnob {7 FogNear l "Fog Near" R 0 200}
 FogNear 3
 addUserKnob {7 FogFar l "Fog Far" R 0 200}
 FogFar 11
 addUserKnob {7 FogExponent l "Fog Exponent" R 0 8}
 FogExponent 6
 addUserKnob {20 DepthOfField l "Depth of Field"}
 addUserKnob {26 devider_dof l "<b><font color=#7DADF9>Depth Of Field</font><b>"}
 addUserKnob {6 dof_enable l Enable +STARTLINE}
 addUserKnob {7 dof_focaldepth l "Focal Depth" R 0 40}
 dof_focaldepth 5
 addUserKnob {7 dof_dof l "Depth of Field" R 0 10}
 dof_dof 2
 addUserKnob {7 dof_maxSize l "Max Size"}
 dof_maxSize 0.5
 addUserKnob {7 dof_Aspect l "Aspect Ratio"}
 dof_Aspect 1
 addUserKnob {7 dof_bias l Bias R -3 3}
 dof_bias -0.2
 addUserKnob {4 Dof_Quality l Quality M {Low Medium High Extreme}}
 addUserKnob {20 MotionBlur}
 addUserKnob {26 devider_MotionBlur l "<b><font color=#7DADF9>Motion Blur</font><b>"}
 addUserKnob {6 mb_enable l Enable +STARTLINE}
 addUserKnob {6 Fast l "Fast (Interpolated)" -STARTLINE}
 Fast true
 addUserKnob {3 Samples}
 Samples 4
 addUserKnob {7 Shutter R 0 2}
 Shutter 0.5
 addUserKnob {4 pulldown l "Shutter Offset" M {Centered Start End ""}}
 addUserKnob {20 preview_3d l "3D Preview"}
 addUserKnob {6 Enable3DPreview l "Enable 3D Preview" t "Display a preview of the points in the Nuke 3D view." +STARTLINE}
 Enable3DPreview true
 addUserKnob {41 pointSize l "point size" T PreviewNode.pointSize}
 addUserKnob {41 detail l "point detail" T PreviewNode.detail}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x388e8e00
  label "Output Format Manager"
  note_font_size 22
  xpos -1079
  ypos 117
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode10
  tile_color 0x388e8e00
  label "AUX Input"
  note_font_size 22
  xpos -385
  ypos 178
  bdwidth 207
  bdheight 178
 }
 BackdropNode {
  inputs 0
  name BackdropNode11
  tile_color 0x388e8e00
  label "Point Render"
  note_font_size 22
  xpos -96
  ypos 99
  bdwidth 203
  bdheight 131
 }
 BackdropNode {
  inputs 0
  name BackdropNode12
  tile_color 0x388e8e00
  label "Normal Generator\nFor Vertex Normals"
  note_font_size 22
  xpos -616
  ypos 243
  bdwidth 191
  bdheight 122
 }
 BackdropNode {
  inputs 0
  name BackdropNode13
  tile_color 0x388e8e00
  label "Ensure output format"
  note_font_size 22
  xpos -622
  ypos -41
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode14
  tile_color 0x388e8e00
  label "Motion Blur"
  note_font_size 22
  xpos -85
  ypos 255
  bdwidth 264
  bdheight 96
 }
 BackdropNode {
  inputs 0
  name BackdropNode15
  tile_color 0x388e8e00
  label "Soft Preview"
  note_font_size 22
  xpos -83
  ypos 601
  bdwidth 191
  bdheight 94
 }
 BackdropNode {
  inputs 0
  name BackdropNode16
  tile_color 0x388e8e00
  label "Final format"
  note_font_size 22
  xpos -84
  ypos 482
  bdwidth 192
  bdheight 95
 }
 BackdropNode {
  inputs 0
  name BackdropNode17
  tile_color 0x388e8e00
  label "No Clue =)"
  note_font_size 22
  xpos -385
  ypos -41
  bdwidth 160
  bdheight 87
 }
 BackdropNode {
  inputs 0
  name BackdropNode18
  tile_color 0x388e8e00
  label "Z-Depth Shuffle"
  note_font_size 22
  xpos -85
  ypos 367
  bdwidth 264
  bdheight 96
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0x388e8e00
  label Motionblur
  note_font_size 22
  xpos -672
  ypos -781
  bdwidth 258
  bdheight 246
 }
 BackdropNode {
  inputs 0
  name BackdropNode3
  tile_color 0x388e8e00
  label "Fast Preview"
  note_font_size 22
  xpos -669
  ypos -971
  bdwidth 254
  bdheight 138
 }
 BackdropNode {
  inputs 0
  name BackdropNode4
  tile_color 0x388e8e00
  label "Nearest Wire Mode Clamp"
  note_font_size 22
  xpos -666
  ypos -1184
  bdwidth 253
  bdheight 111
 }
 BackdropNode {
  inputs 0
  name BackdropNode5
  tile_color 0x388e8e00
  label Occlusion
  note_font_size 22
  xpos 208
  ypos 27
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode6
  tile_color 0x388e8e00
  label "Input Camera Container"
  note_font_size 22
  xpos -1357
  ypos 121
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode7
  tile_color 0x388e8e00
  label "3D Preview"
  note_font_size 22
  xpos -88
  ypos -45
  bdwidth 207
  bdheight 102
 }
 BackdropNode {
  inputs 0
  name BackdropNode8
  tile_color 0x388e8e00
  label "Input Format Manager"
  note_font_size 22
  xpos -526
  ypos -459
  bdwidth 208
  bdheight 97
 }
 BackdropNode {
  inputs 0
  name BackdropNode9
  tile_color 0x388e8e00
  label FOG
  note_font_size 22
  xpos -602
  ypos -253
  bdwidth 370
  bdheight 152
 }
 Input {
  inputs 0
  name InputPointData
  xpos -584
  ypos -1321
 }
 Dot {
  name Dot4
  xpos -550
  ypos -1234
 }
set N1d29dc40 [stack 0]
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize fill
  filter Impulse
  black_outside true
  name Reformat5
  xpos -584
  ypos -906
  disable {{!parent.FastPreview==1}}
 }
 Grade {
  white 10
  name Grade2
  xpos -584
  ypos -874
  disable {{!parent.FastPreview}}
 }
 Dot {
  name Dot2
  xpos -550
  ypos -712
 }
set N1d2c2290 [stack 0]
 Group {
  name FrameHold3
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -501
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame+1}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot6
  xpos -467
  ypos -659
 }
set N1d2e21e0 [stack 0]
push $N1d2c2290
 Group {
  name FrameHold2
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -660
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot5
  xpos -626
  ypos -659
 }
set N1d301fe0 [stack 0]
 Dissolve {
  inputs 2
  which {{frame-floor(frame)}}
  name Dissolve1
  xpos -582
  ypos -666
  disable {{1-parent.mb_enable}}
 }
set N1d306c70 [stack 0]
push $N1d2c2290
 Switch {
  inputs 2
  which {{parent.Fast}}
  name Switch2
  xpos -584
  ypos -567
 }
 Dot {
  name DataFetch
  label "data fetch\t"
  note_font_color 0xff21ff
  xpos -550
  ypos -513
  addUserKnob {20 User}
  addUserKnob {3 n_particles l "Number of Particles"}
  addUserKnob {3 gentype l "Type Of Generator"}
  addUserKnob {26 info l "" -STARTLINE T "0 = unknown, 1 = Card, 2 = Sphere, 3 = Grid"}
 }
set N1d31a020 [stack 0]
 Dot {
  name Dot3
  xpos -635
  ypos -513
 }
 Dot {
  name Dot1
  xpos -635
  ypos 863
 }
 Reformat {
  inputs 0
  format "1920 1080 0 0 1920 1080 1 Canon 5D mkIII HD"
  resize distort
  center false
  black_outside true
  name Settings_Format
  xpos -992
  ypos 209
 }
 AdjBBox {
  numpixels {{parent.overscan} {parent.overscan}}
  name AdjBBox2
  xpos -992
  ypos 241
 }
 Input {
  inputs 0
  name InputOcclusion
  xpos 238
  ypos 75
  number 2
 }
 Expression {
  expr0 depth.Z>0?1/depth.Z:0
  name Expression2
  xpos 238
  ypos 104
  disable {{!parent.occ_method}}
 }
 Constant {
  inputs 0
  channels rgb
  color 1
  format {{{parent.Settings_Format.format}}}
  name Empty
  xpos 371
  ypos 139
 }
 Switch {
  inputs 2
  which {{parent.UseOcclusionMap}}
  name Switch1
  xpos 238
  ypos 163
 }
 AdjBBox {
  numpixels {{parent.overscan} {parent.overscan}}
  name AdjBBox1
  xpos 118
  ypos 163
 }
set N1d363a50 [stack 0]
 Input {
  inputs 0
  name Aux
  xpos -324
  ypos 214
  number 3
 }
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter Impulse
  black_outside true
  name Reformat2
  xpos -324
  ypos 238
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop1
  xpos -324
  ypos 462
 }
push $N1d31a020
 Shuffle {
  in pos
  name Shuffle1
  xpos -584
  ypos -192
 }
set N1d38a4b0 [stack 0]
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter Impulse
  black_outside true
  name Reformat4
  xpos -584
  ypos 18
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop2
  xpos -584
  ypos 48
 }
 Dot {
  name Dot8
  xpos -550
  ypos 166
 }
set N1d3b46f0 [stack 0]
 Group {
  name Point_Normal2
  tile_color 0x434343ff
  note_font_color 0x55ffffff
  xpos -584
  ypos 498
  disable {{!(renderMode==2&&RenderMode==2)}}
  addUserKnob {20 User}
  addUserKnob {26 info l "" +STARTLINE T "Point Normal v1.0"}
  addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
  addUserKnob {26 info_1 l "" +STARTLINE T "well, not much to do here =)"}
 }
  Input {
   inputs 0
   name Input1
   xpos 389
   ypos 207
  }
  Shuffle {
   in pos
   name Shuffle1
   xpos 389
   ypos 294
  }
  BlinkScript {
   kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/BasicLight.cpp
   recompileCount 69
   ProgramGroup 1
   KernelDescription "2 \"PointRender3D\" iterate pixelWise d5452fe7b684561fcfa5182d0c789025a037cc4fe4474c24e065e3fa53fcd8ce 2 \"ppos\" Read Random \"dst\" Write Point 9 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"Zoom\" Float 1 AACAPw== \"half Lambert\" Bool 1 AQ== \"light Mode\" Int 1 AAAAAA== \"light_position\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"light_color\" Float 3 AACAPwAAgD8AAIA/AAAAAA== 9 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"zoom\" 1 1 \"halfLambert\" 1 1 \"lightMode\" 1 1 \"lightPos\" 3 1 \"lightcolor\" 3 1 10 \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"namount\" Float 1 1 AAAAAA=="
   kernelSource "inline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}\n\ninline float saturate(float _in)\n\{\n    return max(0.0f,min(1.0f,_in));\n\}\n\ninline float3 reflect(float3 incidence,float3 normal)\n\{\n  return incidence - 2.f * dot(incidence, normal) * normal;\n\}\n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n    \n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    if (fabs(pScreen.x) > canvasWidth || fabs(pScreen.y) > canvasHeight) \n         return false; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eWrite> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    bool halfLambert;\n    int lightMode;\n    float3 lightPos;\n    float3 lightcolor;\n\n\n  local: //Local variables\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n    float namount; //dither amount\n\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(halfLambert, \"half Lambert\", true);\n    defineParam(lightMode, \"light Mode\", 0);\n    defineParam(lightPos,      \"light_position\", float3(0,0,0));  \n    defineParam(lightcolor,      \"light_color\", float3(1.0,1.0,1.0)); \n  \}\n\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n    namount = 0.0001; //dither amount\n  \}\n\n\n\nfloat3 Reconsile3D(float3 _PointPos)\{\n    vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n    int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    return tRaster;\n\}\n\n\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nfloat3 facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos;\n    float4 V0_Sample,V1_Sample,V2_Sample;\n    float3 normal0,normal1,normal2;\n\n    //for area calculation\n    float area;\n    float3 V0,V1,V2;\n    float3 output = float3(0.0f);\n  if (insideX) \{\n    V2_Sample = ppos(pos.x+1,pos.y);\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(pos.x+1,pos.y-1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n            float3 Normal = CalculateVertexNormals(_vWorld,V2_wPos,V1_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          //write output\n          output +=  float3(Normal.x,Normal.y,Normal.z);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,pos.y+1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n          float3 Normal = CalculateVertexNormals(_vWorld,V1_wPos,V2_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          output += float3(Normal.x,Normal.y,Normal.z);\n\n        \}\n      \}\n    \}\n  \}\n  return output;\n\}\n\n\n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 hitNormal = cross((V1 - V0),(V2 - V0)); \n        return hitNormal;\n\}\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float3 output = float3(0.0f);\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float3 point_pos = float3(_sample.x,_sample.y,_sample.z);\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n      dst() = float4(0.0f);\n      output+=facet_render(pos,float3(_sample.x,_sample.y,_sample.z))*2.0f;\n      _sample = ppos(pos.x-1,pos.y); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x-1,pos.y+1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y+1),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x,pos.y-1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x,pos.y-1),float3(_sample.x,_sample.y,_sample.z));\n\n      output = normalize(output);\n      float3 normal = -output;\n\n      \n\n\n      dst() = float4(normal.x,normal.y,normal.z,1.0f);\n    \}\n  \} //----> process\n\};\n"
   rebuild ""
   "PointRender3D_half Lambert" false
   PointRender3D_light_position {{parent.Axis1.translate} {parent.Axis1.translate} {parent.Axis1.translate}}
   PointRender3D_light_color {0 0 0}
   rebuild_finalise ""
   name BlinkScript1
   xpos 389
   ypos 344
  }
  Grade {
   multiply 0.5
   add 0.5
   black_clamp false
   name Grade1
   xpos 389
   ypos 376
   disable true
  }
  Output {
   name Output1
   xpos 389
   ypos 459
  }
  Axis2 {
   inputs 0
   translate {0.5 0.5 0.5}
   name Axis1
   xpos 661
   ypos 318
   addUserKnob {20 Ivy}
   addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
   addUserKnob {26 divider4 l "" +STARTLINE}
   addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
   _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
   addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
   addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
   addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
   _expressions {{curve}}
   addUserKnob {26 divider0 l "" +STARTLINE}
   addUserKnob {20 dbinfo l "DB Info" n 1}
   dbinfo 0
   addUserKnob {1 twig_dnuuid l "Twig Id"}
   addUserKnob {1 stalk_dnuuid l "Stalk Id"}
   addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
   addUserKnob {1 leaf_dnuuid l "Leaf Id"}
   addUserKnob {26 divider1 l "" +STARTLINE}
   addUserKnob {1 twigtype l "Twig Type"}
   addUserKnob {1 leaf_label l Leaf}
   addUserKnob {1 ivy_version l Version}
   addUserKnob {43 ivy_notes l Notes}
   addUserKnob {26 divider2 l "" +STARTLINE}
   addUserKnob {1 build_label l "Build Label"}
   addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
  }
 end_group
 Switch {
  inputs 2
  which {{parent.connect_aux}}
  name Switch3
  xpos -324
  ypos 498
 }
set N1d42bcf0 [stack 0]
push $N1d38a4b0
 Expression {
  temp_name0 xd
  temp_expr0 red-Camera1.world_matrix.3
  temp_name1 yd
  temp_expr1 green-Camera1.world_matrix.7
  temp_name2 zd
  temp_expr2 blue-Camera1.world_matrix.11
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  expr3 Distance
  name Expression1
  xpos -456
  ypos -192
 }
 Grade {
  channels rgba
  blackpoint {{parent.FogFar}}
  whitepoint {{parent.FogNear}}
  gamma {{1/(parent.FogExponent+0.000000001)}}
  white_clamp true
  name Grade1
  xpos -456
  ypos -168
 }
push $N1d31a020
 Dot {
  name Dot7
  xpos -307
  ypos -513
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge1
  xpos -341
  ypos -168
  disable {{!parent.Fog}}
 }
 Shuffle {
  name Shuffle3
  xpos -341
  ypos 8
 }
set N1d468050 [stack 0]
 Shuffle {
  red white
  green white
  blue white
  name Shuffle2
  xpos -28
  ypos 76
 }
push $N1d3b46f0
 BlinkScript {
  inputs 4
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Render/3D_PointRender_v18.cpp
  recompileCount 806
  ProgramGroup 1
  KernelDescription "2 \"PointRender3D\" iterate pixelWise b6c79b641c58390f32c944e2b5792a8702107f9cfc926636430288e7e0e1b392 5 \"ppos\" Read Random \"src\" Read Random \"normals\" Read Random \"occlusion\" Read Random \"dst\" Write Random 50 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"vertexformat\" Int 2 CgAAAAoAAAA= \"Zoom\" Float 1 AACAPw== \"Filtering Method\" Int 1 AQAAAA== \"_alphaMultiplier\" Float 1 AACAPw== \"_pointRender\" Bool 1 AQ== \"_wireRender\" Bool 1 AQ== \"_facetRender\" Bool 1 AQ== \"_maxLDistance\" Float 1 AACAPw== \"_maxLConnections\" Int 1 AQAAAA== \"_maxPlexType\" Int 1 AAAAAA== \"_plexLinedefXY\" Bool 1 AA== \"_plexLinedefX\" Bool 1 AA== \"_plexLinedefY\" Bool 1 AA== \"_plexLinedefXtoY\" Bool 1 AA== \"_plexLinedefAUX\" Bool 1 AA== \"_plexConnectX\" Bool 1 AA== \"_plexConnectY\" Bool 1 AA== \"_L_gamma\" Float 1 AACAPw== \"Enable Depth of Field\" Bool 1 AA== \"samples\" Int 1 AwAAAA== \"rings\" Int 1 BQAAAA== \"focalDepth\" Float 1 AACAPw== \"_depthOfField\" Float 1 AACAQA== \"_depthMult\" Float 1 zczMPQ== \"_maxDofSize\" Float 1 AAAAQQ== \"dof_aspect\" Float 1 AACAPw== \"dof_threshold\" Float 1 AACAPw== \"dof_gain\" Float 1 AAAAAA== \"dof_bias\" Float 1 AAAAwA== \"dof_fringe\" Float 1 AAAAAA== \"_flatshading\" Bool 1 AQ== \"_backfacing\" Bool 1 AQ== \"_frontfacing\" Bool 1 AQ== \"_vertexMode\" Int 1 AAAAAA== \"_depthBuffer\" Bool 1 AQ== \"_texoffset\" Float 2 AAAAPwAAAD8= \"_pointSize\" Int 1 AQAAAA== \"_gaussigma\" Float 1 AACAPw== \"_depthOcclusion\" Bool 1 AQ== \"depthMultiplier\" Float 1 AACAPw== \"_maxLineSteps\" Float 1 AAB6RQ== \"_lineOffset\" Float 1 AACAPw== \"_lineInMultiplier\" Float 1 AACAPw== \"_lineOutMultiplier\" Float 1 AACAPw== \"_overscan\" Float 2 AAAAAAAAAAA= \"isDepth\" Bool 1 AA== 50 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"Vformat\" 2 1 \"zoom\" 1 1 \"_filtering\" 1 1 \"_alphaMultiplier\" 1 1 \"_pointRender\" 1 1 \"_wireRender\" 1 1 \"_facetRender\" 1 1 \"_maxPlexDistance\" 1 1 \"_maxPlexConnections\" 1 1 \"_maxPlexType\" 1 1 \"_plexLinedefXY\" 1 1 \"_plexLinedefX\" 1 1 \"_plexLinedefY\" 1 1 \"_plexLinedefXtoY\" 1 1 \"_plexLinedefAUX\" 1 1 \"_plexConnectX\" 1 1 \"_plexConnectY\" 1 1 \"_plex_gamma\" 1 1 \"_dof_enable\" 1 1 \"_dof_samples\" 1 1 \"_dof_rings\" 1 1 \"focalDepth\" 1 1 \"_depthOfField\" 1 1 \"_depthMult\" 1 1 \"_maxDofSize\" 1 1 \"dof_aspect\" 1 1 \"dof_threshold\" 1 1 \"dof_gain\" 1 1 \"dof_bias\" 1 1 \"dof_fringe\" 1 1 \"_flatshading\" 1 1 \"_backfacing\" 1 1 \"_frontfacing\" 1 1 \"_vertexMode\" 1 1 \"_depthBuffer\" 1 1 \"_texoffset\" 2 1 \"_pointSize\" 1 1 \"_gaussigma\" 1 1 \"_depthOcclusion\" 1 1 \"depthMultiplier\" 1 1 \"_maxLineSteps\" 1 1 \"_lineOffset\" 1 1 \"_lineInMultiplier\" 1 1 \"_lineOutMultiplier\" 1 1 \"_overscan\" 2 1 \"isDepth\" 1 1 10 \"max_line_connections\" Int 1 1 AAAAAA== \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "//Some basic generic functions.\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float3 Cross(float3 A,float3 B)\n\{\n    return float3(A.y*B.z - A.z*B.y,A.z*B.x - A.x*B.z,A.x*B.y - A.y*B.x);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}     \n\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\ninline float mix(float _X,float _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}                                                                                              \n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n\n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight,\n    float2 overscan\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f-overscan.x || pRaster.x > imageWidth+overscan.x || \n       pRaster.y < 0.0f-overscan.y || pRaster.y > imageHeight+overscan.y || pRaster.z < 0.0f) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eRead, eAccessRandom, eEdgeClamped> src;     //The texture map\n  Image<eRead, eAccessRandom, eEdgeClamped> normals;     //The texture map  \n  Image<eRead, eAccessRandom, eEdgeClamped> occlusion;     //The texture map \n  Image<eWrite, eAccessRandom> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat,Vformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    int _filtering;        //Filter method\n    float _alphaMultiplier; //Additive multiplier\n    bool _pointRender,_wireRender,_facetRender;\n    float _maxPlexDistance; //Additive multiplier\n    int _maxPlexConnections;\n    int _maxPlexType; // 0==Grid, -1==Nearest\n    bool _plexLinedefXY,_plexLinedefX,_plexLinedefY,_plexLinedefXtoY,_plexLinedefAUX; // Define what connections NOT to include\n    bool _plexConnectX,_plexConnectY; //Connect from the edge of x to 0, or edge of y to 0, usually for spheres\n    float _plex_gamma; //The threshold making shorter paths bright and longer paths dark\n    bool _dof_enable; // Enable DOF\n    int _dof_samples; // How many samples per DOF ring\n    int _dof_rings; // How many rings \n    float focalDepth,_depthOfField,_depthMult,_maxDofSize; //DOF Settings\n    float dof_aspect; //Pixel aspect ratio\n    float dof_threshold;\n    float dof_gain;\n    float dof_bias; //bokeh edge bias\n    float dof_fringe; //bokeh chromatic aberration/fringing\n    bool _flatshading,_backfacing,_frontfacing; //Vertex rendering settings\n    int _vertexMode;  //The rendering output mode, (think AOV)\n    bool _depthBuffer; //Non-additive, only render front most pixel\n    float2 _texoffset;\n    int _pointSize;\n    float _gaussigma;\n    bool _depthOcclusion;\n    float depthMultiplier;\n    float _maxLineSteps; //cap the line length to avoid process lock\n    float _lineOffset; //Alow you to shrink or extend the lines\n    float _lineInMultiplier,_lineOutMultiplier; //Control the brightness of the wires at the tips.\n    float2 _overscan; //This will allow you to render some extra outside the bounds of the image.\n    bool isDepth; //This will allow you to render some extra outside the bounds of the image.\n\n  local: //Local variables\n    int max_line_connections;\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(Vformat,      \"vertexformat\", int2(10,10));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(_filtering, \"Filtering Method\", 1); \n    defineParam(_alphaMultiplier, \"_alphaMultiplier\", 1.0f);     \n    defineParam(_pointRender, \"_pointRender\", true);  \n    defineParam(_wireRender, \"_wireRender\", true);\n    defineParam(_facetRender, \"_facetRender\", true);\n    defineParam(_maxPlexDistance, \"_maxLDistance\", 1.0f);    \n    defineParam(_maxPlexConnections, \"_maxLConnections\", 1);    \n    defineParam(_maxPlexType, \"_maxPlexType\", 0); \n    defineParam(_plexLinedefXY, \"_plexLinedefXY\", false);      \n    defineParam(_plexLinedefXtoY, \"_plexLinedefXtoY\", false); //NYI\n    defineParam(_plexLinedefAUX, \"_plexLinedefAUX\", false); \n    defineParam(_plexLinedefX, \"_plexLinedefX\", false);  \n    defineParam(_plexLinedefY, \"_plexLinedefY\", false);  \n    defineParam(_plexConnectX, \"_plexConnectX\", false);      \n    defineParam(_plexConnectY, \"_plexConnectY\", false);   \n    defineParam(_plex_gamma, \"_L_gamma\", 1.0f);\n    //DOF SETTINGS   \n    defineParam(_dof_enable, \"Enable Depth of Field\", false);   \n    defineParam(_dof_samples, \"samples\", 3);    \n    defineParam(_dof_rings, \"rings\", 5);   \n    defineParam(focalDepth, \"focalDepth\", 1.0f);  \n    defineParam(_depthOfField, \"_depthOfField\", 4.0f);  \n    defineParam(_depthMult, \"_depthMult\", 0.1f);  \n    defineParam(_maxDofSize, \"_maxDofSize\", 8.0f);  \n    defineParam(dof_aspect, \"dof_aspect\", 1.0f);  \n    defineParam(dof_threshold, \"dof_threshold\", 1.0f);  \n    defineParam(dof_gain, \"dof_gain\", 0.0f);  \n    defineParam(dof_bias, \"dof_bias\", -2.0f);  \n    defineParam(dof_fringe, \"dof_fringe\", 0.0f); \n    //SHADING SETTINGS \n    defineParam(_flatshading, \"_flatshading\", true);  \n    defineParam(_vertexMode, \"_vertexMode\", 0);  \n    defineParam(_backfacing, \"_backfacing\", true);    \n    defineParam(_frontfacing, \"_frontfacing\", true);        \n    defineParam(_depthBuffer, \"_depthBuffer\", true);  \n    defineParam(_texoffset, \"_texoffset\", float2(0.5f,0.5f)); \n    defineParam(_pointSize, \"_pointSize\", 1); \n    defineParam(_gaussigma, \"_gaussigma\", 1.0f); \n    defineParam(_depthOcclusion, \"_depthOcclusion\", true); \n    defineParam(depthMultiplier, \"depthMultiplier\", 1.0f); \n    defineParam(_maxLineSteps, \"_maxLineSteps\", 4000.0f); \n    defineParam(_lineOffset, \"_lineOffset\", 1.0f); \n    defineParam(_lineInMultiplier, \"_lineInMultiplier\", 1.0f);   \n    defineParam(_lineOutMultiplier, \"_lineOutMultiplier\", 1.0f);     \n    defineParam(_overscan, \"_overscan\",float2(0.0f,0.0f));    \n\n  \}\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    max_line_connections = 80;\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n  \}\n\n  //Convert a 3d point position into a 2d raster position.\n  float3 Reconsile3D(float3 _PointPos)\{\n      vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      return tRaster;\n  \}\n\n//------------------------------\n//-------DRAW FUNCTIONS---------\n//------------------------------\n  //Write pixels to output.\n  void writepixel(float posx,float posy, float4 color,int index,float weight=1.0f)\n  \{ \n      if (_depthOcclusion)\{\n        float4 depthSample = occlusion(posx,posy);\n        if (depthSample.x<=vRaster.z && depthSample.w>0.0f)\{\n\n          float depth = (vRaster.z-depthSample.x);\n          color = color*(1.0f-depthSample.w);\n          color = color / (((depth*depth)*depthMultiplier)+1.0f);\n          //return;\n        \}\n      \}\n      float4 finalOutput; //This is used to store the final output\n      float4 dstSample; //This is used to store a sample of the destination\n      if ( dst.bounds.inside( posx, posy ) ) \{ //Test if the pixel written to is inside the output image. \n        if (_depthBuffer) \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          if ((dstSample.w>color.w)||dstSample.w==0.0f) \{\n            dst(posx,posy) = color;\n          \}\n        \}\n        else \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          finalOutput = dstSample + (color*_alphaMultiplier*weight);\n          finalOutput.w = dstSample.w + ((color.w*_alphaMultiplier*weight));\n\n          finalOutput.w = (dstSample.w + ((color.w*_alphaMultiplier*weight)))-(dstSample.w * ((color.w*_alphaMultiplier*weight)));\n\n          dst(posx,posy) = finalOutput;\n        \}\n      \} \n  \}\n\n  //Calculate a Bilinear Plot\n  void bilinear_Plot(float2 temppos,float4 color,int index)\n  \{\n    float2 p;\n    p.x=Frac(temppos.x);\n    p.y=Frac(temppos.y);\n    float weights\[] = \{(1.0f-p.x)*(1.0f-p.y), p.x*(1.0f-p.y), (1.0f-p.x)*p.y, p.x*p.y\};\n    int2 _position = int2(floor(temppos.x)-0,floor(temppos.y)-0); \n    writepixel(_position.x,_position.y,color,index,weights\[0]);\n    writepixel(_position.x+1,_position.y,color,index,weights\[1]);\n    writepixel(_position.x,_position.y+1,color,index,weights\[2]);\n    writepixel(_position.x+1,_position.y+1,color,index,weights\[3]);\n  \}\n\n  //NYI, unused!\n  void gaussian(float2 temppos,float4 color,int index)\{\n    float in_x = temppos.x;\n    float in_y = temppos.y;\n    int kernelSize = (_pointSize+1)*2;\n    int subsize = (kernelSize /2)-1;\n    float gKernel\[64]\[64];\n    float sigma = _gaussigma;\n    float intSigma = float(_pointSize);\n    float r, s = intSigma * sigma * sigma;\n\n    float sum = 0.0f;\n\n    // generate 5x5 kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            r = float(sqrt(x*x + y*y));\n            gKernel\[x + subsize]\[y + subsize] = (exp(-(r*r)/s))/(3.141592654f * s);\n            sum += gKernel\[x + subsize]\[y + subsize];\n        \}\n    \}\n\n    // normalize the Kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            gKernel\[x + subsize]\[y + subsize] /= sum;\n            writepixel(in_x+x,in_y+y,color,index,gKernel\[x + subsize]\[y + subsize]);\n        \}\n    \}\n  \}\n\n//-------------------------------------\n// DrawLine\n// ----------\n// Draw a line between two points, \n// x,y being 2d screenspace pos and z being depth.\n//-------------------------------------\n  void DrawLine(float3 origin, float3 endpoint,float4 _colorA,float4 _colorB) \{\n    float4 _color;\n    float3 delta = origin-endpoint;\n    float3 curPoint = origin;\n    float mag = sqrt(delta.x*delta.x+delta.y*delta.y);\n    mag = min(mag,_maxLineSteps); //Lets not go crazy, we cap it at 10.000 to avoid insane unwated processing time \n    for( float a = 0; a < mag*_lineOffset; a = a + 1.0f )\{\n      curPoint -= (delta/mag);\n      _color = (_colorA*(1.0f-(a/mag*1.0f)))+(_colorB*(a/mag*1.00f));\n      if (_dof_enable)\{\n        Bokeh(curPoint,_color);\n      \}\n      else \{\n        if (_depthBuffer && isDepth) \{_color = float4(1.0f,1.0f,1.0f,curPoint.z);\} //Added\n        bilinear_Plot(float2(curPoint.x,curPoint.y),_color,1);\n      \}\n      \n    \}\n  \}\n\n//-------------------------------------\n// Point_Render\n//-------------------------------------\nvoid point_render(int2 pos, float3 screen_pos)\{\n  float4 color = src(pos.x,pos.y);\n\n  if (_filtering == 1)\{\n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        if (_depthBuffer) \{color.w = screen_pos.z;\} //Added\n        bilinear_Plot(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  /*\n  //THIS PART NEEDS TO BE RE-WRITTEN.\n  else if (_filtering == 2)\{ \n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        gaussian(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  */\n  else \{\n      int2 _position = int2(floor(screen_pos.x),floor(screen_pos.y)); \n      if (_depthBuffer) \{color.w = screen_pos.z;\}\n      writepixel(_position.x,_position.y, color,1,1.0f); //OutputSample\n  \}\n\n\}\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nvoid facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x+1,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos,V0_N,V1_N,V2_N;\n    float2 V0_ST,V1_ST,V2_ST;\n    float4 V1_Sample,V2_Sample;\n    float4 _tn;\n    float3 normal0,normal1,normal2;\n    float2 UV_Format = float2(Vformat.x,Vformat.y);\n\n\n    int2 P0 = int2(pos.x-1,pos.y-1);\n    int2 P1 = int2(pos.x+1,pos.y+1);\n    if (_plexConnectX && pos.x == int(Vformat.x))\{\n      insideX == true;\n      P1 = int2(0.0f,pos.y+1);\n    \}\n    if (_plexConnectY && pos.y == int(Vformat.y))\{\n      insideYtop == true;\n      P1 = int2(pos.x+1,0);\n    \} \n\n    if (_plexConnectY && pos.y == 0)\{\n      insideY == true;\n      P0 = int2(pos.x-1,int(UV_Format.y));\n    \} \n\n    if (!_flatshading) \{\n      _tn = normals(pos.x,pos.y);\n      V0_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n    V0_ST = float2(pos.x,pos.y)/UV_Format;\n\n  if (insideX) \{\n    V2_Sample = ppos(P1.x,pos.y);\n    V2_ST = float2(P1.x,pos.y)/UV_Format;\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (!_flatshading) \{\n      _tn = normals(P1.x,pos.y);\n      V2_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n        \n\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(P1.x,P0.y);\n        V1_ST = float2(P1.x,P0.y)/UV_Format;\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(P1.x,P0.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}\n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V2_Pos,V1_Pos,_vWorld,V2_wPos,V1_wPos,V0_N,V2_N,V1_N,V0_ST,V2_ST,V1_ST);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,P1.y);\n        V1_ST = float2(pos.x,P1.y)/UV_Format;        \n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(pos.x,P1.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}        \n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V1_Pos,V2_Pos,_vWorld,V1_wPos,V2_wPos,V0_N,V1_N,V2_N,V0_ST,V1_ST,V2_ST);\n        \}\n      \}\n    \}\n  \}\n\}\n\n\n\n//This function will calculate if pixel C is inside the triangle\nfloat edgeFunction(float3 a, float3 b, float3 c) \n\{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n\} \n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat Distance(float3 _a,float3 _b)\n\{\n          float xd = _a.x - _b.x;\n          float yd = _a.y - _b.y;\n          float zd = _a.z - _b.z;\n          return sqrt(xd*xd + yd*yd + zd*zd);\n\}\n\nvoid DrawTriangle(float3 V0, float3 V1, float3 V2,float3 WP0, float3 WP1, float3 WP2,float3 N0, float3 N1, float3 N2, float2 st0,float2 st1,float2 st2) \{\n\n  // Precompute reciprocal of vertex z-coordinate \n  V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n\n  float2 st0n = st0 * V0.z;\n  float2 st1n = st1 * V1.z; \n  float2 st2n = st2 * V2.z; //Normal version of ST\n\n  bool inside; \n  float X0 = Fmin(V0.x,V1.x,V2.x)-1.0f;\n  float X1 = Fmax(V0.x,V1.x,V2.x)+1.0f;\n  float Y0 = Fmin(V0.y,V1.y,V2.y)-1.0f;\n  float Y1 = Fmax(V0.y,V1.y,V2.y)+1.0f;\n  float area = edgeFunction(V2, V1, V0);\n\n\n  float2 sampos = float2(st0.x*float(Vformat.x),st0.y*float(Vformat.y));\n  float4 text0 = src(sampos.x,sampos.y);\n  sampos = float2(st1.x*float(Vformat.x),st1.y*float(Vformat.y));\n  float4 text1 = src(sampos.x,sampos.y);\n  sampos = float2(st2.x*float(Vformat.x),st2.y*float(Vformat.y));  //Why do we have to do this? =(\n  float4 text2 = src(sampos.x,sampos.y);\n  sampos = float2(min(min(st0.x,st1.x),st2.x)*float(Vformat.x),min(min(st0.y,st1.y),st2.y)*float(Vformat.y));\n  float4 text3 = src(sampos.x,sampos.y);\n\n\n  for( int x = X0; x < X1 ; x++) \{\n    for( int y = Y0; y < Y1 ; y++) \{\n      float3 pixelSample(x + _texoffset.x, y + _texoffset.y,0.0f); \n\n      //This is the part where we test if the current pixel is inside the triangle\n      //We check both for front facing and back faing options\n      float w0 = edgeFunction(V1, V0, pixelSample); //Front Facing\n      float w1 = edgeFunction(V2, V1, pixelSample); \n      float w2 = edgeFunction(V0, V2, pixelSample); \n      float w3 = edgeFunction(V0, V1, pixelSample); //Back Facing\n      float w4 = edgeFunction(V1, V2, pixelSample); \n      float w5 = edgeFunction(V2, V0, pixelSample);\n\n      //writepixel(x,y, float4(w1),1,1.0f);\n      if ((w0 >= 0 && w1 >= 0 && w2 >= 0 && _frontfacing) || (w3 >= 0 && w4 >= 0 && w5 >= 0 && _backfacing)) \{ //The curent pixel is inside the triangle\n\n       // calculate vectors from point f to vertices p1, p2 and p3:\n       float3 f1 = V0-pixelSample;\n       float3 f2 = V1-pixelSample;\n       float3 f3 = V2-pixelSample;\n       // calculate the areas and factors (order of parameters doesn't matter):\n       float a = length(cross(V0-V1,V0-V2 )); // main triangle area a\n       area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n        w0 /= area; \n        w1 /= area; \n        w2 /= area; \n\n        w3 /= area; \n        w4 /= area; \n        w5 /= area; \n\n       float a1 = length(cross(f2, f3)) / a; // p1's triangle area / a\n       float a2 = length(cross(f3, f1)) / a; // p2's triangle area / a \n       float a3 = length(cross(f1, f2)) / a; // p3's triangle area / a\n       float a_magnitude = a1+a2+a3;\n       a1 = a1/a_magnitude;\n       a2 = a2/a_magnitude;\n       a3 = a3/a_magnitude;\n       float z = 1.0f / (V0.z * a1 + V1.z * a2 + V2.z * a3); \n\n\n        // find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):\n        float2 uv = st0 * a1 + st1 * a2 + st2 * a3;\n        float2 st = st0 * w0 + st1 * w1 + st2 * w2; \n        st *= z;      \n\n\n        //Calculate normals. Eighter we have flat shading, else we calculate a normal per pixel\n        float3 normalB;\n        if (_flatshading) \{\n          normalB = CalculateSurfaceNormals(WP0,WP1,WP2);\n\n        \}\n        else \{\n          float3 c0 = N2/float3(V0.z); \n          float3 c1 = N0/float3(V1.z); \n          float3 c2 = N1/float3(V2.z);  \n\n          normalB.x = w0 * c0.x + w1 * c1.x + w2 * c2.x; \n          normalB.y = w0 * c0.y + w1 * c1.y + w2 * c2.y; \n          normalB.z = w0 * c0.z + w1 * c1.z + w2 * c2.z; \n\n          normalB.x *= z, normalB.y *= z, normalB.z *= z; \n        \}\n        normalB = normalize(normalB);\n\n        //CALCULATE THE OBJECT TEXTURE COORDINATES\n        float zn = 1.0f / (V0.z * w0 + V1.z * w1 + V2.z * w2); \n        st = st0n * w0 + st1n * w1 + st2n * w2; \n        st *= zn;   \n        //--END \n\n        float3 Wpos = WP0*a1 + WP1*a2 + WP2*a3; //World Position.\n        float3 ViewNormal = normalize(float3(cameraToWorld\[3]\[0],cameraToWorld\[3]\[1],cameraToWorld\[3]\[2])-Wpos);\n\n        float nDotView =  dot(normalB,ViewNormal);\n        nDotView = 1.0f-fabs(nDotView); //make sure that the view normal ramps back around when doing backface\n        float4 tempout;\n\n        //Flatshading or regular?\n        if (!_flatshading) \{\n          tempout = text0 * a1 + text1 * a2 + text2 * a3; \n        \}\n        else\{\n          tempout = text3;\n        \}\n\n        //Additional Render Modes\n        if (_vertexMode == 1)\{\n          tempout = float4(a1,a2,a3,1.0f);\n        \}\n        else if (_vertexMode == 2)\{\n          tempout = float4(normalB.x,normalB.y,normalB.z,1.0f);\n        \}\n        else if (_vertexMode == 3)\{\n          tempout = float4(nDotView,nDotView,nDotView,1.0f);\n        \}\n        else if (_vertexMode == 4)\{\n          tempout = float4(uv.x,uv.y,0.0f,1.0f);\n        \}       \n        else if (_vertexMode == 5)\{\n          tempout = float4(st.x,st.y,0.0f,1.0f);\n        \}               \n        else if (_vertexMode == 6)\{\n          tempout = float4(ViewNormal.x,ViewNormal.y,ViewNormal.z,1.0f);\n        \}             \n        else if (_vertexMode == 7)\{\n          tempout = float4(Wpos.x,Wpos.y,Wpos.z,1.0f);\n        \}   \n\n        if (_depthBuffer)\{\n          writepixel(x,y, float4(tempout.x,tempout.y,tempout.z,z),1,1.0f);  \n        \}\n        else \{\n          if (_dof_enable)\{\n            Bokeh(float3(x,y,z),float4(tempout.x,tempout.y,tempout.z,z));\n          \}\n          else \{\n            bilinear_Plot(float2(x,y),float4(tempout.x,tempout.y,tempout.z,z),1);\n          \}\n        \}\n\n      \}  \n\n    \}\n  \}\n\}\n\n//-------------------------------------\n// Wire_Render\n//-------------------------------------\nvoid wire_render(int2 pos) \{\n  float4 temp = float4(0.0f,0.0f,0.0f,FLT_MAX);\n  float4 wire_ref_sample;\n  int2 tempXY = int2(0,0);\n  float4 plexlist\[11] = \{temp,temp,temp,temp,temp,temp,temp,temp,temp,temp,temp\}; \n  int2 plexlistXY\[11] = \{tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY\};\n  int plex_count = 0; //We use this to figure how many points that should connect.\n  float plex_dist;\n  float3 plex_position,plex_position_b;\n  float4 temp_pos, temp_pos_b; //Temporary Position Containers\n  if (_maxPlexType == -1) \{ //Used for random connection types\n    for( int x = 0; x < max_line_connections ; x++)\{ //THIS 80 NUMBER IS THE LIMIT TO AVOID TOO SLOW PROCESSING!\n      for( int y = 0; y < max_line_connections ; y++)\{\n        wire_ref_sample = ppos(x,y);\n        if (wire_ref_sample.w != 0.0f && pos.x!=x && pos.y != y) \{ \n          plex_position = float3(wire_ref_sample.x,wire_ref_sample.y,wire_ref_sample.z)*(zoom);\n          float xd = plex_position.x - vWorld.x;\n          float yd = plex_position.y - vWorld.y;\n          float zd = plex_position.z - vWorld.z;\n          float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n          if (plex_dist<_maxPlexDistance)\{\n            plex_count = min(10,plex_count+1); //Add one to the count\n            for( int h = 0; h < plex_count+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n              if (plex_dist < plexlist\[h].w) \{                  \n                for( int i = plex_count+1; i > h ; i--) \{\n                  plexlist\[i] = plexlist\[i-1];\n                  plexlistXY\[i] = plexlistXY\[i-1];\n                \}\n                plexlist\[h] = float4(plex_position.x,plex_position.y,plex_position.z,plex_dist);\n                plexlistXY\[h] = int2(x,y);\n                break;        \n              \}\n            \}\n          \} \n        \}\n      \}\n    \}\n  \}\n  else\{ //Used for standard connection types\n    float4 temp_pos;\n    bool insideX = !(Vformat.x < pos.x+1);\n    bool insideY = !(Vformat.y < pos.y+1);\n\n\n    if (!_plexLinedefAUX)\{\n      temp_pos = normals(pos.x,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,vWorld+plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideX && !_plexLinedefX) \{\n      temp_pos = ppos(pos.x+1,pos.y );\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && !_plexLinedefX) \{\n      temp_pos = ppos(0,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideY && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\}                          \n    \}\n    else if ( _plexConnectY  && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,0);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    //_plexConnect\n    if ( insideX && insideY && !_plexLinedefXY) \{              \n      temp_pos = ppos(pos.x+1,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && _plexConnectY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && insideY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectY && insideX && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n  \}   \n\n  //now that all the connections have been sorted by distance then we connect the dots.\n  for( int x = 0; x < min(_maxPlexConnections,plex_count) ; x++)\{\n    plex_position = float3(plexlist\[x].x,plexlist\[x].y,plexlist\[x].z);\n    plex_dist = plexlist\[x].w;\n\n\n    float plex_distribution = 1.0f-((plexlist\[x].w-plexlist\[0].w)/((plexlist\[min(_maxPlexConnections,plex_count)].w-plexlist\[0].w)+0.00001f)); //Where does it lie between the best and the worst distance?\n    //plexlistXY\n\n    float4 plex_col = float4(pow(1.0f-(plex_dist/_maxPlexDistance),1.0f/_plex_gamma))*float4(plex_distribution); //This one is quite cool aswell, but does leave the center ones a bit too focused \n    float4 plex_colorA = src(pos.x,pos.y);\n    float4 plex_colorB = src( plexlistXY\[x].x,plexlistXY\[x].y);\n    plex_col *= 0.1f;\n\n    computePixelCoordinates(plex_position, pRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n    if (dst.bounds.inside(int(vRaster.x),int(vRaster.y)) || dst.bounds.inside(int(pRaster.x),int(pRaster.y)))\{\n        DrawLine(vRaster,pRaster,(plex_colorA*plex_col)*_lineInMultiplier,(plex_colorB*plex_col)*_lineOutMultiplier);\n    \}\n  \}\n\}\n\nvoid wire_connection(float3 p_source,float3 p_target, float4 (&p_plexlist)\[11], int2 (&p_plexlistXY)\[11],int &p_plexcount,int2 position) \{\n  float xd = p_target.x - p_source.x;\n  float yd = p_target.y - p_source.y;\n  float zd = p_target.z - p_source.z;\n  float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n  if (plex_dist<_maxPlexDistance)\{\n    p_plexcount = min(11,p_plexcount+1); //Add one to the count\n    for( int h = 0; h < p_plexcount+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n      if (plex_dist < p_plexlist\[h].w) \{                  \n        for( int i = p_plexcount+1; i > h ; i--) \{\n          p_plexlist\[i] = p_plexlist\[i-1];\n          p_plexlistXY\[i] = p_plexlistXY\[i-1];\n        \}\n        p_plexlist\[h] = float4(p_target.x,p_target.y,p_target.z,plex_dist);\n        p_plexlistXY\[h] = int2(position.x,position.y);\n        break;        \n      \}\n    \}  \n  \}\n\}\n//-------END OF WIRE RENDER FUNCTIONS---------\n\n\n\n\n//-------------------------------\n//-------BOKEH FUNCTIONS---------\n//thanks to: http://devlog-martinsh.blogspot.dk/2011/11/glsl-depth-of-field-with-bokeh-v21.html\nfloat2 rand(float2 coord) //generating noise/pattern texture for dithering\n\{\n  float noiseX = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.25)+(Frac(coord.y*(WHformat\[1]/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.75)+(Frac(coord.y*(WHformat\[1]/2.0))*0.25))*2.0-1.0;\n  noiseX = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f))) * 43758.5453f),0.0f,1.0f)*2.0f-1.0f;\n  noiseY = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f)*2.0f)) * 43758.5453f),0.0f,1.0f)*2.0-1.0f;\n  return float2(noiseX,noiseY);\n\}\n//-------------------------------------\n// Bokeh\n//-------------------------------------\nvoid Bokeh(float3 pos,float4 color)\{\n  float blur = 0.0;\n  blur = clamp((fabs(pos.z - focalDepth)/_depthOfField)*100.0f,-_maxDofSize,_maxDofSize);\n  \n  float w = (1.0/WHformat.x)*blur;//+noise.x;\n  float h = (1.0/(WHformat.x*dof_aspect))*blur;//+noise.y;\n  float3 v3_col = float3(color.x,color.y,color.z);\n  int ringsamples;\n  float s = 1.0;  \n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples; \n    for (int j = 0 ; j < ringsamples ; j += 1)  \n    \{ \n      s += (1.0f*mix(1.0f,(float(i))/(float(_dof_rings)),dof_bias)*1.0f); //No need to do this in the loop\n    \}\n  \}\n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples;\n     \n    for (int j = 0 ; j < ringsamples ; j += 1)   \n    \{\n      float step = PI*2.0 / float(ringsamples);\n      float pw = (cos(float(j)*step)*(float(i)/_dof_rings));\n      float ph = (sin(float(j)*step)*(float(i)/_dof_rings));\n      float p = 1.0;\n\n      float posx = pos.x+((pw*w)*blur);\n      float posy = pos.y+((ph*h)*blur);\n\n\n      float3 lumcoeff = float3(0.299,0.587,0.114);\n      float lum = dot(v3_col, lumcoeff);\n      float thresh = max((lum-dof_threshold)*dof_gain, 0.0f);\n      v3_col+mix(float3(0.0),v3_col,thresh*blur);\n\n      float3 col = (v3_col*mix(1.0,(float(i))/(float(_dof_rings)),dof_bias)*p)/s; \n      bilinear_Plot(float2(posx,posy),float4(col.x,col.y,col.z,color.w/(_dof_rings*_dof_rings)),1);\n    \}\n  \}\n\}\n//-------END OF BOKEH FUNCTIONS---------\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float2 posf = float2(pos.x,pos.y);\n\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n\n      //Convert worldspace coordinates to screenspcace coordinates.\n      vWorld = float3(_sample.x,_sample.y,_sample.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, vRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      if (ret) \{ //Only create points that are visible on screen\n        if (_pointRender)\{\n          point_render(pos,vRaster);\n        \}\n      \} //Pointrender over\n\n      if (_wireRender && _maxPlexConnections>=1) \{\n        if (max(pos.x,pos.y)<=max_line_connections || (_maxPlexType==0))\{ // Don't process more wires than allowed in nearest mode.\n          wire_render(pos);\n        \}\n      \} //WireRender over\n\n      if (_facetRender) \{\n        facet_render(pos,float3(_sample.x,_sample.y,_sample.z));\n      \}  //FacetRender over\n      \n    \}\n  \} //----> process\n\};\n"
  useGPUIfAvailable false
  rebuild ""
  PointRender3D_cam_Matrix {
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
    }
  PointRender3D_focallength {{parent.Camera1.focal}}
  PointRender3D_hapeture {{parent.Camera1.haperture}}
  PointRender3D_format {{!proxy?Settings_Format.width:Settings_Format.width*proxy_scale} {!proxy?Settings_Format.height:Settings_Format.height*proxy_scale}}
  PointRender3D_vertexformat {{parent.InputFormat.box.r-1} {parent.InputFormat.box.t-1}}
  PointRender3D__alphaMultiplier {{parent.AlphaMultiplier}}
  PointRender3D__pointRender {{parent.RenderMode==0}}
  PointRender3D__wireRender {{parent.RenderMode==1}}
  PointRender3D__facetRender {{parent.RenderMode==2}}
  PointRender3D__maxLDistance {{parent.wire_maxdistance}}
  PointRender3D__maxLConnections {{parent.wire_connections}}
  PointRender3D__maxPlexType {{-parent.wire_type}}
  PointRender3D__plexLinedefXY {{!parent.connect_xy}}
  PointRender3D__plexLinedefX {{!parent.connect_x}}
  PointRender3D__plexLinedefY {{!parent.connect_y}}
  PointRender3D__plexLinedefAUX {{!connect_aux}}
  PointRender3D__plexConnectX {{parent.CloseX}}
  PointRender3D__plexConnectY {{parent.CloseY}}
  PointRender3D__L_gamma {{parent.wire_Threshold}}
  "PointRender3D_Enable Depth of Field" {{parent.dof_enable}}
  PointRender3D_samples {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_rings {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_focalDepth {{parent.dof_focaldepth}}
  PointRender3D__depthOfField {{parent.dof_dof}}
  PointRender3D__depthMult 0
  PointRender3D__maxDofSize {{parent.dof_maxSize*400}}
  PointRender3D_dof_aspect {{parent.dof_Aspect}}
  PointRender3D_dof_bias {{parent.dof_bias}}
  PointRender3D__flatshading {{parent.facet_flatShading}}
  PointRender3D__backfacing {{parent.facet_backface}}
  PointRender3D__frontfacing {{parent.facet_front}}
  PointRender3D__vertexMode {{parent.renderMode}}
  PointRender3D__texoffset {-0.5 0.5}
  PointRender3D__pointSize 0
  PointRender3D__depthOcclusion {{parent.UseOcclusionMap}}
  PointRender3D__maxLineSteps {{parent.maxSamples}}
  PointRender3D__lineOffset {{parent.lineoffset}}
  PointRender3D__lineInMultiplier {{parent.inGain}}
  PointRender3D__lineOutMultiplier {{parent.outGain}}
  PointRender3D__overscan {{parent.overscan} {parent.overscan}}
  PointRender3D_isDepth true
  format "1280 720 0 0 1280 720 1 HD_720"
  rebuild_finalise ""
  name BlinkScriptZdepth
  label Zdepth
  xpos -28
  ypos 100
 }
 Dot {
  name Dot10
  xpos 97
  ypos 112
 }
 TimeBlur {
  divisions {{parent.Samples}}
  shutter {{parent.Shutter}}
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur1
  xpos 63
  ypos 300
  disable {{1-parent.mb_enable x89 0}}
 }
 Expression {
  expr3 a!=0?a/r:0
  name Expression3
  selected true
  xpos 63
  ypos 324
 }
 Dot {
  name Dot9
  xpos 97
  ypos 414
 }
push $N1d363a50
push $N1d42bcf0
push $N1d468050
push $N1d3b46f0
 BlinkScript {
  inputs 4
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Render/3D_PointRender_v17.cpp
  recompileCount 803
  ProgramGroup 1
  KernelDescription "2 \"PointRender3D\" iterate pixelWise 0c100cf8a634aa2c2e18f544ec8abfd6d5d138cc25ae8f7d7127230910c2e91f 5 \"ppos\" Read Random \"src\" Read Random \"normals\" Read Random \"occlusion\" Read Random \"dst\" Write Random 49 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"vertexformat\" Int 2 CgAAAAoAAAA= \"Zoom\" Float 1 AACAPw== \"Filtering Method\" Int 1 AQAAAA== \"_alphaMultiplier\" Float 1 AACAPw== \"_pointRender\" Bool 1 AQ== \"_wireRender\" Bool 1 AQ== \"_facetRender\" Bool 1 AQ== \"_maxLDistance\" Float 1 AACAPw== \"_maxLConnections\" Int 1 AQAAAA== \"_maxPlexType\" Int 1 AAAAAA== \"_plexLinedefXY\" Bool 1 AA== \"_plexLinedefX\" Bool 1 AA== \"_plexLinedefY\" Bool 1 AA== \"_plexLinedefXtoY\" Bool 1 AA== \"_plexLinedefAUX\" Bool 1 AA== \"_plexConnectX\" Bool 1 AA== \"_plexConnectY\" Bool 1 AA== \"_L_gamma\" Float 1 AACAPw== \"Enable Depth of Field\" Bool 1 AA== \"samples\" Int 1 AwAAAA== \"rings\" Int 1 BQAAAA== \"focalDepth\" Float 1 AACAPw== \"_depthOfField\" Float 1 AACAQA== \"_depthMult\" Float 1 zczMPQ== \"_maxDofSize\" Float 1 AAAAQQ== \"dof_aspect\" Float 1 AACAPw== \"dof_threshold\" Float 1 AACAPw== \"dof_gain\" Float 1 AAAAAA== \"dof_bias\" Float 1 AAAAwA== \"dof_fringe\" Float 1 AAAAAA== \"_flatshading\" Bool 1 AQ== \"_backfacing\" Bool 1 AQ== \"_frontfacing\" Bool 1 AQ== \"_vertexMode\" Int 1 AAAAAA== \"_depthBuffer\" Bool 1 AQ== \"_texoffset\" Float 2 AAAAPwAAAD8= \"_pointSize\" Int 1 AQAAAA== \"_gaussigma\" Float 1 AACAPw== \"_depthOcclusion\" Bool 1 AQ== \"depthMultiplier\" Float 1 AACAPw== \"_maxLineSteps\" Float 1 AAB6RQ== \"_lineOffset\" Float 1 AACAPw== \"_lineInMultiplier\" Float 1 AACAPw== \"_lineOutMultiplier\" Float 1 AACAPw== \"_overscan\" Float 2 AAAAAAAAAAA= 49 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"Vformat\" 2 1 \"zoom\" 1 1 \"_filtering\" 1 1 \"_alphaMultiplier\" 1 1 \"_pointRender\" 1 1 \"_wireRender\" 1 1 \"_facetRender\" 1 1 \"_maxPlexDistance\" 1 1 \"_maxPlexConnections\" 1 1 \"_maxPlexType\" 1 1 \"_plexLinedefXY\" 1 1 \"_plexLinedefX\" 1 1 \"_plexLinedefY\" 1 1 \"_plexLinedefXtoY\" 1 1 \"_plexLinedefAUX\" 1 1 \"_plexConnectX\" 1 1 \"_plexConnectY\" 1 1 \"_plex_gamma\" 1 1 \"_dof_enable\" 1 1 \"_dof_samples\" 1 1 \"_dof_rings\" 1 1 \"focalDepth\" 1 1 \"_depthOfField\" 1 1 \"_depthMult\" 1 1 \"_maxDofSize\" 1 1 \"dof_aspect\" 1 1 \"dof_threshold\" 1 1 \"dof_gain\" 1 1 \"dof_bias\" 1 1 \"dof_fringe\" 1 1 \"_flatshading\" 1 1 \"_backfacing\" 1 1 \"_frontfacing\" 1 1 \"_vertexMode\" 1 1 \"_depthBuffer\" 1 1 \"_texoffset\" 2 1 \"_pointSize\" 1 1 \"_gaussigma\" 1 1 \"_depthOcclusion\" 1 1 \"depthMultiplier\" 1 1 \"_maxLineSteps\" 1 1 \"_lineOffset\" 1 1 \"_lineInMultiplier\" 1 1 \"_lineOutMultiplier\" 1 1 \"_overscan\" 2 1 10 \"max_line_connections\" Int 1 1 AAAAAA== \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "//Some basic generic functions.\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float3 Cross(float3 A,float3 B)\n\{\n    return float3(A.y*B.z - A.z*B.y,A.z*B.x - A.x*B.z,A.x*B.y - A.y*B.x);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}     \n\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\ninline float mix(float _X,float _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}                                                                                              \n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n\n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight,\n    float2 overscan\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f-overscan.x || pRaster.x > imageWidth+overscan.x || \n       pRaster.y < 0.0f-overscan.y || pRaster.y > imageHeight+overscan.y || pRaster.z < 0.0f) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eRead, eAccessRandom, eEdgeClamped> src;     //The texture map\n  Image<eRead, eAccessRandom, eEdgeClamped> normals;     //The texture map  \n  Image<eRead, eAccessRandom, eEdgeClamped> occlusion;     //The texture map \n  Image<eWrite, eAccessRandom> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat,Vformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    int _filtering;        //Filter method\n    float _alphaMultiplier; //Additive multiplier\n    bool _pointRender,_wireRender,_facetRender;\n    float _maxPlexDistance; //Additive multiplier\n    int _maxPlexConnections;\n    int _maxPlexType; // 0==Grid, -1==Nearest\n    bool _plexLinedefXY,_plexLinedefX,_plexLinedefY,_plexLinedefXtoY,_plexLinedefAUX; // Define what connections NOT to include\n    bool _plexConnectX,_plexConnectY; //Connect from the edge of x to 0, or edge of y to 0, usually for spheres\n    float _plex_gamma; //The threshold making shorter paths bright and longer paths dark\n    bool _dof_enable; // Enable DOF\n    int _dof_samples; // How many samples per DOF ring\n    int _dof_rings; // How many rings \n    float focalDepth,_depthOfField,_depthMult,_maxDofSize; //DOF Settings\n    float dof_aspect; //Pixel aspect ratio\n    float dof_threshold;\n    float dof_gain;\n    float dof_bias; //bokeh edge bias\n    float dof_fringe; //bokeh chromatic aberration/fringing\n    bool _flatshading,_backfacing,_frontfacing; //Vertex rendering settings\n    int _vertexMode;  //The rendering output mode, (think AOV)\n    bool _depthBuffer; //Non-additive, only render front most pixel\n    float2 _texoffset;\n    int _pointSize;\n    float _gaussigma;\n    bool _depthOcclusion;\n    float depthMultiplier;\n    float _maxLineSteps; //cap the line length to avoid process lock\n    float _lineOffset; //Alow you to shrink or extend the lines\n    float _lineInMultiplier,_lineOutMultiplier; //Control the brightness of the wires at the tips.\n    float2 _overscan; //This will allow you to render some extra outside the bounds of the image.\n\n  local: //Local variables\n    int max_line_connections;\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(Vformat,      \"vertexformat\", int2(10,10));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(_filtering, \"Filtering Method\", 1); \n    defineParam(_alphaMultiplier, \"_alphaMultiplier\", 1.0f);     \n    defineParam(_pointRender, \"_pointRender\", true);  \n    defineParam(_wireRender, \"_wireRender\", true);\n    defineParam(_facetRender, \"_facetRender\", true);\n    defineParam(_maxPlexDistance, \"_maxLDistance\", 1.0f);    \n    defineParam(_maxPlexConnections, \"_maxLConnections\", 1);    \n    defineParam(_maxPlexType, \"_maxPlexType\", 0); \n    defineParam(_plexLinedefXY, \"_plexLinedefXY\", false);      \n    defineParam(_plexLinedefXtoY, \"_plexLinedefXtoY\", false); //NYI\n    defineParam(_plexLinedefAUX, \"_plexLinedefAUX\", false); \n    defineParam(_plexLinedefX, \"_plexLinedefX\", false);  \n    defineParam(_plexLinedefY, \"_plexLinedefY\", false);  \n    defineParam(_plexConnectX, \"_plexConnectX\", false);      \n    defineParam(_plexConnectY, \"_plexConnectY\", false);   \n    defineParam(_plex_gamma, \"_L_gamma\", 1.0f);\n    //DOF SETTINGS   \n    defineParam(_dof_enable, \"Enable Depth of Field\", false);   \n    defineParam(_dof_samples, \"samples\", 3);    \n    defineParam(_dof_rings, \"rings\", 5);   \n    defineParam(focalDepth, \"focalDepth\", 1.0f);  \n    defineParam(_depthOfField, \"_depthOfField\", 4.0f);  \n    defineParam(_depthMult, \"_depthMult\", 0.1f);  \n    defineParam(_maxDofSize, \"_maxDofSize\", 8.0f);  \n    defineParam(dof_aspect, \"dof_aspect\", 1.0f);  \n    defineParam(dof_threshold, \"dof_threshold\", 1.0f);  \n    defineParam(dof_gain, \"dof_gain\", 0.0f);  \n    defineParam(dof_bias, \"dof_bias\", -2.0f);  \n    defineParam(dof_fringe, \"dof_fringe\", 0.0f); \n    //SHADING SETTINGS \n    defineParam(_flatshading, \"_flatshading\", true);  \n    defineParam(_vertexMode, \"_vertexMode\", 0);  \n    defineParam(_backfacing, \"_backfacing\", true);    \n    defineParam(_frontfacing, \"_frontfacing\", true);        \n    defineParam(_depthBuffer, \"_depthBuffer\", true);  \n    defineParam(_texoffset, \"_texoffset\", float2(0.5f,0.5f)); \n    defineParam(_pointSize, \"_pointSize\", 1); \n    defineParam(_gaussigma, \"_gaussigma\", 1.0f); \n    defineParam(_depthOcclusion, \"_depthOcclusion\", true); \n    defineParam(depthMultiplier, \"depthMultiplier\", 1.0f); \n    defineParam(_maxLineSteps, \"_maxLineSteps\", 4000.0f); \n    defineParam(_lineOffset, \"_lineOffset\", 1.0f); \n    defineParam(_lineInMultiplier, \"_lineInMultiplier\", 1.0f);   \n    defineParam(_lineOutMultiplier, \"_lineOutMultiplier\", 1.0f);     \n    defineParam(_overscan, \"_overscan\",float2(0.0f,0.0f));    \n\n  \}\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    max_line_connections = 80;\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n  \}\n\n  //Convert a 3d point position into a 2d raster position.\n  float3 Reconsile3D(float3 _PointPos)\{\n      vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      return tRaster;\n  \}\n\n//------------------------------\n//-------DRAW FUNCTIONS---------\n//------------------------------\n  //Write pixels to output.\n  void writepixel(float posx,float posy, float4 color,int index,float weight=1.0f)\n  \{ \n      if (_depthOcclusion)\{\n        float4 depthSample = occlusion(posx,posy);\n        if (depthSample.x<=vRaster.z && depthSample.w>0.0f)\{\n\n          float depth = (vRaster.z-depthSample.x);\n          color = color*(1.0f-depthSample.w);\n          color = color / (((depth*depth)*depthMultiplier)+1.0f);\n          //return;\n        \}\n      \}\n      float4 finalOutput; //This is used to store the final output\n      float4 dstSample; //This is used to store a sample of the destination\n      if ( dst.bounds.inside( posx, posy ) ) \{ //Test if the pixel written to is inside the output image. \n        if (_depthBuffer) \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          if ((dstSample.w>color.w)||dstSample.w==0.0f) \{\n            dst(posx,posy) = color;\n          \}\n        \}\n        else \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          finalOutput = dstSample + (color*_alphaMultiplier*weight);\n          finalOutput.w = dstSample.w + ((color.w*_alphaMultiplier*weight));\n\n          finalOutput.w = (dstSample.w + ((color.w*_alphaMultiplier*weight)))-(dstSample.w * ((color.w*_alphaMultiplier*weight)));\n\n          dst(posx,posy) = finalOutput;\n        \}\n      \} \n  \}\n\n  //Calculate a Bilinear Plot\n  void bilinear_Plot(float2 temppos,float4 color,int index)\n  \{\n    float2 p;\n    p.x=Frac(temppos.x);\n    p.y=Frac(temppos.y);\n    float weights\[] = \{(1.0f-p.x)*(1.0f-p.y), p.x*(1.0f-p.y), (1.0f-p.x)*p.y, p.x*p.y\};\n    int2 _position = int2(floor(temppos.x)-0,floor(temppos.y)-0); \n    writepixel(_position.x,_position.y,color,index,weights\[0]);\n    writepixel(_position.x+1,_position.y,color,index,weights\[1]);\n    writepixel(_position.x,_position.y+1,color,index,weights\[2]);\n    writepixel(_position.x+1,_position.y+1,color,index,weights\[3]);\n  \}\n\n  //NYI, unused!\n  void gaussian(float2 temppos,float4 color,int index)\{\n    float in_x = temppos.x;\n    float in_y = temppos.y;\n    int kernelSize = (_pointSize+1)*2;\n    int subsize = (kernelSize /2)-1;\n    float gKernel\[64]\[64];\n    float sigma = _gaussigma;\n    float intSigma = float(_pointSize);\n    float r, s = intSigma * sigma * sigma;\n\n    float sum = 0.0f;\n\n    // generate 5x5 kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            r = float(sqrt(x*x + y*y));\n            gKernel\[x + subsize]\[y + subsize] = (exp(-(r*r)/s))/(3.141592654f * s);\n            sum += gKernel\[x + subsize]\[y + subsize];\n        \}\n    \}\n\n    // normalize the Kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            gKernel\[x + subsize]\[y + subsize] /= sum;\n            writepixel(in_x+x,in_y+y,color,index,gKernel\[x + subsize]\[y + subsize]);\n        \}\n    \}\n  \}\n\n//-------------------------------------\n// DrawLine\n// ----------\n// Draw a line between two points, \n// x,y being 2d screenspace pos and z being depth.\n//-------------------------------------\n  void DrawLine(float3 origin, float3 endpoint,float4 _colorA,float4 _colorB) \{\n    float4 _color;\n    float3 delta = origin-endpoint;\n    float3 curPoint = origin;\n    float mag = sqrt(delta.x*delta.x+delta.y*delta.y);\n    mag = min(mag,_maxLineSteps); //Lets not go crazy, we cap it at 10.000 to avoid insane unwated processing time \n    for( float a = 0; a < mag*_lineOffset; a = a + 1.0f )\{\n      curPoint -= (delta/mag);\n      _color = (_colorA*(1.0f-(a/mag*1.0f)))+(_colorB*(a/mag*1.00f));\n      if (_dof_enable)\{\n        Bokeh(curPoint,_color);\n      \}\n      else \{\n        bilinear_Plot(float2(curPoint.x,curPoint.y),_color,1);\n      \}\n      \n    \}\n  \}\n\n//-------------------------------------\n// Point_Render\n//-------------------------------------\nvoid point_render(int2 pos, float3 screen_pos)\{\n  float4 color = src(pos.x,pos.y);\n\n  if (_filtering == 1)\{\n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        if (_depthBuffer) \{color.w = screen_pos.z;\} //Added\n        bilinear_Plot(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  /*\n  //THIS PART NEEDS TO BE RE-WRITTEN.\n  else if (_filtering == 2)\{ \n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        gaussian(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  */\n  else \{\n      int2 _position = int2(floor(screen_pos.x),floor(screen_pos.y)); \n      if (_depthBuffer) \{color.w = screen_pos.z;\}\n      writepixel(_position.x,_position.y, color,1,1.0f); //OutputSample\n  \}\n\n\}\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nvoid facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x+1,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos,V0_N,V1_N,V2_N;\n    float2 V0_ST,V1_ST,V2_ST;\n    float4 V1_Sample,V2_Sample;\n    float4 _tn;\n    float3 normal0,normal1,normal2;\n    float2 UV_Format = float2(Vformat.x,Vformat.y);\n\n\n    int2 P0 = int2(pos.x-1,pos.y-1);\n    int2 P1 = int2(pos.x+1,pos.y+1);\n    if (_plexConnectX && pos.x == int(Vformat.x))\{\n      insideX == true;\n      P1 = int2(0.0f,pos.y+1);\n    \}\n    if (_plexConnectY && pos.y == int(Vformat.y))\{\n      insideYtop == true;\n      P1 = int2(pos.x+1,0);\n    \} \n\n    if (_plexConnectY && pos.y == 0)\{\n      insideY == true;\n      P0 = int2(pos.x-1,int(UV_Format.y));\n    \} \n\n    if (!_flatshading) \{\n      _tn = normals(pos.x,pos.y);\n      V0_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n    V0_ST = float2(pos.x,pos.y)/UV_Format;\n\n  if (insideX) \{\n    V2_Sample = ppos(P1.x,pos.y);\n    V2_ST = float2(P1.x,pos.y)/UV_Format;\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (!_flatshading) \{\n      _tn = normals(P1.x,pos.y);\n      V2_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n        \n\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(P1.x,P0.y);\n        V1_ST = float2(P1.x,P0.y)/UV_Format;\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(P1.x,P0.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}\n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V2_Pos,V1_Pos,_vWorld,V2_wPos,V1_wPos,V0_N,V2_N,V1_N,V0_ST,V2_ST,V1_ST);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,P1.y);\n        V1_ST = float2(pos.x,P1.y)/UV_Format;        \n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(pos.x,P1.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}        \n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V1_Pos,V2_Pos,_vWorld,V1_wPos,V2_wPos,V0_N,V1_N,V2_N,V0_ST,V1_ST,V2_ST);\n        \}\n      \}\n    \}\n  \}\n\}\n\n\n\n//This function will calculate if pixel C is inside the triangle\nfloat edgeFunction(float3 a, float3 b, float3 c) \n\{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n\} \n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat Distance(float3 _a,float3 _b)\n\{\n          float xd = _a.x - _b.x;\n          float yd = _a.y - _b.y;\n          float zd = _a.z - _b.z;\n          return sqrt(xd*xd + yd*yd + zd*zd);\n\}\n\nvoid DrawTriangle(float3 V0, float3 V1, float3 V2,float3 WP0, float3 WP1, float3 WP2,float3 N0, float3 N1, float3 N2, float2 st0,float2 st1,float2 st2) \{\n\n  // Precompute reciprocal of vertex z-coordinate \n  V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n\n  float2 st0n = st0 * V0.z;\n  float2 st1n = st1 * V1.z; \n  float2 st2n = st2 * V2.z; //Normal version of ST\n\n  bool inside; \n  float X0 = Fmin(V0.x,V1.x,V2.x)-1.0f;\n  float X1 = Fmax(V0.x,V1.x,V2.x)+1.0f;\n  float Y0 = Fmin(V0.y,V1.y,V2.y)-1.0f;\n  float Y1 = Fmax(V0.y,V1.y,V2.y)+1.0f;\n  float area = edgeFunction(V2, V1, V0);\n\n\n  float2 sampos = float2(st0.x*float(Vformat.x),st0.y*float(Vformat.y));\n  float4 text0 = src(sampos.x,sampos.y);\n  sampos = float2(st1.x*float(Vformat.x),st1.y*float(Vformat.y));\n  float4 text1 = src(sampos.x,sampos.y);\n  sampos = float2(st2.x*float(Vformat.x),st2.y*float(Vformat.y));  //Why do we have to do this? =(\n  float4 text2 = src(sampos.x,sampos.y);\n  sampos = float2(min(min(st0.x,st1.x),st2.x)*float(Vformat.x),min(min(st0.y,st1.y),st2.y)*float(Vformat.y));\n  float4 text3 = src(sampos.x,sampos.y);\n\n\n  for( int x = X0; x < X1 ; x++) \{\n    for( int y = Y0; y < Y1 ; y++) \{\n      float3 pixelSample(x + _texoffset.x, y + _texoffset.y,0.0f); \n\n      //This is the part where we test if the current pixel is inside the triangle\n      //We check both for front facing and back faing options\n      float w0 = edgeFunction(V1, V0, pixelSample); //Front Facing\n      float w1 = edgeFunction(V2, V1, pixelSample); \n      float w2 = edgeFunction(V0, V2, pixelSample); \n      float w3 = edgeFunction(V0, V1, pixelSample); //Back Facing\n      float w4 = edgeFunction(V1, V2, pixelSample); \n      float w5 = edgeFunction(V2, V0, pixelSample);\n\n      //writepixel(x,y, float4(w1),1,1.0f);\n      if ((w0 >= 0 && w1 >= 0 && w2 >= 0 && _frontfacing) || (w3 >= 0 && w4 >= 0 && w5 >= 0 && _backfacing)) \{ //The curent pixel is inside the triangle\n\n       // calculate vectors from point f to vertices p1, p2 and p3:\n       float3 f1 = V0-pixelSample;\n       float3 f2 = V1-pixelSample;\n       float3 f3 = V2-pixelSample;\n       // calculate the areas and factors (order of parameters doesn't matter):\n       float a = length(cross(V0-V1,V0-V2 )); // main triangle area a\n       area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n        w0 /= area; \n        w1 /= area; \n        w2 /= area; \n\n        w3 /= area; \n        w4 /= area; \n        w5 /= area; \n\n       float a1 = length(cross(f2, f3)) / a; // p1's triangle area / a\n       float a2 = length(cross(f3, f1)) / a; // p2's triangle area / a \n       float a3 = length(cross(f1, f2)) / a; // p3's triangle area / a\n       float a_magnitude = a1+a2+a3;\n       a1 = a1/a_magnitude;\n       a2 = a2/a_magnitude;\n       a3 = a3/a_magnitude;\n       float z = 1.0f / (V0.z * a1 + V1.z * a2 + V2.z * a3); \n\n\n        // find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):\n        float2 uv = st0 * a1 + st1 * a2 + st2 * a3;\n        float2 st = st0 * w0 + st1 * w1 + st2 * w2; \n        st *= z;      \n\n\n        //Calculate normals. Eighter we have flat shading, else we calculate a normal per pixel\n        float3 normalB;\n        if (_flatshading) \{\n          normalB = CalculateSurfaceNormals(WP0,WP1,WP2);\n\n        \}\n        else \{\n          float3 c0 = N2/float3(V0.z); \n          float3 c1 = N0/float3(V1.z); \n          float3 c2 = N1/float3(V2.z);  \n\n          normalB.x = w0 * c0.x + w1 * c1.x + w2 * c2.x; \n          normalB.y = w0 * c0.y + w1 * c1.y + w2 * c2.y; \n          normalB.z = w0 * c0.z + w1 * c1.z + w2 * c2.z; \n\n          normalB.x *= z, normalB.y *= z, normalB.z *= z; \n        \}\n        normalB = normalize(normalB);\n\n        //CALCULATE THE OBJECT TEXTURE COORDINATES\n        float zn = 1.0f / (V0.z * w0 + V1.z * w1 + V2.z * w2); \n        st = st0n * w0 + st1n * w1 + st2n * w2; \n        st *= zn;   \n        //--END \n\n        float3 Wpos = WP0*a1 + WP1*a2 + WP2*a3; //World Position.\n        float3 ViewNormal = normalize(float3(cameraToWorld\[3]\[0],cameraToWorld\[3]\[1],cameraToWorld\[3]\[2])-Wpos);\n\n        float nDotView =  dot(normalB,ViewNormal);\n        nDotView = 1.0f-fabs(nDotView); //make sure that the view normal ramps back around when doing backface\n        float4 tempout;\n\n        //Flatshading or regular?\n        if (!_flatshading) \{\n          tempout = text0 * a1 + text1 * a2 + text2 * a3; \n        \}\n        else\{\n          tempout = text3;\n        \}\n\n        //Additional Render Modes\n        if (_vertexMode == 1)\{\n          tempout = float4(a1,a2,a3,1.0f);\n        \}\n        else if (_vertexMode == 2)\{\n          tempout = float4(normalB.x,normalB.y,normalB.z,1.0f);\n        \}\n        else if (_vertexMode == 3)\{\n          tempout = float4(nDotView,nDotView,nDotView,1.0f);\n        \}\n        else if (_vertexMode == 4)\{\n          tempout = float4(uv.x,uv.y,0.0f,1.0f);\n        \}       \n        else if (_vertexMode == 5)\{\n          tempout = float4(st.x,st.y,0.0f,1.0f);\n        \}               \n        else if (_vertexMode == 6)\{\n          tempout = float4(ViewNormal.x,ViewNormal.y,ViewNormal.z,1.0f);\n        \}             \n        else if (_vertexMode == 7)\{\n          tempout = float4(Wpos.x,Wpos.y,Wpos.z,1.0f);\n        \}   \n\n        if (_depthBuffer)\{\n          writepixel(x,y, float4(tempout.x,tempout.y,tempout.z,z),1,1.0f);  \n        \}\n        else \{\n          if (_dof_enable)\{\n            Bokeh(float3(x,y,z),float4(tempout.x,tempout.y,tempout.z,z));\n          \}\n          else \{\n            bilinear_Plot(float2(x,y),float4(tempout.x,tempout.y,tempout.z,z),1);\n          \}\n        \}\n\n      \}  \n\n    \}\n  \}\n\}\n\n//-------------------------------------\n// Wire_Render\n//-------------------------------------\nvoid wire_render(int2 pos) \{\n  float4 temp = float4(0.0f,0.0f,0.0f,FLT_MAX);\n  float4 wire_ref_sample;\n  int2 tempXY = int2(0,0);\n  float4 plexlist\[11] = \{temp,temp,temp,temp,temp,temp,temp,temp,temp,temp,temp\}; \n  int2 plexlistXY\[11] = \{tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY\};\n  int plex_count = 0; //We use this to figure how many points that should connect.\n  float plex_dist;\n  float3 plex_position,plex_position_b;\n  float4 temp_pos, temp_pos_b; //Temporary Position Containers\n  if (_maxPlexType == -1) \{ //Used for random connection types\n    for( int x = 0; x < max_line_connections ; x++)\{ //THIS 80 NUMBER IS THE LIMIT TO AVOID TOO SLOW PROCESSING!\n      for( int y = 0; y < max_line_connections ; y++)\{\n        wire_ref_sample = ppos(x,y);\n        if (wire_ref_sample.w != 0.0f && pos.x!=x && pos.y != y) \{ \n          plex_position = float3(wire_ref_sample.x,wire_ref_sample.y,wire_ref_sample.z)*(zoom);\n          float xd = plex_position.x - vWorld.x;\n          float yd = plex_position.y - vWorld.y;\n          float zd = plex_position.z - vWorld.z;\n          float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n          if (plex_dist<_maxPlexDistance)\{\n            plex_count = min(10,plex_count+1); //Add one to the count\n            for( int h = 0; h < plex_count+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n              if (plex_dist < plexlist\[h].w) \{                  \n                for( int i = plex_count+1; i > h ; i--) \{\n                  plexlist\[i] = plexlist\[i-1];\n                  plexlistXY\[i] = plexlistXY\[i-1];\n                \}\n                plexlist\[h] = float4(plex_position.x,plex_position.y,plex_position.z,plex_dist);\n                plexlistXY\[h] = int2(x,y);\n                break;        \n              \}\n            \}\n          \} \n        \}\n      \}\n    \}\n  \}\n  else\{ //Used for standard connection types\n    float4 temp_pos;\n    bool insideX = !(Vformat.x < pos.x+1);\n    bool insideY = !(Vformat.y < pos.y+1);\n\n\n    if (!_plexLinedefAUX)\{\n      temp_pos = normals(pos.x,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,vWorld+plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideX && !_plexLinedefX) \{\n      temp_pos = ppos(pos.x+1,pos.y );\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && !_plexLinedefX) \{\n      temp_pos = ppos(0,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideY && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\}                          \n    \}\n    else if ( _plexConnectY  && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,0);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    //_plexConnect\n    if ( insideX && insideY && !_plexLinedefXY) \{              \n      temp_pos = ppos(pos.x+1,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && _plexConnectY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && insideY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectY && insideX && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n  \}   \n\n  //now that all the connections have been sorted by distance then we connect the dots.\n  for( int x = 0; x < min(_maxPlexConnections,plex_count) ; x++)\{\n    plex_position = float3(plexlist\[x].x,plexlist\[x].y,plexlist\[x].z);\n    plex_dist = plexlist\[x].w;\n\n\n    float plex_distribution = 1.0f-((plexlist\[x].w-plexlist\[0].w)/((plexlist\[min(_maxPlexConnections,plex_count)].w-plexlist\[0].w)+0.00001f)); //Where does it lie between the best and the worst distance?\n    //plexlistXY\n\n    float4 plex_col = float4(pow(1.0f-(plex_dist/_maxPlexDistance),1.0f/_plex_gamma))*float4(plex_distribution); //This one is quite cool aswell, but does leave the center ones a bit too focused \n    float4 plex_colorA = src(pos.x,pos.y);\n    float4 plex_colorB = src( plexlistXY\[x].x,plexlistXY\[x].y);\n    plex_col *= 0.1f;\n\n    computePixelCoordinates(plex_position, pRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n    if (dst.bounds.inside(int(vRaster.x),int(vRaster.y)) || dst.bounds.inside(int(pRaster.x),int(pRaster.y)))\{\n        DrawLine(vRaster,pRaster,(plex_colorA*plex_col)*_lineInMultiplier,(plex_colorB*plex_col)*_lineOutMultiplier);\n    \}\n  \}\n\}\n\nvoid wire_connection(float3 p_source,float3 p_target, float4 (&p_plexlist)\[11], int2 (&p_plexlistXY)\[11],int &p_plexcount,int2 position) \{\n  float xd = p_target.x - p_source.x;\n  float yd = p_target.y - p_source.y;\n  float zd = p_target.z - p_source.z;\n  float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n  if (plex_dist<_maxPlexDistance)\{\n    p_plexcount = min(11,p_plexcount+1); //Add one to the count\n    for( int h = 0; h < p_plexcount+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n      if (plex_dist < p_plexlist\[h].w) \{                  \n        for( int i = p_plexcount+1; i > h ; i--) \{\n          p_plexlist\[i] = p_plexlist\[i-1];\n          p_plexlistXY\[i] = p_plexlistXY\[i-1];\n        \}\n        p_plexlist\[h] = float4(p_target.x,p_target.y,p_target.z,plex_dist);\n        p_plexlistXY\[h] = int2(position.x,position.y);\n        break;        \n      \}\n    \}  \n  \}\n\}\n//-------END OF WIRE RENDER FUNCTIONS---------\n\n\n\n\n//-------------------------------\n//-------BOKEH FUNCTIONS---------\n//thanks to: http://devlog-martinsh.blogspot.dk/2011/11/glsl-depth-of-field-with-bokeh-v21.html\nfloat2 rand(float2 coord) //generating noise/pattern texture for dithering\n\{\n  float noiseX = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.25)+(Frac(coord.y*(WHformat\[1]/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.75)+(Frac(coord.y*(WHformat\[1]/2.0))*0.25))*2.0-1.0;\n  noiseX = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f))) * 43758.5453f),0.0f,1.0f)*2.0f-1.0f;\n  noiseY = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f)*2.0f)) * 43758.5453f),0.0f,1.0f)*2.0-1.0f;\n  return float2(noiseX,noiseY);\n\}\n//-------------------------------------\n// Bokeh\n//-------------------------------------\nvoid Bokeh(float3 pos,float4 color)\{\n  float blur = 0.0;\n  blur = clamp((fabs(pos.z - focalDepth)/_depthOfField)*100.0f,-_maxDofSize,_maxDofSize);\n  \n  float w = (1.0/WHformat.x)*blur;//+noise.x;\n  float h = (1.0/(WHformat.x*dof_aspect))*blur;//+noise.y;\n  float3 v3_col = float3(color.x,color.y,color.z);\n  int ringsamples;\n  float s = 1.0;  \n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples; \n    for (int j = 0 ; j < ringsamples ; j += 1)  \n    \{ \n      s += (1.0f*mix(1.0f,(float(i))/(float(_dof_rings)),dof_bias)*1.0f); //No need to do this in the loop\n    \}\n  \}\n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples;\n     \n    for (int j = 0 ; j < ringsamples ; j += 1)   \n    \{\n      float step = PI*2.0 / float(ringsamples);\n      float pw = (cos(float(j)*step)*(float(i)/_dof_rings));\n      float ph = (sin(float(j)*step)*(float(i)/_dof_rings));\n      float p = 1.0;\n\n      float posx = pos.x+((pw*w)*blur);\n      float posy = pos.y+((ph*h)*blur);\n\n\n      float3 lumcoeff = float3(0.299,0.587,0.114);\n      float lum = dot(v3_col, lumcoeff);\n      float thresh = max((lum-dof_threshold)*dof_gain, 0.0f);\n      v3_col+mix(float3(0.0),v3_col,thresh*blur);\n\n      float3 col = (v3_col*mix(1.0,(float(i))/(float(_dof_rings)),dof_bias)*p)/s; \n      bilinear_Plot(float2(posx,posy),float4(col.x,col.y,col.z,color.w/(_dof_rings*_dof_rings)),1);\n    \}\n  \}\n\}\n//-------END OF BOKEH FUNCTIONS---------\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float2 posf = float2(pos.x,pos.y);\n\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n\n      //Convert worldspace coordinates to screenspcace coordinates.\n      vWorld = float3(_sample.x,_sample.y,_sample.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, vRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      if (ret) \{ //Only create points that are visible on screen\n        if (_pointRender)\{\n          point_render(pos,vRaster);\n        \}\n      \} //Pointrender over\n\n      if (_wireRender && _maxPlexConnections>=1) \{\n        if (max(pos.x,pos.y)<=max_line_connections || (_maxPlexType==0))\{ // Don't process more wires than allowed in nearest mode.\n          wire_render(pos);\n        \}\n      \} //WireRender over\n\n      if (_facetRender) \{\n        facet_render(pos,float3(_sample.x,_sample.y,_sample.z));\n      \}  //FacetRender over\n      \n    \}\n  \} //----> process\n\};\n"
  useGPUIfAvailable false
  rebuild ""
  PointRender3D_cam_Matrix {
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
    }
  PointRender3D_focallength {{parent.Camera1.focal}}
  PointRender3D_hapeture {{parent.Camera1.haperture}}
  PointRender3D_format {{!proxy?Settings_Format.width:Settings_Format.width*proxy_scale} {!proxy?Settings_Format.height:Settings_Format.height*proxy_scale}}
  PointRender3D_vertexformat {{parent.InputFormat.box.r-1} {parent.InputFormat.box.t-1}}
  PointRender3D__alphaMultiplier {{parent.AlphaMultiplier}}
  PointRender3D__pointRender {{parent.RenderMode==0}}
  PointRender3D__wireRender {{parent.RenderMode==1}}
  PointRender3D__facetRender {{parent.RenderMode==2}}
  PointRender3D__maxLDistance {{parent.wire_maxdistance}}
  PointRender3D__maxLConnections {{parent.wire_connections}}
  PointRender3D__maxPlexType {{-parent.wire_type}}
  PointRender3D__plexLinedefXY {{!parent.connect_xy}}
  PointRender3D__plexLinedefX {{!parent.connect_x}}
  PointRender3D__plexLinedefY {{!parent.connect_y}}
  PointRender3D__plexLinedefAUX {{!connect_aux}}
  PointRender3D__plexConnectX {{parent.CloseX}}
  PointRender3D__plexConnectY {{parent.CloseY}}
  PointRender3D__L_gamma {{parent.wire_Threshold}}
  "PointRender3D_Enable Depth of Field" {{parent.dof_enable}}
  PointRender3D_samples {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_rings {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_focalDepth {{parent.dof_focaldepth}}
  PointRender3D__depthOfField {{parent.dof_dof}}
  PointRender3D__depthMult 0
  PointRender3D__maxDofSize {{parent.dof_maxSize*400}}
  PointRender3D_dof_aspect {{parent.dof_Aspect}}
  PointRender3D_dof_bias {{parent.dof_bias}}
  PointRender3D__flatshading {{parent.facet_flatShading}}
  PointRender3D__backfacing {{parent.facet_backface}}
  PointRender3D__frontfacing {{parent.facet_front}}
  PointRender3D__vertexMode {{parent.renderMode}}
  PointRender3D__depthBuffer {{parent.facet_depth}}
  PointRender3D__texoffset {-0.5 0.5}
  PointRender3D__pointSize 0
  PointRender3D__depthOcclusion {{parent.UseOcclusionMap}}
  PointRender3D__maxLineSteps {{parent.maxSamples}}
  PointRender3D__lineOffset {{parent.lineoffset}}
  PointRender3D__lineInMultiplier {{parent.inGain}}
  PointRender3D__lineOutMultiplier {{parent.outGain}}
  PointRender3D__overscan {{parent.overscan} {parent.overscan}}
  format "1280 720 0 0 1280 720 1 HD_720"
  rebuild_finalise ""
  name BlinkScript1
  xpos -27
  ypos 159
 }
set N1d520530 [stack 0]
 TimeBlur {
  divisions {{parent.Samples}}
  shutter {{parent.Shutter}}
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur
  xpos -27
  ypos 301
  disable {{1-parent.mb_enable x89 0}}
 }
 ShuffleCopy {
  inputs 2
  alpha alpha2
  black alpha
  out2 depth
  name ShuffleCopy2
  xpos -27
  ypos 411
  disable {{!parent.OutputZdepth}}
 }
 CopyBBox {
  inputs 2
  name CopyBBox1
  xpos -27
  ypos 521
 }
 Reformat {
  format {{{Settings_Format.format}}}
  resize none
  center false
  pbb {{max(parent.overscan.w,parent.overscan.h)!=0}}
  name Reformat1
  xpos -27
  ypos 545
 }
 Group {
  name SoftLook
  xpos -27
  ypos 647
  disable {{!parent.HighlightCompression}}
  addUserKnob {20 User}
  addUserKnob {26 ""}
  addUserKnob {7 Add R 0 4}
  Add {{parent.HighlightCeiling}}
  addUserKnob {7 Offset R 0 4}
  Offset {{parent.Compression}}
 }
  Input {
   inputs 0
   name Input1
   xpos -248
   ypos 500
  }
set N1d5bc410 [stack 0]
  Expression {
   expr0 r/(r+parent.Offset)*parent.Add
   expr1 g/(g+parent.Offset)*parent.Add
   expr2 b/(b+parent.Offset)*parent.Add
   expr3 a/(a+parent.Offset)*parent.Add
   name Expression1
   xpos -339
   ypos 576
  }
push $N1d5bc410
  ShuffleCopy {
   inputs 2
   red red
   green green
   blue blue
   alpha alpha2
   name ShuffleCopy1
   xpos -248
   ypos 576
  }
  Output {
   name Output1
   xpos -248
   ypos 651
  }
 end_group
 ShuffleCopy {
  inputs 2
  in pos
  red red
  green green
  blue blue
  out pos
  name ShuffleCopy1
  xpos -27
  ypos 860
  disable true
 }
 Output {
  name Output1
  xpos -27
  ypos 897
 }
push $N1d468050
 PositionToPoints2 {
  display textured
  render_mode textured
  P_channel pos
  detail 0.25
  pointSize 0.6
  name PreviewNode
  xpos -22
  ypos 8
  disable {{!parent.Enable3DPreview}}
 }
push $N1d29dc40
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize none
  filter Impulse
  black_outside true
  name Reformat3
  xpos -633
  ypos -1109
  disable {{!wire_type==1}}
 }
push $N1d2e21e0
push $N1d301fe0
push $N1d306c70
 Merge2 {
  inputs 2
  operation min
  Achannels {-pos.red -pos.green -pos.blue pos.alpha}
  Bchannels {-pos.red -pos.green -pos.blue pos.alpha}
  output {-pos.red -pos.green -pos.blue pos.alpha}
  name Merge4
  xpos -582
  ypos -634
 }
 Merge2 {
  inputs 2
  operation min
  Achannels {-pos.red -pos.green -pos.blue pos.alpha}
  Bchannels {-pos.red -pos.green -pos.blue pos.alpha}
  output {-pos.red -pos.green -pos.blue pos.alpha}
  name Merge5
  xpos -582
  ypos -602
 }
push $N1d31a020
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -456
  ypos -402
 }
push $N1d520530
 Viewer {
  frame 36
  frame_range 1-100
  name Viewer1
  xpos -27
  ypos 325
 }
 Input {
  inputs 0
  name InputCamera
  xpos -1271
  ypos 89
  number 1
 }
 Camera {
  useMatrix true
  matrix {
      {1 0 0 0}
      {0 {1/Settings_Format.actual_format.pixel_aspect} 0 0}
      {0 0 1 0}
      {0 0 0 1}
    }
  projection_mode {{"\[value the_cam]projection_mode"}}
  focal {{"\[value \[value the_cam]focal]"}}
  haperture {{"\[value \[value the_cam]haperture]"}}
  vaperture {{"\[value \[value the_cam]vaperture]"}}
  near {{"\[value \[value the_cam]near]"}}
  far {{"\[value \[value the_cam]far]"}}
  win_translate {{"\[lindex \[value \[value the_cam]win_translate] 0]"} {"\[lindex \[value \[value the_cam]win_translate] 1]"}}
  win_scale {{"\[lindex \[value \[value the_cam]win_scale] 0]"} {"\[lindex \[value \[value the_cam]win_scale] 1]"}}
  winroll {{"\[value \[value the_cam]winroll]"}}
  focal_point {{"\[value \[value the_cam]focal_point]"}}
  fstop {{"\[value \[value the_cam]fstop]"}}
  name Camera1
  help "DummyCam by Adrian Pueyo\n\nCamera that apart from the matrices also grabs all the \"Projection\" values from the upstream camera that it's connected to. Turns into a default Camera if not Camera connected.\n\nCan also be used inside of groups and gizmos, as many levels deep as you want :D\n\nAll using live and super fast TCL.\n\nadrianpueyo.com, 2019"
  onCreate "n = nuke.thisNode()\nfor k in \[\"projection_mode\",\"focal\",\"haperture\",\"vaperture\",\"near\",\"far\",\"win_translate\",\"win_scale\",\"winroll\",\"focal_point\",\"fstop\"]:\n    n\[k].setFlag(0x0000000010000000)"
  label "(thanks to Adrian Pueyo and Ernest Dios)"
  xpos -1261
  ypos 198
  addUserKnob {20 DummyCam l Defaults}
  addUserKnob {43 the_cam +INVISIBLE}
  the_cam "\[\nset the_knob \"focal\"\nset knob_index 0\nset starting_point \"this.input0\"\nset default \"this\"\nset default \[append default \".d_\"]\n\n# If cam has no inputs, return the default...\nif \{\[exists \$starting_point]\} \{\n    set x \[node \$starting_point]\n\} \{ \n    return \$default\n\}\n\nset finished 0\nwhile \{\$finished != 1\} \{\n\n    # First look for a Cam or Input or topnode.\n    while \{\[class \$x] != \"Camera2\" && \[class \$x] != \"Camera\" && \[class \$x] != \"Input\" && \$x != \[topnode \$x]\} \{\n        set x \[node \$x.input0]\n    \}\n\n    # Then, check if node is a cam (and return), and otherwise, if it's an input, see if the parent exists and move to it.\n    if \{\[class \$x]==\"Camera2\"||\[class \$x]==\"Camera\"\} \{\n        set x \[append x \".\"]\n        return \$x\n    \} \{ \n        if \{\[class \$x]==\"Input\"\} \{ \n            set inp \"\$x.parent.input\"\n            set inputNum \[value \$x.number]\n            set inp \[append inp \$inputNum]\n            if \{\[exists \$inp]\} \{\n                set x \[node \$inp]\n            \} \{ \n                set finished 1\n            \}\n        \} \{ \n            set finished 1\n        \}\n    \}\n\}\nreturn \$default\n]"
  addUserKnob {4 d_projection_mode l projection M {perspective orthographic uv spherical ""}}
  addUserKnob {7 d_focal l focal R 0 100}
  d_focal 50
  addUserKnob {7 d_haperture l "horiz aperture" R 0 50}
  d_haperture 24.576
  addUserKnob {7 d_vaperture l "vert aperture" R 0 50}
  d_vaperture 18.672
  addUserKnob {7 d_near l near R 0 10}
  d_near 0.1
  addUserKnob {7 d_far l far R 0 10000}
  d_far 10000
  addUserKnob {12 d_win_translate l "window translate"}
  addUserKnob {12 d_win_scale l "window scale"}
  d_win_scale {1 1}
  addUserKnob {7 d_winroll l "window roll" R 0 45}
  addUserKnob {7 d_focal_point l "focal distance" R 0 10}
  d_focal_point 2
  addUserKnob {7 d_fstop l fstop R 0 30}
  d_fstop 16
  addUserKnob {26 text l " " T "<span style=\"color:#666\"><br/><b>DummyCam v1.0</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2019</span>"}
 }
end_group
FrameRange {
 first_frame 1
 last_frame 2000
 time ""
 name FrameRange8
 xpos 471
 ypos 2266
}
Retime {
 input.first_lock true
 input.last 2000
 input.last_lock true
 output.last 30
 speed 67
 before continue
 after continue
 filter none
 time ""
 name Retime1
 xpos 471
 ypos 2357
}
FrameRange {
 first_frame 1
 last_frame 30
 time ""
 name FrameRange9
 xpos 471
 ypos 2381
}
push $N1d1a79d0
Dot {
 name Dot54
 xpos 1449
 ypos 1524
}
Dot {
 name Dot19
 xpos 1449
 ypos 1600
}
set N1d6a1cf0 [stack 0]
Noise {
 replace true
 size 2000
 zoffset 1
 octaves 3
 gain 1
 gamma 1
 center {1112 774}
 name Noise1
 xpos 1549
 ypos 1664
}
push $N1d6a1cf0
Colorspace {
 channels pos
 colorspace_out CIE-Lab
 name Colorspace4
 xpos 1421
 ypos 1663
}
HueShift {
 inputs 1+1
 channels {-pos.red pos.green -pos.blue pos.alpha}
 hue_rotation {{-frame}}
 name HueShift5
 xpos 1421
 ypos 1699
}
Colorspace {
 channels pos
 colorspace_in HSL
 colorspace_out st2084
 mix 0.98
 name Colorspace7
 xpos 1421
 ypos 1735
}
HueShift {
 channels pos
 hue_rotation {{-frame}}
 name HueShift6
 xpos 1421
 ypos 1771
}
set N1d6fa710 [stack 0]
Colorspace {
 channels pos
 colorspace_in HSV
 colorspace_out Cineon
 name Colorspace8
 xpos 1421
 ypos 1817
}
push $N1d6fa710
push $N1d6fa710
Colorspace {
 inputs 1+1
 channels pos
 colorspace_in SLog
 colorspace_out Cineon
 name Colorspace9
 xpos 1529
 ypos 1804
}
Switch {
 inputs 2
 which 1
 name Switch1
 xpos 1421
 ypos 1877
}
Dot {
 name Dot18
 xpos 1449
 ypos 1917
}
set N1d742080 [stack 0]
push $N1d742080
Blur {
 size 4
 filter box
 name Blur1
 xpos 1287
 ypos 1914
}
Posterize {
 channels pos
 Colors 70
 name Posterize1
 xpos 1287
 ypos 1973
}
Merge2 {
 inputs 2
 operation exclusion
 name Merge1
 xpos 1421
 ypos 1979
}
Crop {
 box {0 0 512 512}
 name Crop5
 xpos 1421
 ypos 2094
}
set N1d770890 [stack 0]
PositionToPoints2 {
 display textured
 render_mode textured
 P_channel pos
 name PositionToPoints4
 xpos 1273
 ypos 2268
}
Axis2 {
 inputs 0
 rotate {-100 1129 110}
 name Axis3
 xpos 1570
 ypos 2118
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 addUserKnob {1 leaf_label l Leaf}
 addUserKnob {1 ivy_version l Version}
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
FrameRange {
 first_frame 1150
 last_frame 1400
 time ""
 name FrameRange1
 xpos 1560
 ypos 2194
}
Camera2 {
 translate {-0.1 0.1 -3}
 rotate {0 180 0}
 name Camera6
 xpos 1570
 ypos 2243
 addUserKnob {20 DNeg}
 addUserKnob {26 _version l "" +STARTLINE +INVISIBLE T 1.0}
 addUserKnob {41 "horiz aperture" T haperture}
 addUserKnob {41 "vert aperture" T vaperture}
 addUserKnob {4 setApertureValues l "" t "Set aperture values based on registered camera sensor data. The 'read from file' knob needs to be disabled and any potential curves deleted." +STARTLINE M {"Set Aperture Values" ANNI/Delivery "Alexa 65/Full" "Alexa 65/Half Res" "Alexa MINI/4:3 Full Ana" "Alexa MINI/16:9 Full" "Alexa MINI/OpenGate" "Alexa MINI/16:9 1.78 Ana" "Alexa Mini/OpenGate" "Alexa XT/OpenGate" "Alexa XT/4:3 Full Ana" "Alexa XT/16:9 1.78" "Alexa XT/16:9 1.78 Ana" "Alexa XT/4:3 Full" "Alexa XT/Open Gate" "Alexa XT/Open Gate TC" "Alexa XT/SuperOpenGate" "Alexa XT/SuperOpenGate Cropped" "Arri 65/6k 1.3 ana" "Arri 65/6k 2.11" BF/Delivery "BOND /Anamorphic" "Blackmagic Prod 4K/4K" "Canon 5D mkIII/HD" "Canon C300/16:9" "Delivery Extractions/Arri 65 1.3 ana Working" "Delivery Extractions/Arri 65 Working" "Extractions/CFW Delivery" "Film 35mm/Cinemascope Centred" "Film 35mm/Full Aperture" "Generic/1080p HD" Generic/Anamorphic Generic/Spherical "GoPro/Generic 16:9" HERC/Alexa IMAX/8K "Internal Movie Extractions/TRAINVFX Working" "Internal Movie Extractions/Alexa XT OpenGate" "Internal Movie Extractions/Previs" "Internal Movie Extractions/Arri 65 1.3 ana Working" "Internal Movie Extractions/MLOU Delivery" "Internal Movie Extractions/MAGIC Working" "Movie Extractions/Alexa XT OpenGate" "Movie Extractions/Alexa XT 4:3 Full Ana" "Movie Extractions/Alexa MINI 4:3 Full Ana" "Movie Extractions/Alexa MINI 16:9 1.78" "Movie Extractions/Alexa XT 16:9 1.78" "Movie Extractions/Alexa MINI OpenGate" "Movie Extractions/Alexa XT 16:9 1.78 Ana" "Movie Extractions/Alexa MINI 16:9 1.78 Ana" "Movie Extractions/Phantom Flex 4k" "Movie Extractions/MAE Working 2" "Movie Extractions/TS Anamorphic 4K" "Movie Extractions/EXO Working" "Movie Extractions/Previs" "Movie Extractions/MAGIC Working" "Movie Extractions/DOTN Working" "Phantom Flex/4k" Previs/Anamorphic Previs/Spherical "Red Epic/5K" "Red Epic Dragon/6K HD" "Red Epic Dragon/5K Full" "Red Epic Dragon/5K FullFrame Scaled" "TM/Alexa MINI 4:3 Full Ana" "Working Extractions/Arri 65 6k 1.3 ana" "Working Extractions/Alexa XT 4:3 Full Ana" "Working Extractions/Alexa XT OpenGate" "Working Extractions/Alexa XT 16:9 1.78" "Working Extractions/Alexa MINI 4:3 Full Ana" "Working Extractions/Alexa MINI OpenGate" "Working Extractions/Alexa MINI 16:9 1.78" "Working Extractions/Phantom Flex 4k" "Working Extractions/Alexa XT 16:9 1.78 Ana" "Working Extractions/Alexa MINI 16:9 1.78 Ana" "Working Extractions/EXO Working" "Working Extractions/EXO Working 2" "Working Extractions/Arri 65 6k" "Working Extractions/Alexa LF 4.5k OpenGate" "Working Extractions/DOTN Working" "internal Movie Extractions/Red Epic Dragon 5k FullFrame Scaled" "internal Movie Extractions/Red Epic Dragon 5K FullFrame" "internal Movie Extractions/IMAX 6K" "internal Movie Extractions/IMAX 8K" "Alexa LF/4.5k OpenGate" "Digital SLR/Full Frame" "Digital SLR/Full Frame Portrait" "Digital SLR/APS-C" "Digital SLR/APS-C Portrait" Generic/HD LatLong/360 LatLong/180}}
 addUserKnob {26 ""}
 addUserKnob {22 makeProjector l "Make Projector..." T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeProjectorNode']).makeProjectorNode()" +STARTLINE}
 addUserKnob {22 makeLinkedProjector l "Make Linked Projector..." -STARTLINE T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeProjectorNode']).makeLinkedProjectorNode()"}
 addUserKnob {26 ""}
 addUserKnob {7 hshake l "hero horiz shake" R -1 1}
 addUserKnob {7 vshake l "hero vert shake" R -1 1}
 addUserKnob {7 shakeroll l "hero shake roll" R -180 180}
 addUserKnob {7 ahshake l "ambient horiz shake" R -1 1}
 addUserKnob {7 avshake l "ambient vert shake" R -1 1}
 addUserKnob {7 ashakeroll l "ambient shake roll" R -180 180}
 addUserKnob {26 ""}
 addUserKnob {22 makeShakeCamera l "Make Shake Camera" T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeAmbientHeroShakeCamera']).makeAmbientHeroShakeCamera()" +STARTLINE}
 addUserKnob {22 makeShakeTransform l "Make Shake Transform" -STARTLINE T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeAmbientHeroShakeTransform']).makeAmbientHeroShakeTransform()"}
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 addUserKnob {1 leaf_label l Leaf}
 addUserKnob {1 ivy_version l Version}
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
push $N1d770890
Group {
 inputs 2
 name Point_Render5
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 xpos 1421
 ypos 2264
 addUserKnob {20 User l "Point Render" t dd}
 addUserKnob {26 info_header l "" +STARTLINE T "Point Render v1.2"}
 addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {4 RenderMode l "Render Mode" t "Some generators support multiple render modes other than just point rendering. This should be considered a experimental feature, but can be used to great effect.\n\nIn the Render Settings tab you can find more controls relating to Wire and Facet rendering modes.\n\nNote that Facet Render can be slow when really close to a object. " M {"Point Render" "Wire Render" "Facet Render (experimental)" "" "" ""}}
 RenderMode "Wire Render"
 addUserKnob {7 FocalLength l "Focal Length" t "The point render does not take the focal length from the input camera, so if you want to match it to a camera you should link the focal length from the camera to this." +INVISIBLE R 0 200}
 FocalLength 40
 addUserKnob {7 horizontalApeture l "Horiz Apeture" +INVISIBLE R 0 100}
 horizontalApeture 24.576
 addUserKnob {14 overscan l Overscan R 0 100}
 addUserKnob {7 AlphaMultiplier l Exposure t "This is a general exposure modifier that lets you adjust the overall brightness of the render." R 0 2}
 AlphaMultiplier 1
 addUserKnob {6 OutputZdepth l "Output Z-depth" t "Will output a Z-depth channel. This will cause reduced rendering performence." +STARTLINE}
 addUserKnob {6 UseOcclusionMap l "Use Occlusion Map" t "Enable the Occlusion map input. This lets you use a depth map as a holdout.\n\nNote:\nThe Red channal should contain the depth (absolute distance, not 1/depth)\nThe Alpha channal must be 1 for the areas that you want to holdout." +STARTLINE}
 addUserKnob {4 occ_method l "" t "Real Depth - input RGB should be the distance to the camera, and A should be the alpha (White occlude, Black ingore).\n\n1/depth.z (Scanline Render) - Will use the depth.Z channal from the scanline render and convert to real depth internally. Alpha is still required." -STARTLINE M {"Real Depth" "1/depth.z (Scanline Render)" ""}}
 occ_method "1/depth.z (Scanline Render)"
 addUserKnob {26 devider_cc l "<b><font color=#7DADF9>Preview</font><b>"}
 addUserKnob {6 FastPreview l "Fast Preview" t "Reduce the number of points for a quick preview of the final render." +STARTLINE}
 addUserKnob {6 HighlightCompression l "Hilight Compression" t "Compresses the highlights to make it easier to see bright details." +STARTLINE}
 addUserKnob {7 HighlightCeiling l "Highlight Ceiling" t "Adjust the cealing for the highlight compression." R 1 10}
 HighlightCeiling 1.15
 addUserKnob {7 Compression t "The compression amount." -STARTLINE R 0 5}
 Compression 1
 addUserKnob {26 devider_format l "<b><font color=#7DADF9>Format</font><b>"}
 addUserKnob {41 format l "output format" T Settings_Format.format}
 addUserKnob {20 WireRender l "Render Settings"}
 addUserKnob {26 devider_wirerender l "<b><font color=#7DADF9>Wire Rendering</font><b>"}
 addUserKnob {4 wire_type l "Connection Mode" t "*Normal\nConnect lines between the local neigbours of the 2d position map\n\n*Nearest\nConnect lines to the nearest points (in 3D space). This mode is limited to 100x100 points for performence reasons!" M {Normal Nearest "" "" "" "" "" "" "" ""}}
 addUserKnob {26 text l "Normal Mode Wires" T " "}
 addUserKnob {6 connect_x l x t "Connect wires in the (uv) X axis." -STARTLINE}
 connect_x true
 addUserKnob {6 connect_xy l xy t "Connect wires in the (uv) XY axis." -STARTLINE}
 connect_xy true
 addUserKnob {6 connect_y l y t "Connect wires in the (uv) Y axis." -STARTLINE}
 connect_y true
 addUserKnob {6 connect_aux l aux t "If you input a vector map into the Aux input for this node, and enable this option, you will get a wire from each point along that vector." -STARTLINE}
 addUserKnob {7 wire_maxdistance l "Max Distance" t "The maximum distance that the wires connect." R 0 10}
 wire_maxdistance 6
 addUserKnob {7 wire_Threshold l "Distance Threshold" t "Control the max distance threshold" R 0 2}
 wire_Threshold 0.5
 addUserKnob {3 wire_connections l "Max Connections" t "The maximum number of connections (Not Yet Implemented)"}
 wire_connections 4
 addUserKnob {7 maxSamples l "Max Line Samples" t "The maximum length of a line. Once a line is longer than this, it will start break up. \nThis can also be used as a creative effect if you set it low, try setting it to 10 in wire mode to get dotted lines" R 0 10000}
 maxSamples 10000
 addUserKnob {7 lineoffset l "Line Offset" t "Expand or contract the lines."}
 lineoffset 1
 addUserKnob {7 inGain l "In Gain" t "Gain the brightness of the in-point of the lines"}
 inGain 1
 addUserKnob {7 outGain l "Out Gain" t "Gain the brightness of the out-point of the lines" -STARTLINE}
 outGain 1
 addUserKnob {26 devider_facet l "<b><font color=#7DADF9>Facet Rendering</font><b>"}
 addUserKnob {4 renderMode l "Render Mode" t "Pick the desidered render mode." M {Diffuse "Local ST" Normal "Facing Ratio" UV ST "View Normal" "World Position" "" ""}}
 addUserKnob {6 facet_flatShading l "Flat Shading" t "Flat shading" +STARTLINE}
 addUserKnob {6 facet_depth l "Depth Buffer" t "Enable depth sorting to avoid additive surfaces." -STARTLINE}
 addUserKnob {6 facet_front l "Front Face" t "Render front facing facets" +STARTLINE}
 facet_front true
 addUserKnob {6 facet_backface l "Back Face" t "Render backfacing faces" -STARTLINE}
 facet_backface true
 addUserKnob {26 _1 l "<b><font color=#7DADF9>Other</font><b>"}
 addUserKnob {6 CloseX l "Close X" t "On spheres or round objects this closes the loop" +STARTLINE}
 addUserKnob {6 CloseY l "Close Y" t "On spheres or round objects this closes the loop" -STARTLINE}
 addUserKnob {20 Fog_1 l Fog}
 addUserKnob {26 Devider_Fog l "<b><font color=#7DADF9>Fog</font><b>"}
 addUserKnob {6 Fog t "Fog reduces the brightness of poins far from the camera." +STARTLINE}
 Fog true
 addUserKnob {7 FogNear l "Fog Near" R 0 200}
 FogNear 3
 addUserKnob {7 FogFar l "Fog Far" R 0 200}
 FogFar 10
 addUserKnob {7 FogExponent l "Fog Exponent" R 0 8}
 FogExponent 7
 addUserKnob {20 DepthOfField l "Depth of Field"}
 addUserKnob {26 devider_dof l "<b><font color=#7DADF9>Depth Of Field</font><b>"}
 addUserKnob {6 dof_enable l Enable +STARTLINE}
 addUserKnob {7 dof_focaldepth l "Focal Depth" R 0 40}
 dof_focaldepth 5
 addUserKnob {7 dof_dof l "Depth of Field" R 0 10}
 dof_dof 1
 addUserKnob {7 dof_maxSize l "Max Size"}
 dof_maxSize 2
 addUserKnob {7 dof_Aspect l "Aspect Ratio"}
 dof_Aspect 1
 addUserKnob {7 dof_bias l Bias R -3 3}
 dof_bias -0.2
 addUserKnob {4 Dof_Quality l Quality M {Low Medium High Extreme}}
 addUserKnob {20 MotionBlur}
 addUserKnob {26 devider_MotionBlur l "<b><font color=#7DADF9>Motion Blur</font><b>"}
 addUserKnob {6 mb_enable l Enable +STARTLINE}
 addUserKnob {6 Fast l "Fast (Interpolated)" -STARTLINE}
 Fast true
 addUserKnob {3 Samples}
 Samples 4
 addUserKnob {7 Shutter R 0 2}
 Shutter 0.5
 addUserKnob {4 pulldown l "Shutter Offset" M {Centered Start End ""}}
 addUserKnob {20 preview_3d l "3D Preview"}
 addUserKnob {6 Enable3DPreview l "Enable 3D Preview" t "Display a preview of the points in the Nuke 3D view." +STARTLINE}
 Enable3DPreview true
 addUserKnob {41 pointSize l "point size" T PreviewNode.pointSize}
 addUserKnob {41 detail l "point detail" T PreviewNode.detail}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x388e8e00
  label "Output Format Manager"
  note_font_size 22
  xpos -1079
  ypos 117
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode10
  tile_color 0x388e8e00
  label "AUX Input"
  note_font_size 22
  xpos -385
  ypos 178
  bdwidth 207
  bdheight 178
 }
 BackdropNode {
  inputs 0
  name BackdropNode11
  tile_color 0x388e8e00
  label "Point Render"
  note_font_size 22
  xpos -96
  ypos 99
  bdwidth 203
  bdheight 131
 }
 BackdropNode {
  inputs 0
  name BackdropNode12
  tile_color 0x388e8e00
  label "Normal Generator\nFor Vertex Normals"
  note_font_size 22
  xpos -616
  ypos 243
  bdwidth 191
  bdheight 122
 }
 BackdropNode {
  inputs 0
  name BackdropNode13
  tile_color 0x388e8e00
  label "Ensure output format"
  note_font_size 22
  xpos -622
  ypos -41
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode14
  tile_color 0x388e8e00
  label "Motion Blur"
  note_font_size 22
  xpos -85
  ypos 255
  bdwidth 264
  bdheight 96
 }
 BackdropNode {
  inputs 0
  name BackdropNode15
  tile_color 0x388e8e00
  label "Soft Preview"
  note_font_size 22
  xpos -83
  ypos 601
  bdwidth 191
  bdheight 94
 }
 BackdropNode {
  inputs 0
  name BackdropNode16
  tile_color 0x388e8e00
  label "Final format"
  note_font_size 22
  xpos -84
  ypos 482
  bdwidth 192
  bdheight 95
 }
 BackdropNode {
  inputs 0
  name BackdropNode17
  tile_color 0x388e8e00
  label "No Clue =)"
  note_font_size 22
  xpos -385
  ypos -41
  bdwidth 160
  bdheight 87
 }
 BackdropNode {
  inputs 0
  name BackdropNode18
  tile_color 0x388e8e00
  label "Z-Depth Shuffle"
  note_font_size 22
  xpos -85
  ypos 367
  bdwidth 264
  bdheight 96
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0x388e8e00
  label Motionblur
  note_font_size 22
  xpos -672
  ypos -781
  bdwidth 258
  bdheight 246
 }
 BackdropNode {
  inputs 0
  name BackdropNode3
  tile_color 0x388e8e00
  label "Fast Preview"
  note_font_size 22
  xpos -669
  ypos -971
  bdwidth 254
  bdheight 138
 }
 BackdropNode {
  inputs 0
  name BackdropNode4
  tile_color 0x388e8e00
  label "Nearest Wire Mode Clamp"
  note_font_size 22
  xpos -666
  ypos -1184
  bdwidth 253
  bdheight 111
 }
 BackdropNode {
  inputs 0
  name BackdropNode5
  tile_color 0x388e8e00
  label Occlusion
  note_font_size 22
  xpos 208
  ypos 27
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode6
  tile_color 0x388e8e00
  label "Input Camera Container"
  note_font_size 22
  xpos -1357
  ypos 121
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode7
  tile_color 0x388e8e00
  label "3D Preview"
  note_font_size 22
  xpos -88
  ypos -45
  bdwidth 207
  bdheight 102
 }
 BackdropNode {
  inputs 0
  name BackdropNode8
  tile_color 0x388e8e00
  label "Input Format Manager"
  note_font_size 22
  xpos -526
  ypos -459
  bdwidth 208
  bdheight 97
 }
 BackdropNode {
  inputs 0
  name BackdropNode9
  tile_color 0x388e8e00
  label FOG
  note_font_size 22
  xpos -602
  ypos -253
  bdwidth 370
  bdheight 152
 }
 Input {
  inputs 0
  name InputPointData
  xpos -584
  ypos -1321
 }
 Dot {
  name Dot4
  xpos -550
  ypos -1234
 }
set N1d84bae0 [stack 0]
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize fill
  filter Impulse
  black_outside true
  name Reformat5
  xpos -584
  ypos -906
  disable {{!parent.FastPreview==1}}
 }
 Grade {
  white 10
  name Grade2
  xpos -584
  ypos -874
  disable {{!parent.FastPreview}}
 }
 Dot {
  name Dot2
  xpos -550
  ypos -712
 }
set N1d870130 [stack 0]
 Group {
  name FrameHold3
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -501
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame+1}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot6
  xpos -467
  ypos -659
 }
set N1d890110 [stack 0]
push $N1d870130
 Group {
  name FrameHold2
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -660
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot5
  xpos -626
  ypos -659
 }
set N1d8aff80 [stack 0]
 Dissolve {
  inputs 2
  which {{frame-floor(frame)}}
  name Dissolve1
  xpos -582
  ypos -666
  disable {{1-parent.mb_enable}}
 }
set N1d8b4ae0 [stack 0]
push $N1d870130
 Switch {
  inputs 2
  which {{parent.Fast}}
  name Switch2
  xpos -584
  ypos -567
 }
 Dot {
  name DataFetch
  label "data fetch\t"
  note_font_color 0xff21ff
  xpos -550
  ypos -513
  addUserKnob {20 User}
  addUserKnob {3 n_particles l "Number of Particles"}
  addUserKnob {3 gentype l "Type Of Generator"}
  addUserKnob {26 info l "" -STARTLINE T "0 = unknown, 1 = Card, 2 = Sphere, 3 = Grid"}
 }
set N1d8c7e90 [stack 0]
 Dot {
  name Dot3
  xpos -635
  ypos -513
 }
 Dot {
  name Dot1
  xpos -635
  ypos 863
 }
 Reformat {
  inputs 0
  format "2224 1548 0 0 2224 1548 1 Alexa LF 4.5k OpenGate Working"
  resize distort
  center false
  black_outside true
  name Settings_Format
  xpos -992
  ypos 209
 }
 AdjBBox {
  numpixels {{parent.overscan} {parent.overscan}}
  name AdjBBox2
  xpos -992
  ypos 241
 }
 Input {
  inputs 0
  name InputOcclusion
  xpos 238
  ypos 75
  number 2
 }
 Expression {
  expr0 depth.Z>0?1/depth.Z:0
  name Expression2
  xpos 238
  ypos 104
  disable {{!parent.occ_method}}
 }
 Constant {
  inputs 0
  channels rgb
  color 1
  format {{{parent.Settings_Format.format}}}
  name Empty
  xpos 371
  ypos 139
 }
 Switch {
  inputs 2
  which {{parent.UseOcclusionMap}}
  name Switch1
  xpos 238
  ypos 163
 }
 AdjBBox {
  numpixels {{parent.overscan} {parent.overscan}}
  name AdjBBox1
  xpos 118
  ypos 163
 }
set N1d9118b0 [stack 0]
 Input {
  inputs 0
  name Aux
  xpos -324
  ypos 214
  number 3
 }
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter Impulse
  black_outside true
  name Reformat2
  xpos -324
  ypos 238
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop1
  xpos -324
  ypos 462
 }
push $N1d8c7e90
 Shuffle {
  in pos
  name Shuffle1
  xpos -584
  ypos -192
 }
set N1d938340 [stack 0]
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter Impulse
  black_outside true
  name Reformat4
  xpos -584
  ypos 18
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop2
  xpos -584
  ypos 48
 }
 Dot {
  name Dot8
  xpos -550
  ypos 166
 }
set N1d962570 [stack 0]
 Group {
  name Point_Normal2
  tile_color 0x434343ff
  note_font_color 0x55ffffff
  xpos -584
  ypos 498
  disable {{!(renderMode==2&&RenderMode==2)}}
  addUserKnob {20 User}
  addUserKnob {26 info l "" +STARTLINE T "Point Normal v1.0"}
  addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
  addUserKnob {26 info_1 l "" +STARTLINE T "well, not much to do here =)"}
 }
  Input {
   inputs 0
   name Input1
   xpos 389
   ypos 207
  }
  Shuffle {
   in pos
   name Shuffle1
   xpos 389
   ypos 294
  }
  BlinkScript {
   kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/BasicLight.cpp
   recompileCount 69
   ProgramGroup 1
   KernelDescription "2 \"PointRender3D\" iterate pixelWise d5452fe7b684561fcfa5182d0c789025a037cc4fe4474c24e065e3fa53fcd8ce 2 \"ppos\" Read Random \"dst\" Write Point 9 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"Zoom\" Float 1 AACAPw== \"half Lambert\" Bool 1 AQ== \"light Mode\" Int 1 AAAAAA== \"light_position\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"light_color\" Float 3 AACAPwAAgD8AAIA/AAAAAA== 9 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"zoom\" 1 1 \"halfLambert\" 1 1 \"lightMode\" 1 1 \"lightPos\" 3 1 \"lightcolor\" 3 1 10 \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"namount\" Float 1 1 AAAAAA=="
   kernelSource "inline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}\n\ninline float saturate(float _in)\n\{\n    return max(0.0f,min(1.0f,_in));\n\}\n\ninline float3 reflect(float3 incidence,float3 normal)\n\{\n  return incidence - 2.f * dot(incidence, normal) * normal;\n\}\n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n    \n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    if (fabs(pScreen.x) > canvasWidth || fabs(pScreen.y) > canvasHeight) \n         return false; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eWrite> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    bool halfLambert;\n    int lightMode;\n    float3 lightPos;\n    float3 lightcolor;\n\n\n  local: //Local variables\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n    float namount; //dither amount\n\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(halfLambert, \"half Lambert\", true);\n    defineParam(lightMode, \"light Mode\", 0);\n    defineParam(lightPos,      \"light_position\", float3(0,0,0));  \n    defineParam(lightcolor,      \"light_color\", float3(1.0,1.0,1.0)); \n  \}\n\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n    namount = 0.0001; //dither amount\n  \}\n\n\n\nfloat3 Reconsile3D(float3 _PointPos)\{\n    vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n    int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    return tRaster;\n\}\n\n\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nfloat3 facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos;\n    float4 V0_Sample,V1_Sample,V2_Sample;\n    float3 normal0,normal1,normal2;\n\n    //for area calculation\n    float area;\n    float3 V0,V1,V2;\n    float3 output = float3(0.0f);\n  if (insideX) \{\n    V2_Sample = ppos(pos.x+1,pos.y);\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(pos.x+1,pos.y-1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n            float3 Normal = CalculateVertexNormals(_vWorld,V2_wPos,V1_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          //write output\n          output +=  float3(Normal.x,Normal.y,Normal.z);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,pos.y+1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n          float3 Normal = CalculateVertexNormals(_vWorld,V1_wPos,V2_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          output += float3(Normal.x,Normal.y,Normal.z);\n\n        \}\n      \}\n    \}\n  \}\n  return output;\n\}\n\n\n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 hitNormal = cross((V1 - V0),(V2 - V0)); \n        return hitNormal;\n\}\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float3 output = float3(0.0f);\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float3 point_pos = float3(_sample.x,_sample.y,_sample.z);\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n      dst() = float4(0.0f);\n      output+=facet_render(pos,float3(_sample.x,_sample.y,_sample.z))*2.0f;\n      _sample = ppos(pos.x-1,pos.y); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x-1,pos.y+1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y+1),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x,pos.y-1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x,pos.y-1),float3(_sample.x,_sample.y,_sample.z));\n\n      output = normalize(output);\n      float3 normal = -output;\n\n      \n\n\n      dst() = float4(normal.x,normal.y,normal.z,1.0f);\n    \}\n  \} //----> process\n\};\n"
   rebuild ""
   "PointRender3D_half Lambert" false
   PointRender3D_light_position {{parent.Axis1.translate} {parent.Axis1.translate} {parent.Axis1.translate}}
   PointRender3D_light_color {0 0 0}
   rebuild_finalise ""
   name BlinkScript1
   xpos 389
   ypos 344
  }
  Grade {
   multiply 0.5
   add 0.5
   black_clamp false
   name Grade1
   xpos 389
   ypos 376
   disable true
  }
  Output {
   name Output1
   xpos 389
   ypos 459
  }
  Axis2 {
   inputs 0
   translate {0.5 0.5 0.5}
   name Axis1
   xpos 661
   ypos 318
   addUserKnob {20 Ivy}
   addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
   addUserKnob {26 divider4 l "" +STARTLINE}
   addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
   _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
   addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
   addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
   addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
   _expressions {{curve}}
   addUserKnob {26 divider0 l "" +STARTLINE}
   addUserKnob {20 dbinfo l "DB Info" n 1}
   dbinfo 0
   addUserKnob {1 twig_dnuuid l "Twig Id"}
   addUserKnob {1 stalk_dnuuid l "Stalk Id"}
   addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
   addUserKnob {1 leaf_dnuuid l "Leaf Id"}
   addUserKnob {26 divider1 l "" +STARTLINE}
   addUserKnob {1 twigtype l "Twig Type"}
   addUserKnob {1 leaf_label l Leaf}
   addUserKnob {1 ivy_version l Version}
   addUserKnob {43 ivy_notes l Notes}
   addUserKnob {26 divider2 l "" +STARTLINE}
   addUserKnob {1 build_label l "Build Label"}
   addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
  }
 end_group
 Switch {
  inputs 2
  which {{parent.connect_aux}}
  name Switch3
  xpos -324
  ypos 498
 }
set N1d9dfb80 [stack 0]
push $N1d938340
 Expression {
  temp_name0 xd
  temp_expr0 red-Camera1.world_matrix.3
  temp_name1 yd
  temp_expr1 green-Camera1.world_matrix.7
  temp_name2 zd
  temp_expr2 blue-Camera1.world_matrix.11
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  expr3 Distance
  name Expression1
  xpos -456
  ypos -192
 }
 Grade {
  channels rgba
  blackpoint {{parent.FogFar}}
  whitepoint {{parent.FogNear}}
  gamma {{1/(parent.FogExponent+0.000000001)}}
  white_clamp true
  name Grade1
  xpos -456
  ypos -168
 }
push $N1d8c7e90
 Dot {
  name Dot7
  xpos -307
  ypos -513
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge1
  xpos -341
  ypos -168
  disable {{!parent.Fog}}
 }
 Shuffle {
  name Shuffle3
  xpos -341
  ypos 8
 }
set N1da1bef0 [stack 0]
 Shuffle {
  red white
  green white
  blue white
  name Shuffle2
  xpos -28
  ypos 76
 }
push $N1d962570
 BlinkScript {
  inputs 4
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Render/3D_PointRender_v18.cpp
  recompileCount 806
  ProgramGroup 1
  KernelDescription "2 \"PointRender3D\" iterate pixelWise b6c79b641c58390f32c944e2b5792a8702107f9cfc926636430288e7e0e1b392 5 \"ppos\" Read Random \"src\" Read Random \"normals\" Read Random \"occlusion\" Read Random \"dst\" Write Random 50 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"vertexformat\" Int 2 CgAAAAoAAAA= \"Zoom\" Float 1 AACAPw== \"Filtering Method\" Int 1 AQAAAA== \"_alphaMultiplier\" Float 1 AACAPw== \"_pointRender\" Bool 1 AQ== \"_wireRender\" Bool 1 AQ== \"_facetRender\" Bool 1 AQ== \"_maxLDistance\" Float 1 AACAPw== \"_maxLConnections\" Int 1 AQAAAA== \"_maxPlexType\" Int 1 AAAAAA== \"_plexLinedefXY\" Bool 1 AA== \"_plexLinedefX\" Bool 1 AA== \"_plexLinedefY\" Bool 1 AA== \"_plexLinedefXtoY\" Bool 1 AA== \"_plexLinedefAUX\" Bool 1 AA== \"_plexConnectX\" Bool 1 AA== \"_plexConnectY\" Bool 1 AA== \"_L_gamma\" Float 1 AACAPw== \"Enable Depth of Field\" Bool 1 AA== \"samples\" Int 1 AwAAAA== \"rings\" Int 1 BQAAAA== \"focalDepth\" Float 1 AACAPw== \"_depthOfField\" Float 1 AACAQA== \"_depthMult\" Float 1 zczMPQ== \"_maxDofSize\" Float 1 AAAAQQ== \"dof_aspect\" Float 1 AACAPw== \"dof_threshold\" Float 1 AACAPw== \"dof_gain\" Float 1 AAAAAA== \"dof_bias\" Float 1 AAAAwA== \"dof_fringe\" Float 1 AAAAAA== \"_flatshading\" Bool 1 AQ== \"_backfacing\" Bool 1 AQ== \"_frontfacing\" Bool 1 AQ== \"_vertexMode\" Int 1 AAAAAA== \"_depthBuffer\" Bool 1 AQ== \"_texoffset\" Float 2 AAAAPwAAAD8= \"_pointSize\" Int 1 AQAAAA== \"_gaussigma\" Float 1 AACAPw== \"_depthOcclusion\" Bool 1 AQ== \"depthMultiplier\" Float 1 AACAPw== \"_maxLineSteps\" Float 1 AAB6RQ== \"_lineOffset\" Float 1 AACAPw== \"_lineInMultiplier\" Float 1 AACAPw== \"_lineOutMultiplier\" Float 1 AACAPw== \"_overscan\" Float 2 AAAAAAAAAAA= \"isDepth\" Bool 1 AA== 50 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"Vformat\" 2 1 \"zoom\" 1 1 \"_filtering\" 1 1 \"_alphaMultiplier\" 1 1 \"_pointRender\" 1 1 \"_wireRender\" 1 1 \"_facetRender\" 1 1 \"_maxPlexDistance\" 1 1 \"_maxPlexConnections\" 1 1 \"_maxPlexType\" 1 1 \"_plexLinedefXY\" 1 1 \"_plexLinedefX\" 1 1 \"_plexLinedefY\" 1 1 \"_plexLinedefXtoY\" 1 1 \"_plexLinedefAUX\" 1 1 \"_plexConnectX\" 1 1 \"_plexConnectY\" 1 1 \"_plex_gamma\" 1 1 \"_dof_enable\" 1 1 \"_dof_samples\" 1 1 \"_dof_rings\" 1 1 \"focalDepth\" 1 1 \"_depthOfField\" 1 1 \"_depthMult\" 1 1 \"_maxDofSize\" 1 1 \"dof_aspect\" 1 1 \"dof_threshold\" 1 1 \"dof_gain\" 1 1 \"dof_bias\" 1 1 \"dof_fringe\" 1 1 \"_flatshading\" 1 1 \"_backfacing\" 1 1 \"_frontfacing\" 1 1 \"_vertexMode\" 1 1 \"_depthBuffer\" 1 1 \"_texoffset\" 2 1 \"_pointSize\" 1 1 \"_gaussigma\" 1 1 \"_depthOcclusion\" 1 1 \"depthMultiplier\" 1 1 \"_maxLineSteps\" 1 1 \"_lineOffset\" 1 1 \"_lineInMultiplier\" 1 1 \"_lineOutMultiplier\" 1 1 \"_overscan\" 2 1 \"isDepth\" 1 1 10 \"max_line_connections\" Int 1 1 AAAAAA== \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "//Some basic generic functions.\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float3 Cross(float3 A,float3 B)\n\{\n    return float3(A.y*B.z - A.z*B.y,A.z*B.x - A.x*B.z,A.x*B.y - A.y*B.x);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}     \n\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\ninline float mix(float _X,float _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}                                                                                              \n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n\n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight,\n    float2 overscan\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f-overscan.x || pRaster.x > imageWidth+overscan.x || \n       pRaster.y < 0.0f-overscan.y || pRaster.y > imageHeight+overscan.y || pRaster.z < 0.0f) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eRead, eAccessRandom, eEdgeClamped> src;     //The texture map\n  Image<eRead, eAccessRandom, eEdgeClamped> normals;     //The texture map  \n  Image<eRead, eAccessRandom, eEdgeClamped> occlusion;     //The texture map \n  Image<eWrite, eAccessRandom> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat,Vformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    int _filtering;        //Filter method\n    float _alphaMultiplier; //Additive multiplier\n    bool _pointRender,_wireRender,_facetRender;\n    float _maxPlexDistance; //Additive multiplier\n    int _maxPlexConnections;\n    int _maxPlexType; // 0==Grid, -1==Nearest\n    bool _plexLinedefXY,_plexLinedefX,_plexLinedefY,_plexLinedefXtoY,_plexLinedefAUX; // Define what connections NOT to include\n    bool _plexConnectX,_plexConnectY; //Connect from the edge of x to 0, or edge of y to 0, usually for spheres\n    float _plex_gamma; //The threshold making shorter paths bright and longer paths dark\n    bool _dof_enable; // Enable DOF\n    int _dof_samples; // How many samples per DOF ring\n    int _dof_rings; // How many rings \n    float focalDepth,_depthOfField,_depthMult,_maxDofSize; //DOF Settings\n    float dof_aspect; //Pixel aspect ratio\n    float dof_threshold;\n    float dof_gain;\n    float dof_bias; //bokeh edge bias\n    float dof_fringe; //bokeh chromatic aberration/fringing\n    bool _flatshading,_backfacing,_frontfacing; //Vertex rendering settings\n    int _vertexMode;  //The rendering output mode, (think AOV)\n    bool _depthBuffer; //Non-additive, only render front most pixel\n    float2 _texoffset;\n    int _pointSize;\n    float _gaussigma;\n    bool _depthOcclusion;\n    float depthMultiplier;\n    float _maxLineSteps; //cap the line length to avoid process lock\n    float _lineOffset; //Alow you to shrink or extend the lines\n    float _lineInMultiplier,_lineOutMultiplier; //Control the brightness of the wires at the tips.\n    float2 _overscan; //This will allow you to render some extra outside the bounds of the image.\n    bool isDepth; //This will allow you to render some extra outside the bounds of the image.\n\n  local: //Local variables\n    int max_line_connections;\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(Vformat,      \"vertexformat\", int2(10,10));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(_filtering, \"Filtering Method\", 1); \n    defineParam(_alphaMultiplier, \"_alphaMultiplier\", 1.0f);     \n    defineParam(_pointRender, \"_pointRender\", true);  \n    defineParam(_wireRender, \"_wireRender\", true);\n    defineParam(_facetRender, \"_facetRender\", true);\n    defineParam(_maxPlexDistance, \"_maxLDistance\", 1.0f);    \n    defineParam(_maxPlexConnections, \"_maxLConnections\", 1);    \n    defineParam(_maxPlexType, \"_maxPlexType\", 0); \n    defineParam(_plexLinedefXY, \"_plexLinedefXY\", false);      \n    defineParam(_plexLinedefXtoY, \"_plexLinedefXtoY\", false); //NYI\n    defineParam(_plexLinedefAUX, \"_plexLinedefAUX\", false); \n    defineParam(_plexLinedefX, \"_plexLinedefX\", false);  \n    defineParam(_plexLinedefY, \"_plexLinedefY\", false);  \n    defineParam(_plexConnectX, \"_plexConnectX\", false);      \n    defineParam(_plexConnectY, \"_plexConnectY\", false);   \n    defineParam(_plex_gamma, \"_L_gamma\", 1.0f);\n    //DOF SETTINGS   \n    defineParam(_dof_enable, \"Enable Depth of Field\", false);   \n    defineParam(_dof_samples, \"samples\", 3);    \n    defineParam(_dof_rings, \"rings\", 5);   \n    defineParam(focalDepth, \"focalDepth\", 1.0f);  \n    defineParam(_depthOfField, \"_depthOfField\", 4.0f);  \n    defineParam(_depthMult, \"_depthMult\", 0.1f);  \n    defineParam(_maxDofSize, \"_maxDofSize\", 8.0f);  \n    defineParam(dof_aspect, \"dof_aspect\", 1.0f);  \n    defineParam(dof_threshold, \"dof_threshold\", 1.0f);  \n    defineParam(dof_gain, \"dof_gain\", 0.0f);  \n    defineParam(dof_bias, \"dof_bias\", -2.0f);  \n    defineParam(dof_fringe, \"dof_fringe\", 0.0f); \n    //SHADING SETTINGS \n    defineParam(_flatshading, \"_flatshading\", true);  \n    defineParam(_vertexMode, \"_vertexMode\", 0);  \n    defineParam(_backfacing, \"_backfacing\", true);    \n    defineParam(_frontfacing, \"_frontfacing\", true);        \n    defineParam(_depthBuffer, \"_depthBuffer\", true);  \n    defineParam(_texoffset, \"_texoffset\", float2(0.5f,0.5f)); \n    defineParam(_pointSize, \"_pointSize\", 1); \n    defineParam(_gaussigma, \"_gaussigma\", 1.0f); \n    defineParam(_depthOcclusion, \"_depthOcclusion\", true); \n    defineParam(depthMultiplier, \"depthMultiplier\", 1.0f); \n    defineParam(_maxLineSteps, \"_maxLineSteps\", 4000.0f); \n    defineParam(_lineOffset, \"_lineOffset\", 1.0f); \n    defineParam(_lineInMultiplier, \"_lineInMultiplier\", 1.0f);   \n    defineParam(_lineOutMultiplier, \"_lineOutMultiplier\", 1.0f);     \n    defineParam(_overscan, \"_overscan\",float2(0.0f,0.0f));    \n\n  \}\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    max_line_connections = 80;\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n  \}\n\n  //Convert a 3d point position into a 2d raster position.\n  float3 Reconsile3D(float3 _PointPos)\{\n      vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      return tRaster;\n  \}\n\n//------------------------------\n//-------DRAW FUNCTIONS---------\n//------------------------------\n  //Write pixels to output.\n  void writepixel(float posx,float posy, float4 color,int index,float weight=1.0f)\n  \{ \n      if (_depthOcclusion)\{\n        float4 depthSample = occlusion(posx,posy);\n        if (depthSample.x<=vRaster.z && depthSample.w>0.0f)\{\n\n          float depth = (vRaster.z-depthSample.x);\n          color = color*(1.0f-depthSample.w);\n          color = color / (((depth*depth)*depthMultiplier)+1.0f);\n          //return;\n        \}\n      \}\n      float4 finalOutput; //This is used to store the final output\n      float4 dstSample; //This is used to store a sample of the destination\n      if ( dst.bounds.inside( posx, posy ) ) \{ //Test if the pixel written to is inside the output image. \n        if (_depthBuffer) \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          if ((dstSample.w>color.w)||dstSample.w==0.0f) \{\n            dst(posx,posy) = color;\n          \}\n        \}\n        else \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          finalOutput = dstSample + (color*_alphaMultiplier*weight);\n          finalOutput.w = dstSample.w + ((color.w*_alphaMultiplier*weight));\n\n          finalOutput.w = (dstSample.w + ((color.w*_alphaMultiplier*weight)))-(dstSample.w * ((color.w*_alphaMultiplier*weight)));\n\n          dst(posx,posy) = finalOutput;\n        \}\n      \} \n  \}\n\n  //Calculate a Bilinear Plot\n  void bilinear_Plot(float2 temppos,float4 color,int index)\n  \{\n    float2 p;\n    p.x=Frac(temppos.x);\n    p.y=Frac(temppos.y);\n    float weights\[] = \{(1.0f-p.x)*(1.0f-p.y), p.x*(1.0f-p.y), (1.0f-p.x)*p.y, p.x*p.y\};\n    int2 _position = int2(floor(temppos.x)-0,floor(temppos.y)-0); \n    writepixel(_position.x,_position.y,color,index,weights\[0]);\n    writepixel(_position.x+1,_position.y,color,index,weights\[1]);\n    writepixel(_position.x,_position.y+1,color,index,weights\[2]);\n    writepixel(_position.x+1,_position.y+1,color,index,weights\[3]);\n  \}\n\n  //NYI, unused!\n  void gaussian(float2 temppos,float4 color,int index)\{\n    float in_x = temppos.x;\n    float in_y = temppos.y;\n    int kernelSize = (_pointSize+1)*2;\n    int subsize = (kernelSize /2)-1;\n    float gKernel\[64]\[64];\n    float sigma = _gaussigma;\n    float intSigma = float(_pointSize);\n    float r, s = intSigma * sigma * sigma;\n\n    float sum = 0.0f;\n\n    // generate 5x5 kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            r = float(sqrt(x*x + y*y));\n            gKernel\[x + subsize]\[y + subsize] = (exp(-(r*r)/s))/(3.141592654f * s);\n            sum += gKernel\[x + subsize]\[y + subsize];\n        \}\n    \}\n\n    // normalize the Kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            gKernel\[x + subsize]\[y + subsize] /= sum;\n            writepixel(in_x+x,in_y+y,color,index,gKernel\[x + subsize]\[y + subsize]);\n        \}\n    \}\n  \}\n\n//-------------------------------------\n// DrawLine\n// ----------\n// Draw a line between two points, \n// x,y being 2d screenspace pos and z being depth.\n//-------------------------------------\n  void DrawLine(float3 origin, float3 endpoint,float4 _colorA,float4 _colorB) \{\n    float4 _color;\n    float3 delta = origin-endpoint;\n    float3 curPoint = origin;\n    float mag = sqrt(delta.x*delta.x+delta.y*delta.y);\n    mag = min(mag,_maxLineSteps); //Lets not go crazy, we cap it at 10.000 to avoid insane unwated processing time \n    for( float a = 0; a < mag*_lineOffset; a = a + 1.0f )\{\n      curPoint -= (delta/mag);\n      _color = (_colorA*(1.0f-(a/mag*1.0f)))+(_colorB*(a/mag*1.00f));\n      if (_dof_enable)\{\n        Bokeh(curPoint,_color);\n      \}\n      else \{\n        if (_depthBuffer && isDepth) \{_color = float4(1.0f,1.0f,1.0f,curPoint.z);\} //Added\n        bilinear_Plot(float2(curPoint.x,curPoint.y),_color,1);\n      \}\n      \n    \}\n  \}\n\n//-------------------------------------\n// Point_Render\n//-------------------------------------\nvoid point_render(int2 pos, float3 screen_pos)\{\n  float4 color = src(pos.x,pos.y);\n\n  if (_filtering == 1)\{\n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        if (_depthBuffer) \{color.w = screen_pos.z;\} //Added\n        bilinear_Plot(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  /*\n  //THIS PART NEEDS TO BE RE-WRITTEN.\n  else if (_filtering == 2)\{ \n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        gaussian(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  */\n  else \{\n      int2 _position = int2(floor(screen_pos.x),floor(screen_pos.y)); \n      if (_depthBuffer) \{color.w = screen_pos.z;\}\n      writepixel(_position.x,_position.y, color,1,1.0f); //OutputSample\n  \}\n\n\}\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nvoid facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x+1,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos,V0_N,V1_N,V2_N;\n    float2 V0_ST,V1_ST,V2_ST;\n    float4 V1_Sample,V2_Sample;\n    float4 _tn;\n    float3 normal0,normal1,normal2;\n    float2 UV_Format = float2(Vformat.x,Vformat.y);\n\n\n    int2 P0 = int2(pos.x-1,pos.y-1);\n    int2 P1 = int2(pos.x+1,pos.y+1);\n    if (_plexConnectX && pos.x == int(Vformat.x))\{\n      insideX == true;\n      P1 = int2(0.0f,pos.y+1);\n    \}\n    if (_plexConnectY && pos.y == int(Vformat.y))\{\n      insideYtop == true;\n      P1 = int2(pos.x+1,0);\n    \} \n\n    if (_plexConnectY && pos.y == 0)\{\n      insideY == true;\n      P0 = int2(pos.x-1,int(UV_Format.y));\n    \} \n\n    if (!_flatshading) \{\n      _tn = normals(pos.x,pos.y);\n      V0_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n    V0_ST = float2(pos.x,pos.y)/UV_Format;\n\n  if (insideX) \{\n    V2_Sample = ppos(P1.x,pos.y);\n    V2_ST = float2(P1.x,pos.y)/UV_Format;\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (!_flatshading) \{\n      _tn = normals(P1.x,pos.y);\n      V2_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n        \n\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(P1.x,P0.y);\n        V1_ST = float2(P1.x,P0.y)/UV_Format;\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(P1.x,P0.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}\n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V2_Pos,V1_Pos,_vWorld,V2_wPos,V1_wPos,V0_N,V2_N,V1_N,V0_ST,V2_ST,V1_ST);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,P1.y);\n        V1_ST = float2(pos.x,P1.y)/UV_Format;        \n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(pos.x,P1.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}        \n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V1_Pos,V2_Pos,_vWorld,V1_wPos,V2_wPos,V0_N,V1_N,V2_N,V0_ST,V1_ST,V2_ST);\n        \}\n      \}\n    \}\n  \}\n\}\n\n\n\n//This function will calculate if pixel C is inside the triangle\nfloat edgeFunction(float3 a, float3 b, float3 c) \n\{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n\} \n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat Distance(float3 _a,float3 _b)\n\{\n          float xd = _a.x - _b.x;\n          float yd = _a.y - _b.y;\n          float zd = _a.z - _b.z;\n          return sqrt(xd*xd + yd*yd + zd*zd);\n\}\n\nvoid DrawTriangle(float3 V0, float3 V1, float3 V2,float3 WP0, float3 WP1, float3 WP2,float3 N0, float3 N1, float3 N2, float2 st0,float2 st1,float2 st2) \{\n\n  // Precompute reciprocal of vertex z-coordinate \n  V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n\n  float2 st0n = st0 * V0.z;\n  float2 st1n = st1 * V1.z; \n  float2 st2n = st2 * V2.z; //Normal version of ST\n\n  bool inside; \n  float X0 = Fmin(V0.x,V1.x,V2.x)-1.0f;\n  float X1 = Fmax(V0.x,V1.x,V2.x)+1.0f;\n  float Y0 = Fmin(V0.y,V1.y,V2.y)-1.0f;\n  float Y1 = Fmax(V0.y,V1.y,V2.y)+1.0f;\n  float area = edgeFunction(V2, V1, V0);\n\n\n  float2 sampos = float2(st0.x*float(Vformat.x),st0.y*float(Vformat.y));\n  float4 text0 = src(sampos.x,sampos.y);\n  sampos = float2(st1.x*float(Vformat.x),st1.y*float(Vformat.y));\n  float4 text1 = src(sampos.x,sampos.y);\n  sampos = float2(st2.x*float(Vformat.x),st2.y*float(Vformat.y));  //Why do we have to do this? =(\n  float4 text2 = src(sampos.x,sampos.y);\n  sampos = float2(min(min(st0.x,st1.x),st2.x)*float(Vformat.x),min(min(st0.y,st1.y),st2.y)*float(Vformat.y));\n  float4 text3 = src(sampos.x,sampos.y);\n\n\n  for( int x = X0; x < X1 ; x++) \{\n    for( int y = Y0; y < Y1 ; y++) \{\n      float3 pixelSample(x + _texoffset.x, y + _texoffset.y,0.0f); \n\n      //This is the part where we test if the current pixel is inside the triangle\n      //We check both for front facing and back faing options\n      float w0 = edgeFunction(V1, V0, pixelSample); //Front Facing\n      float w1 = edgeFunction(V2, V1, pixelSample); \n      float w2 = edgeFunction(V0, V2, pixelSample); \n      float w3 = edgeFunction(V0, V1, pixelSample); //Back Facing\n      float w4 = edgeFunction(V1, V2, pixelSample); \n      float w5 = edgeFunction(V2, V0, pixelSample);\n\n      //writepixel(x,y, float4(w1),1,1.0f);\n      if ((w0 >= 0 && w1 >= 0 && w2 >= 0 && _frontfacing) || (w3 >= 0 && w4 >= 0 && w5 >= 0 && _backfacing)) \{ //The curent pixel is inside the triangle\n\n       // calculate vectors from point f to vertices p1, p2 and p3:\n       float3 f1 = V0-pixelSample;\n       float3 f2 = V1-pixelSample;\n       float3 f3 = V2-pixelSample;\n       // calculate the areas and factors (order of parameters doesn't matter):\n       float a = length(cross(V0-V1,V0-V2 )); // main triangle area a\n       area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n        w0 /= area; \n        w1 /= area; \n        w2 /= area; \n\n        w3 /= area; \n        w4 /= area; \n        w5 /= area; \n\n       float a1 = length(cross(f2, f3)) / a; // p1's triangle area / a\n       float a2 = length(cross(f3, f1)) / a; // p2's triangle area / a \n       float a3 = length(cross(f1, f2)) / a; // p3's triangle area / a\n       float a_magnitude = a1+a2+a3;\n       a1 = a1/a_magnitude;\n       a2 = a2/a_magnitude;\n       a3 = a3/a_magnitude;\n       float z = 1.0f / (V0.z * a1 + V1.z * a2 + V2.z * a3); \n\n\n        // find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):\n        float2 uv = st0 * a1 + st1 * a2 + st2 * a3;\n        float2 st = st0 * w0 + st1 * w1 + st2 * w2; \n        st *= z;      \n\n\n        //Calculate normals. Eighter we have flat shading, else we calculate a normal per pixel\n        float3 normalB;\n        if (_flatshading) \{\n          normalB = CalculateSurfaceNormals(WP0,WP1,WP2);\n\n        \}\n        else \{\n          float3 c0 = N2/float3(V0.z); \n          float3 c1 = N0/float3(V1.z); \n          float3 c2 = N1/float3(V2.z);  \n\n          normalB.x = w0 * c0.x + w1 * c1.x + w2 * c2.x; \n          normalB.y = w0 * c0.y + w1 * c1.y + w2 * c2.y; \n          normalB.z = w0 * c0.z + w1 * c1.z + w2 * c2.z; \n\n          normalB.x *= z, normalB.y *= z, normalB.z *= z; \n        \}\n        normalB = normalize(normalB);\n\n        //CALCULATE THE OBJECT TEXTURE COORDINATES\n        float zn = 1.0f / (V0.z * w0 + V1.z * w1 + V2.z * w2); \n        st = st0n * w0 + st1n * w1 + st2n * w2; \n        st *= zn;   \n        //--END \n\n        float3 Wpos = WP0*a1 + WP1*a2 + WP2*a3; //World Position.\n        float3 ViewNormal = normalize(float3(cameraToWorld\[3]\[0],cameraToWorld\[3]\[1],cameraToWorld\[3]\[2])-Wpos);\n\n        float nDotView =  dot(normalB,ViewNormal);\n        nDotView = 1.0f-fabs(nDotView); //make sure that the view normal ramps back around when doing backface\n        float4 tempout;\n\n        //Flatshading or regular?\n        if (!_flatshading) \{\n          tempout = text0 * a1 + text1 * a2 + text2 * a3; \n        \}\n        else\{\n          tempout = text3;\n        \}\n\n        //Additional Render Modes\n        if (_vertexMode == 1)\{\n          tempout = float4(a1,a2,a3,1.0f);\n        \}\n        else if (_vertexMode == 2)\{\n          tempout = float4(normalB.x,normalB.y,normalB.z,1.0f);\n        \}\n        else if (_vertexMode == 3)\{\n          tempout = float4(nDotView,nDotView,nDotView,1.0f);\n        \}\n        else if (_vertexMode == 4)\{\n          tempout = float4(uv.x,uv.y,0.0f,1.0f);\n        \}       \n        else if (_vertexMode == 5)\{\n          tempout = float4(st.x,st.y,0.0f,1.0f);\n        \}               \n        else if (_vertexMode == 6)\{\n          tempout = float4(ViewNormal.x,ViewNormal.y,ViewNormal.z,1.0f);\n        \}             \n        else if (_vertexMode == 7)\{\n          tempout = float4(Wpos.x,Wpos.y,Wpos.z,1.0f);\n        \}   \n\n        if (_depthBuffer)\{\n          writepixel(x,y, float4(tempout.x,tempout.y,tempout.z,z),1,1.0f);  \n        \}\n        else \{\n          if (_dof_enable)\{\n            Bokeh(float3(x,y,z),float4(tempout.x,tempout.y,tempout.z,z));\n          \}\n          else \{\n            bilinear_Plot(float2(x,y),float4(tempout.x,tempout.y,tempout.z,z),1);\n          \}\n        \}\n\n      \}  \n\n    \}\n  \}\n\}\n\n//-------------------------------------\n// Wire_Render\n//-------------------------------------\nvoid wire_render(int2 pos) \{\n  float4 temp = float4(0.0f,0.0f,0.0f,FLT_MAX);\n  float4 wire_ref_sample;\n  int2 tempXY = int2(0,0);\n  float4 plexlist\[11] = \{temp,temp,temp,temp,temp,temp,temp,temp,temp,temp,temp\}; \n  int2 plexlistXY\[11] = \{tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY\};\n  int plex_count = 0; //We use this to figure how many points that should connect.\n  float plex_dist;\n  float3 plex_position,plex_position_b;\n  float4 temp_pos, temp_pos_b; //Temporary Position Containers\n  if (_maxPlexType == -1) \{ //Used for random connection types\n    for( int x = 0; x < max_line_connections ; x++)\{ //THIS 80 NUMBER IS THE LIMIT TO AVOID TOO SLOW PROCESSING!\n      for( int y = 0; y < max_line_connections ; y++)\{\n        wire_ref_sample = ppos(x,y);\n        if (wire_ref_sample.w != 0.0f && pos.x!=x && pos.y != y) \{ \n          plex_position = float3(wire_ref_sample.x,wire_ref_sample.y,wire_ref_sample.z)*(zoom);\n          float xd = plex_position.x - vWorld.x;\n          float yd = plex_position.y - vWorld.y;\n          float zd = plex_position.z - vWorld.z;\n          float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n          if (plex_dist<_maxPlexDistance)\{\n            plex_count = min(10,plex_count+1); //Add one to the count\n            for( int h = 0; h < plex_count+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n              if (plex_dist < plexlist\[h].w) \{                  \n                for( int i = plex_count+1; i > h ; i--) \{\n                  plexlist\[i] = plexlist\[i-1];\n                  plexlistXY\[i] = plexlistXY\[i-1];\n                \}\n                plexlist\[h] = float4(plex_position.x,plex_position.y,plex_position.z,plex_dist);\n                plexlistXY\[h] = int2(x,y);\n                break;        \n              \}\n            \}\n          \} \n        \}\n      \}\n    \}\n  \}\n  else\{ //Used for standard connection types\n    float4 temp_pos;\n    bool insideX = !(Vformat.x < pos.x+1);\n    bool insideY = !(Vformat.y < pos.y+1);\n\n\n    if (!_plexLinedefAUX)\{\n      temp_pos = normals(pos.x,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,vWorld+plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideX && !_plexLinedefX) \{\n      temp_pos = ppos(pos.x+1,pos.y );\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && !_plexLinedefX) \{\n      temp_pos = ppos(0,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideY && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\}                          \n    \}\n    else if ( _plexConnectY  && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,0);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    //_plexConnect\n    if ( insideX && insideY && !_plexLinedefXY) \{              \n      temp_pos = ppos(pos.x+1,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && _plexConnectY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && insideY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectY && insideX && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n  \}   \n\n  //now that all the connections have been sorted by distance then we connect the dots.\n  for( int x = 0; x < min(_maxPlexConnections,plex_count) ; x++)\{\n    plex_position = float3(plexlist\[x].x,plexlist\[x].y,plexlist\[x].z);\n    plex_dist = plexlist\[x].w;\n\n\n    float plex_distribution = 1.0f-((plexlist\[x].w-plexlist\[0].w)/((plexlist\[min(_maxPlexConnections,plex_count)].w-plexlist\[0].w)+0.00001f)); //Where does it lie between the best and the worst distance?\n    //plexlistXY\n\n    float4 plex_col = float4(pow(1.0f-(plex_dist/_maxPlexDistance),1.0f/_plex_gamma))*float4(plex_distribution); //This one is quite cool aswell, but does leave the center ones a bit too focused \n    float4 plex_colorA = src(pos.x,pos.y);\n    float4 plex_colorB = src( plexlistXY\[x].x,plexlistXY\[x].y);\n    plex_col *= 0.1f;\n\n    computePixelCoordinates(plex_position, pRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n    if (dst.bounds.inside(int(vRaster.x),int(vRaster.y)) || dst.bounds.inside(int(pRaster.x),int(pRaster.y)))\{\n        DrawLine(vRaster,pRaster,(plex_colorA*plex_col)*_lineInMultiplier,(plex_colorB*plex_col)*_lineOutMultiplier);\n    \}\n  \}\n\}\n\nvoid wire_connection(float3 p_source,float3 p_target, float4 (&p_plexlist)\[11], int2 (&p_plexlistXY)\[11],int &p_plexcount,int2 position) \{\n  float xd = p_target.x - p_source.x;\n  float yd = p_target.y - p_source.y;\n  float zd = p_target.z - p_source.z;\n  float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n  if (plex_dist<_maxPlexDistance)\{\n    p_plexcount = min(11,p_plexcount+1); //Add one to the count\n    for( int h = 0; h < p_plexcount+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n      if (plex_dist < p_plexlist\[h].w) \{                  \n        for( int i = p_plexcount+1; i > h ; i--) \{\n          p_plexlist\[i] = p_plexlist\[i-1];\n          p_plexlistXY\[i] = p_plexlistXY\[i-1];\n        \}\n        p_plexlist\[h] = float4(p_target.x,p_target.y,p_target.z,plex_dist);\n        p_plexlistXY\[h] = int2(position.x,position.y);\n        break;        \n      \}\n    \}  \n  \}\n\}\n//-------END OF WIRE RENDER FUNCTIONS---------\n\n\n\n\n//-------------------------------\n//-------BOKEH FUNCTIONS---------\n//thanks to: http://devlog-martinsh.blogspot.dk/2011/11/glsl-depth-of-field-with-bokeh-v21.html\nfloat2 rand(float2 coord) //generating noise/pattern texture for dithering\n\{\n  float noiseX = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.25)+(Frac(coord.y*(WHformat\[1]/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.75)+(Frac(coord.y*(WHformat\[1]/2.0))*0.25))*2.0-1.0;\n  noiseX = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f))) * 43758.5453f),0.0f,1.0f)*2.0f-1.0f;\n  noiseY = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f)*2.0f)) * 43758.5453f),0.0f,1.0f)*2.0-1.0f;\n  return float2(noiseX,noiseY);\n\}\n//-------------------------------------\n// Bokeh\n//-------------------------------------\nvoid Bokeh(float3 pos,float4 color)\{\n  float blur = 0.0;\n  blur = clamp((fabs(pos.z - focalDepth)/_depthOfField)*100.0f,-_maxDofSize,_maxDofSize);\n  \n  float w = (1.0/WHformat.x)*blur;//+noise.x;\n  float h = (1.0/(WHformat.x*dof_aspect))*blur;//+noise.y;\n  float3 v3_col = float3(color.x,color.y,color.z);\n  int ringsamples;\n  float s = 1.0;  \n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples; \n    for (int j = 0 ; j < ringsamples ; j += 1)  \n    \{ \n      s += (1.0f*mix(1.0f,(float(i))/(float(_dof_rings)),dof_bias)*1.0f); //No need to do this in the loop\n    \}\n  \}\n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples;\n     \n    for (int j = 0 ; j < ringsamples ; j += 1)   \n    \{\n      float step = PI*2.0 / float(ringsamples);\n      float pw = (cos(float(j)*step)*(float(i)/_dof_rings));\n      float ph = (sin(float(j)*step)*(float(i)/_dof_rings));\n      float p = 1.0;\n\n      float posx = pos.x+((pw*w)*blur);\n      float posy = pos.y+((ph*h)*blur);\n\n\n      float3 lumcoeff = float3(0.299,0.587,0.114);\n      float lum = dot(v3_col, lumcoeff);\n      float thresh = max((lum-dof_threshold)*dof_gain, 0.0f);\n      v3_col+mix(float3(0.0),v3_col,thresh*blur);\n\n      float3 col = (v3_col*mix(1.0,(float(i))/(float(_dof_rings)),dof_bias)*p)/s; \n      bilinear_Plot(float2(posx,posy),float4(col.x,col.y,col.z,color.w/(_dof_rings*_dof_rings)),1);\n    \}\n  \}\n\}\n//-------END OF BOKEH FUNCTIONS---------\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float2 posf = float2(pos.x,pos.y);\n\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n\n      //Convert worldspace coordinates to screenspcace coordinates.\n      vWorld = float3(_sample.x,_sample.y,_sample.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, vRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      if (ret) \{ //Only create points that are visible on screen\n        if (_pointRender)\{\n          point_render(pos,vRaster);\n        \}\n      \} //Pointrender over\n\n      if (_wireRender && _maxPlexConnections>=1) \{\n        if (max(pos.x,pos.y)<=max_line_connections || (_maxPlexType==0))\{ // Don't process more wires than allowed in nearest mode.\n          wire_render(pos);\n        \}\n      \} //WireRender over\n\n      if (_facetRender) \{\n        facet_render(pos,float3(_sample.x,_sample.y,_sample.z));\n      \}  //FacetRender over\n      \n    \}\n  \} //----> process\n\};\n"
  useGPUIfAvailable false
  rebuild ""
  PointRender3D_cam_Matrix {
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
    }
  PointRender3D_focallength {{parent.Camera1.focal}}
  PointRender3D_hapeture {{parent.Camera1.haperture}}
  PointRender3D_format {{!proxy?Settings_Format.width:Settings_Format.width*proxy_scale} {!proxy?Settings_Format.height:Settings_Format.height*proxy_scale}}
  PointRender3D_vertexformat {{parent.InputFormat.box.r-1} {parent.InputFormat.box.t-1}}
  PointRender3D__alphaMultiplier {{parent.AlphaMultiplier}}
  PointRender3D__pointRender {{parent.RenderMode==0}}
  PointRender3D__wireRender {{parent.RenderMode==1}}
  PointRender3D__facetRender {{parent.RenderMode==2}}
  PointRender3D__maxLDistance {{parent.wire_maxdistance}}
  PointRender3D__maxLConnections {{parent.wire_connections}}
  PointRender3D__maxPlexType {{-parent.wire_type}}
  PointRender3D__plexLinedefXY {{!parent.connect_xy}}
  PointRender3D__plexLinedefX {{!parent.connect_x}}
  PointRender3D__plexLinedefY {{!parent.connect_y}}
  PointRender3D__plexLinedefAUX {{!connect_aux}}
  PointRender3D__plexConnectX {{parent.CloseX}}
  PointRender3D__plexConnectY {{parent.CloseY}}
  PointRender3D__L_gamma {{parent.wire_Threshold}}
  "PointRender3D_Enable Depth of Field" {{parent.dof_enable}}
  PointRender3D_samples {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_rings {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_focalDepth {{parent.dof_focaldepth}}
  PointRender3D__depthOfField {{parent.dof_dof}}
  PointRender3D__depthMult 0
  PointRender3D__maxDofSize {{parent.dof_maxSize*400}}
  PointRender3D_dof_aspect {{parent.dof_Aspect}}
  PointRender3D_dof_bias {{parent.dof_bias}}
  PointRender3D__flatshading {{parent.facet_flatShading}}
  PointRender3D__backfacing {{parent.facet_backface}}
  PointRender3D__frontfacing {{parent.facet_front}}
  PointRender3D__vertexMode {{parent.renderMode}}
  PointRender3D__texoffset {-0.5 0.5}
  PointRender3D__pointSize 0
  PointRender3D__depthOcclusion {{parent.UseOcclusionMap}}
  PointRender3D__maxLineSteps {{parent.maxSamples}}
  PointRender3D__lineOffset {{parent.lineoffset}}
  PointRender3D__lineInMultiplier {{parent.inGain}}
  PointRender3D__lineOutMultiplier {{parent.outGain}}
  PointRender3D__overscan {{parent.overscan} {parent.overscan}}
  PointRender3D_isDepth true
  format "1280 720 0 0 1280 720 1 HD_720"
  rebuild_finalise ""
  name BlinkScriptZdepth
  label Zdepth
  xpos -28
  ypos 100
 }
 Dot {
  name Dot10
  xpos 97
  ypos 112
 }
 TimeBlur {
  divisions {{parent.Samples}}
  shutter {{parent.Shutter}}
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur1
  xpos 63
  ypos 300
  disable {{1-parent.mb_enable x89 0}}
 }
 Expression {
  expr3 a!=0?a/r:0
  name Expression3
  selected true
  xpos 63
  ypos 324
 }
 Dot {
  name Dot9
  xpos 97
  ypos 414
 }
push $N1d9118b0
push $N1d9dfb80
push $N1da1bef0
push $N1d962570
 BlinkScript {
  inputs 4
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Render/3D_PointRender_v17.cpp
  recompileCount 803
  ProgramGroup 1
  KernelDescription "2 \"PointRender3D\" iterate pixelWise 0c100cf8a634aa2c2e18f544ec8abfd6d5d138cc25ae8f7d7127230910c2e91f 5 \"ppos\" Read Random \"src\" Read Random \"normals\" Read Random \"occlusion\" Read Random \"dst\" Write Random 49 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"vertexformat\" Int 2 CgAAAAoAAAA= \"Zoom\" Float 1 AACAPw== \"Filtering Method\" Int 1 AQAAAA== \"_alphaMultiplier\" Float 1 AACAPw== \"_pointRender\" Bool 1 AQ== \"_wireRender\" Bool 1 AQ== \"_facetRender\" Bool 1 AQ== \"_maxLDistance\" Float 1 AACAPw== \"_maxLConnections\" Int 1 AQAAAA== \"_maxPlexType\" Int 1 AAAAAA== \"_plexLinedefXY\" Bool 1 AA== \"_plexLinedefX\" Bool 1 AA== \"_plexLinedefY\" Bool 1 AA== \"_plexLinedefXtoY\" Bool 1 AA== \"_plexLinedefAUX\" Bool 1 AA== \"_plexConnectX\" Bool 1 AA== \"_plexConnectY\" Bool 1 AA== \"_L_gamma\" Float 1 AACAPw== \"Enable Depth of Field\" Bool 1 AA== \"samples\" Int 1 AwAAAA== \"rings\" Int 1 BQAAAA== \"focalDepth\" Float 1 AACAPw== \"_depthOfField\" Float 1 AACAQA== \"_depthMult\" Float 1 zczMPQ== \"_maxDofSize\" Float 1 AAAAQQ== \"dof_aspect\" Float 1 AACAPw== \"dof_threshold\" Float 1 AACAPw== \"dof_gain\" Float 1 AAAAAA== \"dof_bias\" Float 1 AAAAwA== \"dof_fringe\" Float 1 AAAAAA== \"_flatshading\" Bool 1 AQ== \"_backfacing\" Bool 1 AQ== \"_frontfacing\" Bool 1 AQ== \"_vertexMode\" Int 1 AAAAAA== \"_depthBuffer\" Bool 1 AQ== \"_texoffset\" Float 2 AAAAPwAAAD8= \"_pointSize\" Int 1 AQAAAA== \"_gaussigma\" Float 1 AACAPw== \"_depthOcclusion\" Bool 1 AQ== \"depthMultiplier\" Float 1 AACAPw== \"_maxLineSteps\" Float 1 AAB6RQ== \"_lineOffset\" Float 1 AACAPw== \"_lineInMultiplier\" Float 1 AACAPw== \"_lineOutMultiplier\" Float 1 AACAPw== \"_overscan\" Float 2 AAAAAAAAAAA= 49 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"Vformat\" 2 1 \"zoom\" 1 1 \"_filtering\" 1 1 \"_alphaMultiplier\" 1 1 \"_pointRender\" 1 1 \"_wireRender\" 1 1 \"_facetRender\" 1 1 \"_maxPlexDistance\" 1 1 \"_maxPlexConnections\" 1 1 \"_maxPlexType\" 1 1 \"_plexLinedefXY\" 1 1 \"_plexLinedefX\" 1 1 \"_plexLinedefY\" 1 1 \"_plexLinedefXtoY\" 1 1 \"_plexLinedefAUX\" 1 1 \"_plexConnectX\" 1 1 \"_plexConnectY\" 1 1 \"_plex_gamma\" 1 1 \"_dof_enable\" 1 1 \"_dof_samples\" 1 1 \"_dof_rings\" 1 1 \"focalDepth\" 1 1 \"_depthOfField\" 1 1 \"_depthMult\" 1 1 \"_maxDofSize\" 1 1 \"dof_aspect\" 1 1 \"dof_threshold\" 1 1 \"dof_gain\" 1 1 \"dof_bias\" 1 1 \"dof_fringe\" 1 1 \"_flatshading\" 1 1 \"_backfacing\" 1 1 \"_frontfacing\" 1 1 \"_vertexMode\" 1 1 \"_depthBuffer\" 1 1 \"_texoffset\" 2 1 \"_pointSize\" 1 1 \"_gaussigma\" 1 1 \"_depthOcclusion\" 1 1 \"depthMultiplier\" 1 1 \"_maxLineSteps\" 1 1 \"_lineOffset\" 1 1 \"_lineInMultiplier\" 1 1 \"_lineOutMultiplier\" 1 1 \"_overscan\" 2 1 10 \"max_line_connections\" Int 1 1 AAAAAA== \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "//Some basic generic functions.\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float3 Cross(float3 A,float3 B)\n\{\n    return float3(A.y*B.z - A.z*B.y,A.z*B.x - A.x*B.z,A.x*B.y - A.y*B.x);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}     \n\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\ninline float mix(float _X,float _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}                                                                                              \n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n\n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight,\n    float2 overscan\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f-overscan.x || pRaster.x > imageWidth+overscan.x || \n       pRaster.y < 0.0f-overscan.y || pRaster.y > imageHeight+overscan.y || pRaster.z < 0.0f) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eRead, eAccessRandom, eEdgeClamped> src;     //The texture map\n  Image<eRead, eAccessRandom, eEdgeClamped> normals;     //The texture map  \n  Image<eRead, eAccessRandom, eEdgeClamped> occlusion;     //The texture map \n  Image<eWrite, eAccessRandom> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat,Vformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    int _filtering;        //Filter method\n    float _alphaMultiplier; //Additive multiplier\n    bool _pointRender,_wireRender,_facetRender;\n    float _maxPlexDistance; //Additive multiplier\n    int _maxPlexConnections;\n    int _maxPlexType; // 0==Grid, -1==Nearest\n    bool _plexLinedefXY,_plexLinedefX,_plexLinedefY,_plexLinedefXtoY,_plexLinedefAUX; // Define what connections NOT to include\n    bool _plexConnectX,_plexConnectY; //Connect from the edge of x to 0, or edge of y to 0, usually for spheres\n    float _plex_gamma; //The threshold making shorter paths bright and longer paths dark\n    bool _dof_enable; // Enable DOF\n    int _dof_samples; // How many samples per DOF ring\n    int _dof_rings; // How many rings \n    float focalDepth,_depthOfField,_depthMult,_maxDofSize; //DOF Settings\n    float dof_aspect; //Pixel aspect ratio\n    float dof_threshold;\n    float dof_gain;\n    float dof_bias; //bokeh edge bias\n    float dof_fringe; //bokeh chromatic aberration/fringing\n    bool _flatshading,_backfacing,_frontfacing; //Vertex rendering settings\n    int _vertexMode;  //The rendering output mode, (think AOV)\n    bool _depthBuffer; //Non-additive, only render front most pixel\n    float2 _texoffset;\n    int _pointSize;\n    float _gaussigma;\n    bool _depthOcclusion;\n    float depthMultiplier;\n    float _maxLineSteps; //cap the line length to avoid process lock\n    float _lineOffset; //Alow you to shrink or extend the lines\n    float _lineInMultiplier,_lineOutMultiplier; //Control the brightness of the wires at the tips.\n    float2 _overscan; //This will allow you to render some extra outside the bounds of the image.\n\n  local: //Local variables\n    int max_line_connections;\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(Vformat,      \"vertexformat\", int2(10,10));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(_filtering, \"Filtering Method\", 1); \n    defineParam(_alphaMultiplier, \"_alphaMultiplier\", 1.0f);     \n    defineParam(_pointRender, \"_pointRender\", true);  \n    defineParam(_wireRender, \"_wireRender\", true);\n    defineParam(_facetRender, \"_facetRender\", true);\n    defineParam(_maxPlexDistance, \"_maxLDistance\", 1.0f);    \n    defineParam(_maxPlexConnections, \"_maxLConnections\", 1);    \n    defineParam(_maxPlexType, \"_maxPlexType\", 0); \n    defineParam(_plexLinedefXY, \"_plexLinedefXY\", false);      \n    defineParam(_plexLinedefXtoY, \"_plexLinedefXtoY\", false); //NYI\n    defineParam(_plexLinedefAUX, \"_plexLinedefAUX\", false); \n    defineParam(_plexLinedefX, \"_plexLinedefX\", false);  \n    defineParam(_plexLinedefY, \"_plexLinedefY\", false);  \n    defineParam(_plexConnectX, \"_plexConnectX\", false);      \n    defineParam(_plexConnectY, \"_plexConnectY\", false);   \n    defineParam(_plex_gamma, \"_L_gamma\", 1.0f);\n    //DOF SETTINGS   \n    defineParam(_dof_enable, \"Enable Depth of Field\", false);   \n    defineParam(_dof_samples, \"samples\", 3);    \n    defineParam(_dof_rings, \"rings\", 5);   \n    defineParam(focalDepth, \"focalDepth\", 1.0f);  \n    defineParam(_depthOfField, \"_depthOfField\", 4.0f);  \n    defineParam(_depthMult, \"_depthMult\", 0.1f);  \n    defineParam(_maxDofSize, \"_maxDofSize\", 8.0f);  \n    defineParam(dof_aspect, \"dof_aspect\", 1.0f);  \n    defineParam(dof_threshold, \"dof_threshold\", 1.0f);  \n    defineParam(dof_gain, \"dof_gain\", 0.0f);  \n    defineParam(dof_bias, \"dof_bias\", -2.0f);  \n    defineParam(dof_fringe, \"dof_fringe\", 0.0f); \n    //SHADING SETTINGS \n    defineParam(_flatshading, \"_flatshading\", true);  \n    defineParam(_vertexMode, \"_vertexMode\", 0);  \n    defineParam(_backfacing, \"_backfacing\", true);    \n    defineParam(_frontfacing, \"_frontfacing\", true);        \n    defineParam(_depthBuffer, \"_depthBuffer\", true);  \n    defineParam(_texoffset, \"_texoffset\", float2(0.5f,0.5f)); \n    defineParam(_pointSize, \"_pointSize\", 1); \n    defineParam(_gaussigma, \"_gaussigma\", 1.0f); \n    defineParam(_depthOcclusion, \"_depthOcclusion\", true); \n    defineParam(depthMultiplier, \"depthMultiplier\", 1.0f); \n    defineParam(_maxLineSteps, \"_maxLineSteps\", 4000.0f); \n    defineParam(_lineOffset, \"_lineOffset\", 1.0f); \n    defineParam(_lineInMultiplier, \"_lineInMultiplier\", 1.0f);   \n    defineParam(_lineOutMultiplier, \"_lineOutMultiplier\", 1.0f);     \n    defineParam(_overscan, \"_overscan\",float2(0.0f,0.0f));    \n\n  \}\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    max_line_connections = 80;\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n  \}\n\n  //Convert a 3d point position into a 2d raster position.\n  float3 Reconsile3D(float3 _PointPos)\{\n      vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      return tRaster;\n  \}\n\n//------------------------------\n//-------DRAW FUNCTIONS---------\n//------------------------------\n  //Write pixels to output.\n  void writepixel(float posx,float posy, float4 color,int index,float weight=1.0f)\n  \{ \n      if (_depthOcclusion)\{\n        float4 depthSample = occlusion(posx,posy);\n        if (depthSample.x<=vRaster.z && depthSample.w>0.0f)\{\n\n          float depth = (vRaster.z-depthSample.x);\n          color = color*(1.0f-depthSample.w);\n          color = color / (((depth*depth)*depthMultiplier)+1.0f);\n          //return;\n        \}\n      \}\n      float4 finalOutput; //This is used to store the final output\n      float4 dstSample; //This is used to store a sample of the destination\n      if ( dst.bounds.inside( posx, posy ) ) \{ //Test if the pixel written to is inside the output image. \n        if (_depthBuffer) \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          if ((dstSample.w>color.w)||dstSample.w==0.0f) \{\n            dst(posx,posy) = color;\n          \}\n        \}\n        else \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          finalOutput = dstSample + (color*_alphaMultiplier*weight);\n          finalOutput.w = dstSample.w + ((color.w*_alphaMultiplier*weight));\n\n          finalOutput.w = (dstSample.w + ((color.w*_alphaMultiplier*weight)))-(dstSample.w * ((color.w*_alphaMultiplier*weight)));\n\n          dst(posx,posy) = finalOutput;\n        \}\n      \} \n  \}\n\n  //Calculate a Bilinear Plot\n  void bilinear_Plot(float2 temppos,float4 color,int index)\n  \{\n    float2 p;\n    p.x=Frac(temppos.x);\n    p.y=Frac(temppos.y);\n    float weights\[] = \{(1.0f-p.x)*(1.0f-p.y), p.x*(1.0f-p.y), (1.0f-p.x)*p.y, p.x*p.y\};\n    int2 _position = int2(floor(temppos.x)-0,floor(temppos.y)-0); \n    writepixel(_position.x,_position.y,color,index,weights\[0]);\n    writepixel(_position.x+1,_position.y,color,index,weights\[1]);\n    writepixel(_position.x,_position.y+1,color,index,weights\[2]);\n    writepixel(_position.x+1,_position.y+1,color,index,weights\[3]);\n  \}\n\n  //NYI, unused!\n  void gaussian(float2 temppos,float4 color,int index)\{\n    float in_x = temppos.x;\n    float in_y = temppos.y;\n    int kernelSize = (_pointSize+1)*2;\n    int subsize = (kernelSize /2)-1;\n    float gKernel\[64]\[64];\n    float sigma = _gaussigma;\n    float intSigma = float(_pointSize);\n    float r, s = intSigma * sigma * sigma;\n\n    float sum = 0.0f;\n\n    // generate 5x5 kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            r = float(sqrt(x*x + y*y));\n            gKernel\[x + subsize]\[y + subsize] = (exp(-(r*r)/s))/(3.141592654f * s);\n            sum += gKernel\[x + subsize]\[y + subsize];\n        \}\n    \}\n\n    // normalize the Kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            gKernel\[x + subsize]\[y + subsize] /= sum;\n            writepixel(in_x+x,in_y+y,color,index,gKernel\[x + subsize]\[y + subsize]);\n        \}\n    \}\n  \}\n\n//-------------------------------------\n// DrawLine\n// ----------\n// Draw a line between two points, \n// x,y being 2d screenspace pos and z being depth.\n//-------------------------------------\n  void DrawLine(float3 origin, float3 endpoint,float4 _colorA,float4 _colorB) \{\n    float4 _color;\n    float3 delta = origin-endpoint;\n    float3 curPoint = origin;\n    float mag = sqrt(delta.x*delta.x+delta.y*delta.y);\n    mag = min(mag,_maxLineSteps); //Lets not go crazy, we cap it at 10.000 to avoid insane unwated processing time \n    for( float a = 0; a < mag*_lineOffset; a = a + 1.0f )\{\n      curPoint -= (delta/mag);\n      _color = (_colorA*(1.0f-(a/mag*1.0f)))+(_colorB*(a/mag*1.00f));\n      if (_dof_enable)\{\n        Bokeh(curPoint,_color);\n      \}\n      else \{\n        bilinear_Plot(float2(curPoint.x,curPoint.y),_color,1);\n      \}\n      \n    \}\n  \}\n\n//-------------------------------------\n// Point_Render\n//-------------------------------------\nvoid point_render(int2 pos, float3 screen_pos)\{\n  float4 color = src(pos.x,pos.y);\n\n  if (_filtering == 1)\{\n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        if (_depthBuffer) \{color.w = screen_pos.z;\} //Added\n        bilinear_Plot(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  /*\n  //THIS PART NEEDS TO BE RE-WRITTEN.\n  else if (_filtering == 2)\{ \n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        gaussian(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  */\n  else \{\n      int2 _position = int2(floor(screen_pos.x),floor(screen_pos.y)); \n      if (_depthBuffer) \{color.w = screen_pos.z;\}\n      writepixel(_position.x,_position.y, color,1,1.0f); //OutputSample\n  \}\n\n\}\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nvoid facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x+1,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos,V0_N,V1_N,V2_N;\n    float2 V0_ST,V1_ST,V2_ST;\n    float4 V1_Sample,V2_Sample;\n    float4 _tn;\n    float3 normal0,normal1,normal2;\n    float2 UV_Format = float2(Vformat.x,Vformat.y);\n\n\n    int2 P0 = int2(pos.x-1,pos.y-1);\n    int2 P1 = int2(pos.x+1,pos.y+1);\n    if (_plexConnectX && pos.x == int(Vformat.x))\{\n      insideX == true;\n      P1 = int2(0.0f,pos.y+1);\n    \}\n    if (_plexConnectY && pos.y == int(Vformat.y))\{\n      insideYtop == true;\n      P1 = int2(pos.x+1,0);\n    \} \n\n    if (_plexConnectY && pos.y == 0)\{\n      insideY == true;\n      P0 = int2(pos.x-1,int(UV_Format.y));\n    \} \n\n    if (!_flatshading) \{\n      _tn = normals(pos.x,pos.y);\n      V0_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n    V0_ST = float2(pos.x,pos.y)/UV_Format;\n\n  if (insideX) \{\n    V2_Sample = ppos(P1.x,pos.y);\n    V2_ST = float2(P1.x,pos.y)/UV_Format;\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (!_flatshading) \{\n      _tn = normals(P1.x,pos.y);\n      V2_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n        \n\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(P1.x,P0.y);\n        V1_ST = float2(P1.x,P0.y)/UV_Format;\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(P1.x,P0.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}\n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V2_Pos,V1_Pos,_vWorld,V2_wPos,V1_wPos,V0_N,V2_N,V1_N,V0_ST,V2_ST,V1_ST);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,P1.y);\n        V1_ST = float2(pos.x,P1.y)/UV_Format;        \n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(pos.x,P1.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}        \n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V1_Pos,V2_Pos,_vWorld,V1_wPos,V2_wPos,V0_N,V1_N,V2_N,V0_ST,V1_ST,V2_ST);\n        \}\n      \}\n    \}\n  \}\n\}\n\n\n\n//This function will calculate if pixel C is inside the triangle\nfloat edgeFunction(float3 a, float3 b, float3 c) \n\{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n\} \n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat Distance(float3 _a,float3 _b)\n\{\n          float xd = _a.x - _b.x;\n          float yd = _a.y - _b.y;\n          float zd = _a.z - _b.z;\n          return sqrt(xd*xd + yd*yd + zd*zd);\n\}\n\nvoid DrawTriangle(float3 V0, float3 V1, float3 V2,float3 WP0, float3 WP1, float3 WP2,float3 N0, float3 N1, float3 N2, float2 st0,float2 st1,float2 st2) \{\n\n  // Precompute reciprocal of vertex z-coordinate \n  V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n\n  float2 st0n = st0 * V0.z;\n  float2 st1n = st1 * V1.z; \n  float2 st2n = st2 * V2.z; //Normal version of ST\n\n  bool inside; \n  float X0 = Fmin(V0.x,V1.x,V2.x)-1.0f;\n  float X1 = Fmax(V0.x,V1.x,V2.x)+1.0f;\n  float Y0 = Fmin(V0.y,V1.y,V2.y)-1.0f;\n  float Y1 = Fmax(V0.y,V1.y,V2.y)+1.0f;\n  float area = edgeFunction(V2, V1, V0);\n\n\n  float2 sampos = float2(st0.x*float(Vformat.x),st0.y*float(Vformat.y));\n  float4 text0 = src(sampos.x,sampos.y);\n  sampos = float2(st1.x*float(Vformat.x),st1.y*float(Vformat.y));\n  float4 text1 = src(sampos.x,sampos.y);\n  sampos = float2(st2.x*float(Vformat.x),st2.y*float(Vformat.y));  //Why do we have to do this? =(\n  float4 text2 = src(sampos.x,sampos.y);\n  sampos = float2(min(min(st0.x,st1.x),st2.x)*float(Vformat.x),min(min(st0.y,st1.y),st2.y)*float(Vformat.y));\n  float4 text3 = src(sampos.x,sampos.y);\n\n\n  for( int x = X0; x < X1 ; x++) \{\n    for( int y = Y0; y < Y1 ; y++) \{\n      float3 pixelSample(x + _texoffset.x, y + _texoffset.y,0.0f); \n\n      //This is the part where we test if the current pixel is inside the triangle\n      //We check both for front facing and back faing options\n      float w0 = edgeFunction(V1, V0, pixelSample); //Front Facing\n      float w1 = edgeFunction(V2, V1, pixelSample); \n      float w2 = edgeFunction(V0, V2, pixelSample); \n      float w3 = edgeFunction(V0, V1, pixelSample); //Back Facing\n      float w4 = edgeFunction(V1, V2, pixelSample); \n      float w5 = edgeFunction(V2, V0, pixelSample);\n\n      //writepixel(x,y, float4(w1),1,1.0f);\n      if ((w0 >= 0 && w1 >= 0 && w2 >= 0 && _frontfacing) || (w3 >= 0 && w4 >= 0 && w5 >= 0 && _backfacing)) \{ //The curent pixel is inside the triangle\n\n       // calculate vectors from point f to vertices p1, p2 and p3:\n       float3 f1 = V0-pixelSample;\n       float3 f2 = V1-pixelSample;\n       float3 f3 = V2-pixelSample;\n       // calculate the areas and factors (order of parameters doesn't matter):\n       float a = length(cross(V0-V1,V0-V2 )); // main triangle area a\n       area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n        w0 /= area; \n        w1 /= area; \n        w2 /= area; \n\n        w3 /= area; \n        w4 /= area; \n        w5 /= area; \n\n       float a1 = length(cross(f2, f3)) / a; // p1's triangle area / a\n       float a2 = length(cross(f3, f1)) / a; // p2's triangle area / a \n       float a3 = length(cross(f1, f2)) / a; // p3's triangle area / a\n       float a_magnitude = a1+a2+a3;\n       a1 = a1/a_magnitude;\n       a2 = a2/a_magnitude;\n       a3 = a3/a_magnitude;\n       float z = 1.0f / (V0.z * a1 + V1.z * a2 + V2.z * a3); \n\n\n        // find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):\n        float2 uv = st0 * a1 + st1 * a2 + st2 * a3;\n        float2 st = st0 * w0 + st1 * w1 + st2 * w2; \n        st *= z;      \n\n\n        //Calculate normals. Eighter we have flat shading, else we calculate a normal per pixel\n        float3 normalB;\n        if (_flatshading) \{\n          normalB = CalculateSurfaceNormals(WP0,WP1,WP2);\n\n        \}\n        else \{\n          float3 c0 = N2/float3(V0.z); \n          float3 c1 = N0/float3(V1.z); \n          float3 c2 = N1/float3(V2.z);  \n\n          normalB.x = w0 * c0.x + w1 * c1.x + w2 * c2.x; \n          normalB.y = w0 * c0.y + w1 * c1.y + w2 * c2.y; \n          normalB.z = w0 * c0.z + w1 * c1.z + w2 * c2.z; \n\n          normalB.x *= z, normalB.y *= z, normalB.z *= z; \n        \}\n        normalB = normalize(normalB);\n\n        //CALCULATE THE OBJECT TEXTURE COORDINATES\n        float zn = 1.0f / (V0.z * w0 + V1.z * w1 + V2.z * w2); \n        st = st0n * w0 + st1n * w1 + st2n * w2; \n        st *= zn;   \n        //--END \n\n        float3 Wpos = WP0*a1 + WP1*a2 + WP2*a3; //World Position.\n        float3 ViewNormal = normalize(float3(cameraToWorld\[3]\[0],cameraToWorld\[3]\[1],cameraToWorld\[3]\[2])-Wpos);\n\n        float nDotView =  dot(normalB,ViewNormal);\n        nDotView = 1.0f-fabs(nDotView); //make sure that the view normal ramps back around when doing backface\n        float4 tempout;\n\n        //Flatshading or regular?\n        if (!_flatshading) \{\n          tempout = text0 * a1 + text1 * a2 + text2 * a3; \n        \}\n        else\{\n          tempout = text3;\n        \}\n\n        //Additional Render Modes\n        if (_vertexMode == 1)\{\n          tempout = float4(a1,a2,a3,1.0f);\n        \}\n        else if (_vertexMode == 2)\{\n          tempout = float4(normalB.x,normalB.y,normalB.z,1.0f);\n        \}\n        else if (_vertexMode == 3)\{\n          tempout = float4(nDotView,nDotView,nDotView,1.0f);\n        \}\n        else if (_vertexMode == 4)\{\n          tempout = float4(uv.x,uv.y,0.0f,1.0f);\n        \}       \n        else if (_vertexMode == 5)\{\n          tempout = float4(st.x,st.y,0.0f,1.0f);\n        \}               \n        else if (_vertexMode == 6)\{\n          tempout = float4(ViewNormal.x,ViewNormal.y,ViewNormal.z,1.0f);\n        \}             \n        else if (_vertexMode == 7)\{\n          tempout = float4(Wpos.x,Wpos.y,Wpos.z,1.0f);\n        \}   \n\n        if (_depthBuffer)\{\n          writepixel(x,y, float4(tempout.x,tempout.y,tempout.z,z),1,1.0f);  \n        \}\n        else \{\n          if (_dof_enable)\{\n            Bokeh(float3(x,y,z),float4(tempout.x,tempout.y,tempout.z,z));\n          \}\n          else \{\n            bilinear_Plot(float2(x,y),float4(tempout.x,tempout.y,tempout.z,z),1);\n          \}\n        \}\n\n      \}  \n\n    \}\n  \}\n\}\n\n//-------------------------------------\n// Wire_Render\n//-------------------------------------\nvoid wire_render(int2 pos) \{\n  float4 temp = float4(0.0f,0.0f,0.0f,FLT_MAX);\n  float4 wire_ref_sample;\n  int2 tempXY = int2(0,0);\n  float4 plexlist\[11] = \{temp,temp,temp,temp,temp,temp,temp,temp,temp,temp,temp\}; \n  int2 plexlistXY\[11] = \{tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY\};\n  int plex_count = 0; //We use this to figure how many points that should connect.\n  float plex_dist;\n  float3 plex_position,plex_position_b;\n  float4 temp_pos, temp_pos_b; //Temporary Position Containers\n  if (_maxPlexType == -1) \{ //Used for random connection types\n    for( int x = 0; x < max_line_connections ; x++)\{ //THIS 80 NUMBER IS THE LIMIT TO AVOID TOO SLOW PROCESSING!\n      for( int y = 0; y < max_line_connections ; y++)\{\n        wire_ref_sample = ppos(x,y);\n        if (wire_ref_sample.w != 0.0f && pos.x!=x && pos.y != y) \{ \n          plex_position = float3(wire_ref_sample.x,wire_ref_sample.y,wire_ref_sample.z)*(zoom);\n          float xd = plex_position.x - vWorld.x;\n          float yd = plex_position.y - vWorld.y;\n          float zd = plex_position.z - vWorld.z;\n          float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n          if (plex_dist<_maxPlexDistance)\{\n            plex_count = min(10,plex_count+1); //Add one to the count\n            for( int h = 0; h < plex_count+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n              if (plex_dist < plexlist\[h].w) \{                  \n                for( int i = plex_count+1; i > h ; i--) \{\n                  plexlist\[i] = plexlist\[i-1];\n                  plexlistXY\[i] = plexlistXY\[i-1];\n                \}\n                plexlist\[h] = float4(plex_position.x,plex_position.y,plex_position.z,plex_dist);\n                plexlistXY\[h] = int2(x,y);\n                break;        \n              \}\n            \}\n          \} \n        \}\n      \}\n    \}\n  \}\n  else\{ //Used for standard connection types\n    float4 temp_pos;\n    bool insideX = !(Vformat.x < pos.x+1);\n    bool insideY = !(Vformat.y < pos.y+1);\n\n\n    if (!_plexLinedefAUX)\{\n      temp_pos = normals(pos.x,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,vWorld+plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideX && !_plexLinedefX) \{\n      temp_pos = ppos(pos.x+1,pos.y );\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && !_plexLinedefX) \{\n      temp_pos = ppos(0,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideY && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\}                          \n    \}\n    else if ( _plexConnectY  && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,0);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    //_plexConnect\n    if ( insideX && insideY && !_plexLinedefXY) \{              \n      temp_pos = ppos(pos.x+1,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && _plexConnectY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && insideY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectY && insideX && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n  \}   \n\n  //now that all the connections have been sorted by distance then we connect the dots.\n  for( int x = 0; x < min(_maxPlexConnections,plex_count) ; x++)\{\n    plex_position = float3(plexlist\[x].x,plexlist\[x].y,plexlist\[x].z);\n    plex_dist = plexlist\[x].w;\n\n\n    float plex_distribution = 1.0f-((plexlist\[x].w-plexlist\[0].w)/((plexlist\[min(_maxPlexConnections,plex_count)].w-plexlist\[0].w)+0.00001f)); //Where does it lie between the best and the worst distance?\n    //plexlistXY\n\n    float4 plex_col = float4(pow(1.0f-(plex_dist/_maxPlexDistance),1.0f/_plex_gamma))*float4(plex_distribution); //This one is quite cool aswell, but does leave the center ones a bit too focused \n    float4 plex_colorA = src(pos.x,pos.y);\n    float4 plex_colorB = src( plexlistXY\[x].x,plexlistXY\[x].y);\n    plex_col *= 0.1f;\n\n    computePixelCoordinates(plex_position, pRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n    if (dst.bounds.inside(int(vRaster.x),int(vRaster.y)) || dst.bounds.inside(int(pRaster.x),int(pRaster.y)))\{\n        DrawLine(vRaster,pRaster,(plex_colorA*plex_col)*_lineInMultiplier,(plex_colorB*plex_col)*_lineOutMultiplier);\n    \}\n  \}\n\}\n\nvoid wire_connection(float3 p_source,float3 p_target, float4 (&p_plexlist)\[11], int2 (&p_plexlistXY)\[11],int &p_plexcount,int2 position) \{\n  float xd = p_target.x - p_source.x;\n  float yd = p_target.y - p_source.y;\n  float zd = p_target.z - p_source.z;\n  float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n  if (plex_dist<_maxPlexDistance)\{\n    p_plexcount = min(11,p_plexcount+1); //Add one to the count\n    for( int h = 0; h < p_plexcount+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n      if (plex_dist < p_plexlist\[h].w) \{                  \n        for( int i = p_plexcount+1; i > h ; i--) \{\n          p_plexlist\[i] = p_plexlist\[i-1];\n          p_plexlistXY\[i] = p_plexlistXY\[i-1];\n        \}\n        p_plexlist\[h] = float4(p_target.x,p_target.y,p_target.z,plex_dist);\n        p_plexlistXY\[h] = int2(position.x,position.y);\n        break;        \n      \}\n    \}  \n  \}\n\}\n//-------END OF WIRE RENDER FUNCTIONS---------\n\n\n\n\n//-------------------------------\n//-------BOKEH FUNCTIONS---------\n//thanks to: http://devlog-martinsh.blogspot.dk/2011/11/glsl-depth-of-field-with-bokeh-v21.html\nfloat2 rand(float2 coord) //generating noise/pattern texture for dithering\n\{\n  float noiseX = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.25)+(Frac(coord.y*(WHformat\[1]/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.75)+(Frac(coord.y*(WHformat\[1]/2.0))*0.25))*2.0-1.0;\n  noiseX = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f))) * 43758.5453f),0.0f,1.0f)*2.0f-1.0f;\n  noiseY = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f)*2.0f)) * 43758.5453f),0.0f,1.0f)*2.0-1.0f;\n  return float2(noiseX,noiseY);\n\}\n//-------------------------------------\n// Bokeh\n//-------------------------------------\nvoid Bokeh(float3 pos,float4 color)\{\n  float blur = 0.0;\n  blur = clamp((fabs(pos.z - focalDepth)/_depthOfField)*100.0f,-_maxDofSize,_maxDofSize);\n  \n  float w = (1.0/WHformat.x)*blur;//+noise.x;\n  float h = (1.0/(WHformat.x*dof_aspect))*blur;//+noise.y;\n  float3 v3_col = float3(color.x,color.y,color.z);\n  int ringsamples;\n  float s = 1.0;  \n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples; \n    for (int j = 0 ; j < ringsamples ; j += 1)  \n    \{ \n      s += (1.0f*mix(1.0f,(float(i))/(float(_dof_rings)),dof_bias)*1.0f); //No need to do this in the loop\n    \}\n  \}\n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples;\n     \n    for (int j = 0 ; j < ringsamples ; j += 1)   \n    \{\n      float step = PI*2.0 / float(ringsamples);\n      float pw = (cos(float(j)*step)*(float(i)/_dof_rings));\n      float ph = (sin(float(j)*step)*(float(i)/_dof_rings));\n      float p = 1.0;\n\n      float posx = pos.x+((pw*w)*blur);\n      float posy = pos.y+((ph*h)*blur);\n\n\n      float3 lumcoeff = float3(0.299,0.587,0.114);\n      float lum = dot(v3_col, lumcoeff);\n      float thresh = max((lum-dof_threshold)*dof_gain, 0.0f);\n      v3_col+mix(float3(0.0),v3_col,thresh*blur);\n\n      float3 col = (v3_col*mix(1.0,(float(i))/(float(_dof_rings)),dof_bias)*p)/s; \n      bilinear_Plot(float2(posx,posy),float4(col.x,col.y,col.z,color.w/(_dof_rings*_dof_rings)),1);\n    \}\n  \}\n\}\n//-------END OF BOKEH FUNCTIONS---------\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float2 posf = float2(pos.x,pos.y);\n\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n\n      //Convert worldspace coordinates to screenspcace coordinates.\n      vWorld = float3(_sample.x,_sample.y,_sample.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, vRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      if (ret) \{ //Only create points that are visible on screen\n        if (_pointRender)\{\n          point_render(pos,vRaster);\n        \}\n      \} //Pointrender over\n\n      if (_wireRender && _maxPlexConnections>=1) \{\n        if (max(pos.x,pos.y)<=max_line_connections || (_maxPlexType==0))\{ // Don't process more wires than allowed in nearest mode.\n          wire_render(pos);\n        \}\n      \} //WireRender over\n\n      if (_facetRender) \{\n        facet_render(pos,float3(_sample.x,_sample.y,_sample.z));\n      \}  //FacetRender over\n      \n    \}\n  \} //----> process\n\};\n"
  useGPUIfAvailable false
  rebuild ""
  PointRender3D_cam_Matrix {
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
    }
  PointRender3D_focallength {{parent.Camera1.focal}}
  PointRender3D_hapeture {{parent.Camera1.haperture}}
  PointRender3D_format {{!proxy?Settings_Format.width:Settings_Format.width*proxy_scale} {!proxy?Settings_Format.height:Settings_Format.height*proxy_scale}}
  PointRender3D_vertexformat {{parent.InputFormat.box.r-1} {parent.InputFormat.box.t-1}}
  PointRender3D__alphaMultiplier {{parent.AlphaMultiplier}}
  PointRender3D__pointRender {{parent.RenderMode==0}}
  PointRender3D__wireRender {{parent.RenderMode==1}}
  PointRender3D__facetRender {{parent.RenderMode==2}}
  PointRender3D__maxLDistance {{parent.wire_maxdistance}}
  PointRender3D__maxLConnections {{parent.wire_connections}}
  PointRender3D__maxPlexType {{-parent.wire_type}}
  PointRender3D__plexLinedefXY {{!parent.connect_xy}}
  PointRender3D__plexLinedefX {{!parent.connect_x}}
  PointRender3D__plexLinedefY {{!parent.connect_y}}
  PointRender3D__plexLinedefAUX {{!connect_aux}}
  PointRender3D__plexConnectX {{parent.CloseX}}
  PointRender3D__plexConnectY {{parent.CloseY}}
  PointRender3D__L_gamma {{parent.wire_Threshold}}
  "PointRender3D_Enable Depth of Field" {{parent.dof_enable}}
  PointRender3D_samples {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_rings {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_focalDepth {{parent.dof_focaldepth}}
  PointRender3D__depthOfField {{parent.dof_dof}}
  PointRender3D__depthMult 0
  PointRender3D__maxDofSize {{parent.dof_maxSize*400}}
  PointRender3D_dof_aspect {{parent.dof_Aspect}}
  PointRender3D_dof_bias {{parent.dof_bias}}
  PointRender3D__flatshading {{parent.facet_flatShading}}
  PointRender3D__backfacing {{parent.facet_backface}}
  PointRender3D__frontfacing {{parent.facet_front}}
  PointRender3D__vertexMode {{parent.renderMode}}
  PointRender3D__depthBuffer {{parent.facet_depth}}
  PointRender3D__texoffset {-0.5 0.5}
  PointRender3D__pointSize 0
  PointRender3D__depthOcclusion {{parent.UseOcclusionMap}}
  PointRender3D__maxLineSteps {{parent.maxSamples}}
  PointRender3D__lineOffset {{parent.lineoffset}}
  PointRender3D__lineInMultiplier {{parent.inGain}}
  PointRender3D__lineOutMultiplier {{parent.outGain}}
  PointRender3D__overscan {{parent.overscan} {parent.overscan}}
  format "1280 720 0 0 1280 720 1 HD_720"
  rebuild_finalise ""
  name BlinkScript1
  xpos -27
  ypos 159
 }
set N1dad43f0 [stack 0]
 TimeBlur {
  divisions {{parent.Samples}}
  shutter {{parent.Shutter}}
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur
  xpos -27
  ypos 301
  disable {{1-parent.mb_enable x89 0}}
 }
 ShuffleCopy {
  inputs 2
  alpha alpha2
  black alpha
  out2 depth
  name ShuffleCopy2
  xpos -27
  ypos 411
  disable {{!parent.OutputZdepth}}
 }
 CopyBBox {
  inputs 2
  name CopyBBox1
  xpos -27
  ypos 521
 }
 Reformat {
  format {{{Settings_Format.format}}}
  resize none
  center false
  pbb {{max(parent.overscan.w,parent.overscan.h)!=0}}
  name Reformat1
  xpos -27
  ypos 545
 }
 Group {
  name SoftLook
  xpos -27
  ypos 647
  disable {{!parent.HighlightCompression}}
  addUserKnob {20 User}
  addUserKnob {26 ""}
  addUserKnob {7 Add R 0 4}
  Add {{parent.HighlightCeiling}}
  addUserKnob {7 Offset R 0 4}
  Offset {{parent.Compression}}
 }
  Input {
   inputs 0
   name Input1
   xpos -248
   ypos 500
  }
set N1db702b0 [stack 0]
  Expression {
   expr0 r/(r+parent.Offset)*parent.Add
   expr1 g/(g+parent.Offset)*parent.Add
   expr2 b/(b+parent.Offset)*parent.Add
   expr3 a/(a+parent.Offset)*parent.Add
   name Expression1
   xpos -339
   ypos 576
  }
push $N1db702b0
  ShuffleCopy {
   inputs 2
   red red
   green green
   blue blue
   alpha alpha2
   name ShuffleCopy1
   xpos -248
   ypos 576
  }
  Output {
   name Output1
   xpos -248
   ypos 651
  }
 end_group
 ShuffleCopy {
  inputs 2
  in pos
  red red
  green green
  blue blue
  out pos
  name ShuffleCopy1
  xpos -27
  ypos 860
  disable true
 }
 Output {
  name Output1
  xpos -27
  ypos 897
 }
push $N1da1bef0
 PositionToPoints2 {
  display textured
  render_mode textured
  P_channel pos
  detail 0.25
  pointSize 0.6
  name PreviewNode
  xpos -22
  ypos 8
  disable {{!parent.Enable3DPreview}}
 }
push $N1d84bae0
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize none
  filter Impulse
  black_outside true
  name Reformat3
  xpos -633
  ypos -1109
  disable {{!wire_type==1}}
 }
push $N1d890110
push $N1d8aff80
push $N1d8b4ae0
 Merge2 {
  inputs 2
  operation min
  Achannels {-pos.red -pos.green -pos.blue pos.alpha}
  Bchannels {-pos.red -pos.green -pos.blue pos.alpha}
  output {-pos.red -pos.green -pos.blue pos.alpha}
  name Merge4
  xpos -582
  ypos -634
 }
 Merge2 {
  inputs 2
  operation min
  Achannels {-pos.red -pos.green -pos.blue pos.alpha}
  Bchannels {-pos.red -pos.green -pos.blue pos.alpha}
  output {-pos.red -pos.green -pos.blue pos.alpha}
  name Merge5
  xpos -582
  ypos -602
 }
push $N1d8c7e90
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -456
  ypos -402
 }
push $N1dad43f0
 Viewer {
  frame 36
  frame_range 1-100
  name Viewer1
  xpos -27
  ypos 325
 }
 Input {
  inputs 0
  name InputCamera
  xpos -1271
  ypos 89
  number 1
 }
 Camera {
  useMatrix true
  matrix {
      {1 0 0 0}
      {0 {1/Settings_Format.actual_format.pixel_aspect} 0 0}
      {0 0 1 0}
      {0 0 0 1}
    }
  projection_mode {{"\[value the_cam]projection_mode"}}
  focal {{"\[value \[value the_cam]focal]"}}
  haperture {{"\[value \[value the_cam]haperture]"}}
  vaperture {{"\[value \[value the_cam]vaperture]"}}
  near {{"\[value \[value the_cam]near]"}}
  far {{"\[value \[value the_cam]far]"}}
  win_translate {{"\[lindex \[value \[value the_cam]win_translate] 0]"} {"\[lindex \[value \[value the_cam]win_translate] 1]"}}
  win_scale {{"\[lindex \[value \[value the_cam]win_scale] 0]"} {"\[lindex \[value \[value the_cam]win_scale] 1]"}}
  winroll {{"\[value \[value the_cam]winroll]"}}
  focal_point {{"\[value \[value the_cam]focal_point]"}}
  fstop {{"\[value \[value the_cam]fstop]"}}
  name Camera1
  help "DummyCam by Adrian Pueyo\n\nCamera that apart from the matrices also grabs all the \"Projection\" values from the upstream camera that it's connected to. Turns into a default Camera if not Camera connected.\n\nCan also be used inside of groups and gizmos, as many levels deep as you want :D\n\nAll using live and super fast TCL.\n\nadrianpueyo.com, 2019"
  onCreate "n = nuke.thisNode()\nfor k in \[\"projection_mode\",\"focal\",\"haperture\",\"vaperture\",\"near\",\"far\",\"win_translate\",\"win_scale\",\"winroll\",\"focal_point\",\"fstop\"]:\n    n\[k].setFlag(0x0000000010000000)"
  label "(thanks to Adrian Pueyo and Ernest Dios)"
  xpos -1261
  ypos 198
  addUserKnob {20 DummyCam l Defaults}
  addUserKnob {43 the_cam +INVISIBLE}
  the_cam "\[\nset the_knob \"focal\"\nset knob_index 0\nset starting_point \"this.input0\"\nset default \"this\"\nset default \[append default \".d_\"]\n\n# If cam has no inputs, return the default...\nif \{\[exists \$starting_point]\} \{\n    set x \[node \$starting_point]\n\} \{ \n    return \$default\n\}\n\nset finished 0\nwhile \{\$finished != 1\} \{\n\n    # First look for a Cam or Input or topnode.\n    while \{\[class \$x] != \"Camera2\" && \[class \$x] != \"Camera\" && \[class \$x] != \"Input\" && \$x != \[topnode \$x]\} \{\n        set x \[node \$x.input0]\n    \}\n\n    # Then, check if node is a cam (and return), and otherwise, if it's an input, see if the parent exists and move to it.\n    if \{\[class \$x]==\"Camera2\"||\[class \$x]==\"Camera\"\} \{\n        set x \[append x \".\"]\n        return \$x\n    \} \{ \n        if \{\[class \$x]==\"Input\"\} \{ \n            set inp \"\$x.parent.input\"\n            set inputNum \[value \$x.number]\n            set inp \[append inp \$inputNum]\n            if \{\[exists \$inp]\} \{\n                set x \[node \$inp]\n            \} \{ \n                set finished 1\n            \}\n        \} \{ \n            set finished 1\n        \}\n    \}\n\}\nreturn \$default\n]"
  addUserKnob {4 d_projection_mode l projection M {perspective orthographic uv spherical ""}}
  addUserKnob {7 d_focal l focal R 0 100}
  d_focal 50
  addUserKnob {7 d_haperture l "horiz aperture" R 0 50}
  d_haperture 24.576
  addUserKnob {7 d_vaperture l "vert aperture" R 0 50}
  d_vaperture 18.672
  addUserKnob {7 d_near l near R 0 10}
  d_near 0.1
  addUserKnob {7 d_far l far R 0 10000}
  d_far 10000
  addUserKnob {12 d_win_translate l "window translate"}
  addUserKnob {12 d_win_scale l "window scale"}
  d_win_scale {1 1}
  addUserKnob {7 d_winroll l "window roll" R 0 45}
  addUserKnob {7 d_focal_point l "focal distance" R 0 10}
  d_focal_point 2
  addUserKnob {7 d_fstop l fstop R 0 30}
  d_fstop 16
  addUserKnob {26 text l " " T "<span style=\"color:#666\"><br/><b>DummyCam v1.0</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2019</span>"}
 }
end_group
FrameRange {
 first_frame 1000
 last_frame 2000
 time ""
 name FrameRange10
 xpos 1421
 ypos 2288
}
Camera2 {
 inputs 0
 translate {0.211 10 5.69999981}
 rotate {-60 0 0}
 focal 62
 name Camera5
 xpos 2327
 ypos 2031
 addUserKnob {20 DNeg}
 addUserKnob {26 _version l "" +STARTLINE +INVISIBLE T 1.0}
 addUserKnob {41 "horiz aperture" T haperture}
 addUserKnob {41 "vert aperture" T vaperture}
 addUserKnob {4 setApertureValues l "" t "Set aperture values based on registered camera sensor data. The 'read from file' knob needs to be disabled and any potential curves deleted." +STARTLINE M {"Set Aperture Values" ANNI/Delivery "Alexa 65/Full" "Alexa 65/Half Res" "Alexa MINI/4:3 Full Ana" "Alexa MINI/16:9 Full" "Alexa MINI/OpenGate" "Alexa MINI/16:9 1.78 Ana" "Alexa Mini/OpenGate" "Alexa XT/OpenGate" "Alexa XT/4:3 Full Ana" "Alexa XT/16:9 1.78" "Alexa XT/16:9 1.78 Ana" "Alexa XT/4:3 Full" "Alexa XT/Open Gate" "Alexa XT/Open Gate TC" "Alexa XT/SuperOpenGate" "Alexa XT/SuperOpenGate Cropped" "Arri 65/6k 1.3 ana" "Arri 65/6k 2.11" BF/Delivery "BOND /Anamorphic" "Blackmagic Prod 4K/4K" "Canon 5D mkIII/HD" "Canon C300/16:9" "Delivery Extractions/Arri 65 1.3 ana Working" "Delivery Extractions/Arri 65 Working" "Extractions/CFW Delivery" "Film 35mm/Cinemascope Centred" "Film 35mm/Full Aperture" "Generic/1080p HD" Generic/Anamorphic Generic/Spherical "GoPro/Generic 16:9" HERC/Alexa IMAX/8K "Internal Movie Extractions/TRAINVFX Working" "Internal Movie Extractions/Alexa XT OpenGate" "Internal Movie Extractions/Previs" "Internal Movie Extractions/Arri 65 1.3 ana Working" "Internal Movie Extractions/MLOU Delivery" "Internal Movie Extractions/MAGIC Working" "Movie Extractions/Alexa XT OpenGate" "Movie Extractions/Alexa XT 4:3 Full Ana" "Movie Extractions/Alexa MINI 4:3 Full Ana" "Movie Extractions/Alexa MINI 16:9 1.78" "Movie Extractions/Alexa XT 16:9 1.78" "Movie Extractions/Alexa MINI OpenGate" "Movie Extractions/Alexa XT 16:9 1.78 Ana" "Movie Extractions/Alexa MINI 16:9 1.78 Ana" "Movie Extractions/Phantom Flex 4k" "Movie Extractions/MAE Working 2" "Movie Extractions/TS Anamorphic 4K" "Movie Extractions/EXO Working" "Movie Extractions/Previs" "Movie Extractions/MAGIC Working" "Movie Extractions/DOTN Working" "Phantom Flex/4k" Previs/Anamorphic Previs/Spherical "Red Epic/5K" "Red Epic Dragon/6K HD" "Red Epic Dragon/5K Full" "Red Epic Dragon/5K FullFrame Scaled" "TM/Alexa MINI 4:3 Full Ana" "Working Extractions/Arri 65 6k 1.3 ana" "Working Extractions/Alexa XT 4:3 Full Ana" "Working Extractions/Alexa XT OpenGate" "Working Extractions/Alexa XT 16:9 1.78" "Working Extractions/Alexa MINI 4:3 Full Ana" "Working Extractions/Alexa MINI OpenGate" "Working Extractions/Alexa MINI 16:9 1.78" "Working Extractions/Phantom Flex 4k" "Working Extractions/Alexa XT 16:9 1.78 Ana" "Working Extractions/Alexa MINI 16:9 1.78 Ana" "Working Extractions/EXO Working" "Working Extractions/EXO Working 2" "Working Extractions/Arri 65 6k" "Working Extractions/Alexa LF 4.5k OpenGate" "Working Extractions/DOTN Working" "internal Movie Extractions/Red Epic Dragon 5k FullFrame Scaled" "internal Movie Extractions/Red Epic Dragon 5K FullFrame" "internal Movie Extractions/IMAX 6K" "internal Movie Extractions/IMAX 8K" "Alexa LF/4.5k OpenGate" "Digital SLR/Full Frame" "Digital SLR/Full Frame Portrait" "Digital SLR/APS-C" "Digital SLR/APS-C Portrait" Generic/HD LatLong/360 LatLong/180}}
 addUserKnob {26 ""}
 addUserKnob {22 makeProjector l "Make Projector..." T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeProjectorNode']).makeProjectorNode()" +STARTLINE}
 addUserKnob {22 makeLinkedProjector l "Make Linked Projector..." -STARTLINE T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeProjectorNode']).makeLinkedProjectorNode()"}
 addUserKnob {26 ""}
 addUserKnob {7 hshake l "hero horiz shake" R -1 1}
 addUserKnob {7 vshake l "hero vert shake" R -1 1}
 addUserKnob {7 shakeroll l "hero shake roll" R -180 180}
 addUserKnob {7 ahshake l "ambient horiz shake" R -1 1}
 addUserKnob {7 avshake l "ambient vert shake" R -1 1}
 addUserKnob {7 ashakeroll l "ambient shake roll" R -180 180}
 addUserKnob {26 ""}
 addUserKnob {22 makeShakeCamera l "Make Shake Camera" T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeAmbientHeroShakeCamera']).makeAmbientHeroShakeCamera()" +STARTLINE}
 addUserKnob {22 makeShakeTransform l "Make Shake Transform" -STARTLINE T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeAmbientHeroShakeTransform']).makeAmbientHeroShakeTransform()"}
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 addUserKnob {1 leaf_label l Leaf}
 addUserKnob {1 ivy_version l Version}
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
set N1dc39c60 [stack 0]
ColorWheel {
 inputs 0
 format "256 256 0 0 256 256 1 square_256"
 gamma 0.45
 name ColorWheel1
 xpos 2429
 ypos 1510
}
Reformat {
 type scale
 scale 2
 pbb true
 name Reformat1
 xpos 2429
 ypos 1605
}
add_layer {__Pworld __Pworld.x __Pworld.y __Pworld.z}
Shuffle {
 out __Pworld
 name Shuffle3
 xpos 2429
 ypos 1646
}
Colorspace {
 channels __Pworld
 colorspace_in AlexaV3LogC
 colorspace_out CIE-LCH
 name Colorspace1
 xpos 2435
 ypos 1722
}
HueShift {
 channels __Pworld
 hue_rotation {{-frame/10}}
 name HueShift2
 xpos 2435
 ypos 1758
}
Colorspace {
 channels __Pworld
 colorspace_in HSL
 colorspace_out YPbPr
 name Colorspace2
 xpos 2429
 ypos 1807
}
set N1dcaf550 [stack 0]
push $N1dcaf550
Merge2 {
 inputs 2
 operation exclusion
 name Merge3
 xpos 2574
 ypos 1874
}
Clamp {
 channels __Pworld
 minimum -6
 maximum 4
 name Clamp1
 xpos 2574
 ypos 1910
}
set N1e1b42b0 [stack 0]
PositionToPoints2 {
 display textured
 render_mode textured
 P_channel __Pworld
 detail 1
 pointSize 2
 name PositionToPoints2
 xpos 2429
 ypos 1974
}
push 0
ScanlineRender {
 inputs 3
 conservative_shader_sampling false
 overscan 150
 shutteroffset centred
 motion_vectors_type distance
 name ScanlineRender2
 xpos 2429
 ypos 2052
}
FrameRange {
 first_frame 1000
 last_frame 2000
 time ""
 name FrameRange12
 xpos 2426
 ypos 2087
}
Camera2 {
 inputs 0
 translate {8.985695839 10.81952858 5.41764164}
 rotate {-53.53445714 46.53024366 -12.29288482}
 focal 22
 name Camera10
 xpos 2693
 ypos 2025
 addUserKnob {20 DNeg}
 addUserKnob {26 _version l "" +STARTLINE +INVISIBLE T 1.0}
 addUserKnob {41 "horiz aperture" T haperture}
 addUserKnob {41 "vert aperture" T vaperture}
 addUserKnob {4 setApertureValues l "" t "Set aperture values based on registered camera sensor data. The 'read from file' knob needs to be disabled and any potential curves deleted." +STARTLINE M {"Set Aperture Values" ANNI/Delivery "Alexa 65/Full" "Alexa 65/Half Res" "Alexa MINI/4:3 Full Ana" "Alexa MINI/16:9 Full" "Alexa MINI/OpenGate" "Alexa MINI/16:9 1.78 Ana" "Alexa Mini/OpenGate" "Alexa XT/OpenGate" "Alexa XT/4:3 Full Ana" "Alexa XT/16:9 1.78" "Alexa XT/16:9 1.78 Ana" "Alexa XT/4:3 Full" "Alexa XT/Open Gate" "Alexa XT/Open Gate TC" "Alexa XT/SuperOpenGate" "Alexa XT/SuperOpenGate Cropped" "Arri 65/6k 1.3 ana" "Arri 65/6k 2.11" BF/Delivery "BOND /Anamorphic" "Blackmagic Prod 4K/4K" "Canon 5D mkIII/HD" "Canon C300/16:9" "Delivery Extractions/Arri 65 1.3 ana Working" "Delivery Extractions/Arri 65 Working" "Extractions/CFW Delivery" "Film 35mm/Cinemascope Centred" "Film 35mm/Full Aperture" "Generic/1080p HD" Generic/Anamorphic Generic/Spherical "GoPro/Generic 16:9" HERC/Alexa IMAX/8K "Internal Movie Extractions/TRAINVFX Working" "Internal Movie Extractions/Alexa XT OpenGate" "Internal Movie Extractions/Previs" "Internal Movie Extractions/Arri 65 1.3 ana Working" "Internal Movie Extractions/MLOU Delivery" "Internal Movie Extractions/MAGIC Working" "Movie Extractions/Alexa XT OpenGate" "Movie Extractions/Alexa XT 4:3 Full Ana" "Movie Extractions/Alexa MINI 4:3 Full Ana" "Movie Extractions/Alexa MINI 16:9 1.78" "Movie Extractions/Alexa XT 16:9 1.78" "Movie Extractions/Alexa MINI OpenGate" "Movie Extractions/Alexa XT 16:9 1.78 Ana" "Movie Extractions/Alexa MINI 16:9 1.78 Ana" "Movie Extractions/Phantom Flex 4k" "Movie Extractions/MAE Working 2" "Movie Extractions/TS Anamorphic 4K" "Movie Extractions/EXO Working" "Movie Extractions/Previs" "Movie Extractions/MAGIC Working" "Movie Extractions/DOTN Working" "Phantom Flex/4k" Previs/Anamorphic Previs/Spherical "Red Epic/5K" "Red Epic Dragon/6K HD" "Red Epic Dragon/5K Full" "Red Epic Dragon/5K FullFrame Scaled" "TM/Alexa MINI 4:3 Full Ana" "Working Extractions/Arri 65 6k 1.3 ana" "Working Extractions/Alexa XT 4:3 Full Ana" "Working Extractions/Alexa XT OpenGate" "Working Extractions/Alexa XT 16:9 1.78" "Working Extractions/Alexa MINI 4:3 Full Ana" "Working Extractions/Alexa MINI OpenGate" "Working Extractions/Alexa MINI 16:9 1.78" "Working Extractions/Phantom Flex 4k" "Working Extractions/Alexa XT 16:9 1.78 Ana" "Working Extractions/Alexa MINI 16:9 1.78 Ana" "Working Extractions/EXO Working" "Working Extractions/EXO Working 2" "Working Extractions/Arri 65 6k" "Working Extractions/Alexa LF 4.5k OpenGate" "Working Extractions/DOTN Working" "internal Movie Extractions/Red Epic Dragon 5k FullFrame Scaled" "internal Movie Extractions/Red Epic Dragon 5K FullFrame" "internal Movie Extractions/IMAX 6K" "internal Movie Extractions/IMAX 8K" "Alexa LF/4.5k OpenGate" "Digital SLR/Full Frame" "Digital SLR/Full Frame Portrait" "Digital SLR/APS-C" "Digital SLR/APS-C Portrait" Generic/HD LatLong/360 LatLong/180}}
 addUserKnob {26 ""}
 addUserKnob {22 makeProjector l "Make Projector..." T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeProjectorNode']).makeProjectorNode()" +STARTLINE}
 addUserKnob {22 makeLinkedProjector l "Make Linked Projector..." -STARTLINE T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeProjectorNode']).makeLinkedProjectorNode()"}
 addUserKnob {26 ""}
 addUserKnob {7 hshake l "hero horiz shake" R -1 1}
 addUserKnob {7 vshake l "hero vert shake" R -1 1}
 addUserKnob {7 shakeroll l "hero shake roll" R -180 180}
 addUserKnob {7 ahshake l "ambient horiz shake" R -1 1}
 addUserKnob {7 avshake l "ambient vert shake" R -1 1}
 addUserKnob {7 ashakeroll l "ambient shake roll" R -180 180}
 addUserKnob {26 ""}
 addUserKnob {22 makeShakeCamera l "Make Shake Camera" T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeAmbientHeroShakeCamera']).makeAmbientHeroShakeCamera()" +STARTLINE}
 addUserKnob {22 makeShakeTransform l "Make Shake Transform" -STARTLINE T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeAmbientHeroShakeTransform']).makeAmbientHeroShakeTransform()"}
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 addUserKnob {1 leaf_label l Leaf}
 addUserKnob {1 ivy_version l Version}
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
push $N1e1b42b0
Shuffle {
 in __Pworld
 out pos
 name Shuffle18
 xpos 2574
 ypos 1960
}
Group {
 inputs 2
 name Point_Render8
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 xpos 2574
 ypos 2046
 addUserKnob {20 User l "Point Render" t dd}
 addUserKnob {26 info_header l "" +STARTLINE T "Point Render v1.2"}
 addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {4 RenderMode l "Render Mode" t "Some generators support multiple render modes other than just point rendering. This should be considered a experimental feature, but can be used to great effect.\n\nIn the Render Settings tab you can find more controls relating to Wire and Facet rendering modes.\n\nNote that Facet Render can be slow when really close to a object. " M {"Point Render" "Wire Render" "Facet Render (experimental)" "" "" ""}}
 RenderMode "Wire Render"
 addUserKnob {7 FocalLength l "Focal Length" t "The point render does not take the focal length from the input camera, so if you want to match it to a camera you should link the focal length from the camera to this." +INVISIBLE R 0 200}
 FocalLength 40
 addUserKnob {7 horizontalApeture l "Horiz Apeture" +INVISIBLE R 0 100}
 horizontalApeture 24.576
 addUserKnob {14 overscan l Overscan R 0 100}
 addUserKnob {7 AlphaMultiplier l Exposure t "This is a general exposure modifier that lets you adjust the overall brightness of the render." R 0 2}
 AlphaMultiplier 1
 addUserKnob {6 OutputZdepth l "Output Z-depth" t "Will output a Z-depth channel. This will cause reduced rendering performence." +STARTLINE}
 addUserKnob {6 UseOcclusionMap l "Use Occlusion Map" t "Enable the Occlusion map input. This lets you use a depth map as a holdout.\n\nNote:\nThe Red channal should contain the depth (absolute distance, not 1/depth)\nThe Alpha channal must be 1 for the areas that you want to holdout." +STARTLINE}
 addUserKnob {4 occ_method l "" t "Real Depth - input RGB should be the distance to the camera, and A should be the alpha (White occlude, Black ingore).\n\n1/depth.z (Scanline Render) - Will use the depth.Z channal from the scanline render and convert to real depth internally. Alpha is still required." -STARTLINE M {"Real Depth" "1/depth.z (Scanline Render)" ""}}
 occ_method "1/depth.z (Scanline Render)"
 addUserKnob {26 devider_cc l "<b><font color=#7DADF9>Preview</font><b>"}
 addUserKnob {6 FastPreview l "Fast Preview" t "Reduce the number of points for a quick preview of the final render." +STARTLINE}
 addUserKnob {6 HighlightCompression l "Hilight Compression" t "Compresses the highlights to make it easier to see bright details." +STARTLINE}
 addUserKnob {7 HighlightCeiling l "Highlight Ceiling" t "Adjust the cealing for the highlight compression." R 1 10}
 HighlightCeiling 1.15
 addUserKnob {7 Compression t "The compression amount." -STARTLINE R 0 5}
 Compression 1
 addUserKnob {26 devider_format l "<b><font color=#7DADF9>Format</font><b>"}
 addUserKnob {41 format l "output format" T Settings_Format.format}
 addUserKnob {20 WireRender l "Render Settings"}
 addUserKnob {26 devider_wirerender l "<b><font color=#7DADF9>Wire Rendering</font><b>"}
 addUserKnob {4 wire_type l "Connection Mode" t "*Normal\nConnect lines between the local neigbours of the 2d position map\n\n*Nearest\nConnect lines to the nearest points (in 3D space). This mode is limited to 100x100 points for performence reasons!" M {Normal Nearest "" "" "" "" "" "" "" ""}}
 addUserKnob {26 text l "Normal Mode Wires" T " "}
 addUserKnob {6 connect_x l x t "Connect wires in the (uv) X axis." -STARTLINE}
 connect_x true
 addUserKnob {6 connect_xy l xy t "Connect wires in the (uv) XY axis." -STARTLINE}
 connect_xy true
 addUserKnob {6 connect_y l y t "Connect wires in the (uv) Y axis." -STARTLINE}
 connect_y true
 addUserKnob {6 connect_aux l aux t "If you input a vector map into the Aux input for this node, and enable this option, you will get a wire from each point along that vector." -STARTLINE}
 addUserKnob {7 wire_maxdistance l "Max Distance" t "The maximum distance that the wires connect." R 0 10}
 wire_maxdistance 6
 addUserKnob {7 wire_Threshold l "Distance Threshold" t "Control the max distance threshold" R 0 2}
 wire_Threshold 0.5
 addUserKnob {3 wire_connections l "Max Connections" t "The maximum number of connections (Not Yet Implemented)"}
 wire_connections 4
 addUserKnob {7 maxSamples l "Max Line Samples" t "The maximum length of a line. Once a line is longer than this, it will start break up. \nThis can also be used as a creative effect if you set it low, try setting it to 10 in wire mode to get dotted lines" R 0 10000}
 maxSamples 10000
 addUserKnob {7 lineoffset l "Line Offset" t "Expand or contract the lines."}
 lineoffset 1
 addUserKnob {7 inGain l "In Gain" t "Gain the brightness of the in-point of the lines"}
 inGain 1
 addUserKnob {7 outGain l "Out Gain" t "Gain the brightness of the out-point of the lines" -STARTLINE}
 outGain 1
 addUserKnob {26 devider_facet l "<b><font color=#7DADF9>Facet Rendering</font><b>"}
 addUserKnob {4 renderMode l "Render Mode" t "Pick the desidered render mode." M {Diffuse "Local ST" Normal "Facing Ratio" UV ST "View Normal" "World Position" "" ""}}
 addUserKnob {6 facet_flatShading l "Flat Shading" t "Flat shading" +STARTLINE}
 addUserKnob {6 facet_depth l "Depth Buffer" t "Enable depth sorting to avoid additive surfaces." -STARTLINE}
 addUserKnob {6 facet_front l "Front Face" t "Render front facing facets" +STARTLINE}
 facet_front true
 addUserKnob {6 facet_backface l "Back Face" t "Render backfacing faces" -STARTLINE}
 facet_backface true
 addUserKnob {26 _1 l "<b><font color=#7DADF9>Other</font><b>"}
 addUserKnob {6 CloseX l "Close X" t "On spheres or round objects this closes the loop" +STARTLINE}
 addUserKnob {6 CloseY l "Close Y" t "On spheres or round objects this closes the loop" -STARTLINE}
 addUserKnob {20 Fog_1 l Fog}
 addUserKnob {26 Devider_Fog l "<b><font color=#7DADF9>Fog</font><b>"}
 addUserKnob {6 Fog t "Fog reduces the brightness of poins far from the camera." +STARTLINE}
 addUserKnob {7 FogNear l "Fog Near" R 0 200}
 FogNear 1
 addUserKnob {7 FogFar l "Fog Far" R 0 200}
 FogFar 150
 addUserKnob {7 FogExponent l "Fog Exponent" R 0 8}
 FogExponent 8
 addUserKnob {20 DepthOfField l "Depth of Field"}
 addUserKnob {26 devider_dof l "<b><font color=#7DADF9>Depth Of Field</font><b>"}
 addUserKnob {6 dof_enable l Enable +STARTLINE}
 addUserKnob {7 dof_focaldepth l "Focal Depth" R 0 40}
 dof_focaldepth 24.1
 addUserKnob {7 dof_dof l "Depth of Field" R 0 10}
 dof_dof 1
 addUserKnob {7 dof_maxSize l "Max Size"}
 dof_maxSize 0.6
 addUserKnob {7 dof_Aspect l "Aspect Ratio"}
 dof_Aspect 1
 addUserKnob {7 dof_bias l Bias R -3 3}
 dof_bias -0.2
 addUserKnob {4 Dof_Quality l Quality M {Low Medium High Extreme}}
 addUserKnob {20 MotionBlur}
 addUserKnob {26 devider_MotionBlur l "<b><font color=#7DADF9>Motion Blur</font><b>"}
 addUserKnob {6 mb_enable l Enable +STARTLINE}
 addUserKnob {6 Fast l "Fast (Interpolated)" -STARTLINE}
 Fast true
 addUserKnob {3 Samples}
 Samples 8
 addUserKnob {7 Shutter R 0 2}
 Shutter 1
 addUserKnob {4 pulldown l "Shutter Offset" M {Centered Start End ""}}
 addUserKnob {20 preview_3d l "3D Preview"}
 addUserKnob {6 Enable3DPreview l "Enable 3D Preview" t "Display a preview of the points in the Nuke 3D view." +STARTLINE}
 Enable3DPreview true
 addUserKnob {41 pointSize l "point size" T PreviewNode.pointSize}
 addUserKnob {41 detail l "point detail" T PreviewNode.detail}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x388e8e00
  label "Output Format Manager"
  note_font_size 22
  xpos -1079
  ypos 117
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode10
  tile_color 0x388e8e00
  label "AUX Input"
  note_font_size 22
  xpos -385
  ypos 178
  bdwidth 207
  bdheight 178
 }
 BackdropNode {
  inputs 0
  name BackdropNode11
  tile_color 0x388e8e00
  label "Point Render"
  note_font_size 22
  xpos -96
  ypos 99
  bdwidth 203
  bdheight 131
 }
 BackdropNode {
  inputs 0
  name BackdropNode12
  tile_color 0x388e8e00
  label "Normal Generator\nFor Vertex Normals"
  note_font_size 22
  xpos -616
  ypos 243
  bdwidth 191
  bdheight 122
 }
 BackdropNode {
  inputs 0
  name BackdropNode13
  tile_color 0x388e8e00
  label "Ensure output format"
  note_font_size 22
  xpos -622
  ypos -41
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode14
  tile_color 0x388e8e00
  label "Motion Blur"
  note_font_size 22
  xpos -85
  ypos 255
  bdwidth 264
  bdheight 96
 }
 BackdropNode {
  inputs 0
  name BackdropNode15
  tile_color 0x388e8e00
  label "Soft Preview"
  note_font_size 22
  xpos -83
  ypos 601
  bdwidth 191
  bdheight 94
 }
 BackdropNode {
  inputs 0
  name BackdropNode16
  tile_color 0x388e8e00
  label "Final format"
  note_font_size 22
  xpos -84
  ypos 482
  bdwidth 192
  bdheight 95
 }
 BackdropNode {
  inputs 0
  name BackdropNode17
  tile_color 0x388e8e00
  label "No Clue =)"
  note_font_size 22
  xpos -385
  ypos -41
  bdwidth 160
  bdheight 87
 }
 BackdropNode {
  inputs 0
  name BackdropNode18
  tile_color 0x388e8e00
  label "Z-Depth Shuffle"
  note_font_size 22
  xpos -85
  ypos 367
  bdwidth 264
  bdheight 96
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0x388e8e00
  label Motionblur
  note_font_size 22
  xpos -672
  ypos -781
  bdwidth 258
  bdheight 246
 }
 BackdropNode {
  inputs 0
  name BackdropNode3
  tile_color 0x388e8e00
  label "Fast Preview"
  note_font_size 22
  xpos -669
  ypos -971
  bdwidth 254
  bdheight 138
 }
 BackdropNode {
  inputs 0
  name BackdropNode4
  tile_color 0x388e8e00
  label "Nearest Wire Mode Clamp"
  note_font_size 22
  xpos -666
  ypos -1184
  bdwidth 253
  bdheight 111
 }
 BackdropNode {
  inputs 0
  name BackdropNode5
  tile_color 0x388e8e00
  label Occlusion
  note_font_size 22
  xpos 208
  ypos 27
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode6
  tile_color 0x388e8e00
  label "Input Camera Container"
  note_font_size 22
  xpos -1357
  ypos 121
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode7
  tile_color 0x388e8e00
  label "3D Preview"
  note_font_size 22
  xpos -88
  ypos -45
  bdwidth 207
  bdheight 102
 }
 BackdropNode {
  inputs 0
  name BackdropNode8
  tile_color 0x388e8e00
  label "Input Format Manager"
  note_font_size 22
  xpos -526
  ypos -459
  bdwidth 208
  bdheight 97
 }
 BackdropNode {
  inputs 0
  name BackdropNode9
  tile_color 0x388e8e00
  label FOG
  note_font_size 22
  xpos -602
  ypos -253
  bdwidth 370
  bdheight 152
 }
 Input {
  inputs 0
  name InputPointData
  xpos -584
  ypos -1321
 }
 Dot {
  name Dot4
  xpos -550
  ypos -1234
 }
set N1e2a9ea0 [stack 0]
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize fill
  filter Impulse
  black_outside true
  name Reformat5
  xpos -584
  ypos -906
  disable {{!parent.FastPreview==1}}
 }
 Grade {
  white 10
  name Grade2
  xpos -584
  ypos -874
  disable {{!parent.FastPreview}}
 }
 Dot {
  name Dot2
  xpos -550
  ypos -712
 }
set N1e2ce4f0 [stack 0]
 Group {
  name FrameHold3
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -501
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame+1}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot6
  xpos -467
  ypos -659
 }
set N1e2ee4e0 [stack 0]
push $N1e2ce4f0
 Group {
  name FrameHold2
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -660
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot5
  xpos -626
  ypos -659
 }
set N1e30e360 [stack 0]
 Dissolve {
  inputs 2
  which {{frame-floor(frame)}}
  name Dissolve1
  xpos -582
  ypos -666
  disable {{1-parent.mb_enable}}
 }
set N1e312ec0 [stack 0]
push $N1e2ce4f0
 Switch {
  inputs 2
  which {{parent.Fast}}
  name Switch2
  xpos -584
  ypos -567
 }
 Dot {
  name DataFetch
  label "data fetch\t"
  note_font_color 0xff21ff
  xpos -550
  ypos -513
  addUserKnob {20 User}
  addUserKnob {3 n_particles l "Number of Particles"}
  addUserKnob {3 gentype l "Type Of Generator"}
  addUserKnob {26 info l "" -STARTLINE T "0 = unknown, 1 = Card, 2 = Sphere, 3 = Grid"}
 }
set N1e326270 [stack 0]
 Dot {
  name Dot3
  xpos -635
  ypos -513
 }
 Dot {
  name Dot1
  xpos -635
  ypos 863
 }
 Reformat {
  inputs 0
  format "1920 1080 0 0 1920 1080 1 HD_1080"
  resize distort
  center false
  black_outside true
  name Settings_Format
  xpos -992
  ypos 209
 }
 AdjBBox {
  numpixels {{parent.overscan} {parent.overscan}}
  name AdjBBox2
  xpos -992
  ypos 241
 }
 Input {
  inputs 0
  name InputOcclusion
  xpos 238
  ypos 75
  number 2
 }
 Expression {
  expr0 depth.Z>0?1/depth.Z:0
  name Expression2
  xpos 238
  ypos 104
  disable {{!parent.occ_method}}
 }
 Constant {
  inputs 0
  channels rgb
  color 1
  format {{{parent.Settings_Format.format}}}
  name Empty
  xpos 371
  ypos 139
 }
 Switch {
  inputs 2
  which {{parent.UseOcclusionMap}}
  name Switch1
  xpos 238
  ypos 163
 }
 AdjBBox {
  numpixels {{parent.overscan} {parent.overscan}}
  name AdjBBox1
  xpos 118
  ypos 163
 }
set N1e36fc90 [stack 0]
 Input {
  inputs 0
  name Aux
  xpos -324
  ypos 214
  number 3
 }
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter Impulse
  black_outside true
  name Reformat2
  xpos -324
  ypos 238
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop1
  xpos -324
  ypos 462
 }
push $N1e326270
 Shuffle {
  in pos
  name Shuffle1
  xpos -584
  ypos -192
 }
set N1e396730 [stack 0]
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter Impulse
  black_outside true
  name Reformat4
  xpos -584
  ypos 18
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop2
  xpos -584
  ypos 48
 }
 Dot {
  name Dot8
  xpos -550
  ypos 166
 }
set N1e3c0950 [stack 0]
 Group {
  name Point_Normal2
  tile_color 0x434343ff
  note_font_color 0x55ffffff
  xpos -584
  ypos 498
  disable {{!(renderMode==2&&RenderMode==2)}}
  addUserKnob {20 User}
  addUserKnob {26 info l "" +STARTLINE T "Point Normal v1.0"}
  addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
  addUserKnob {26 info_1 l "" +STARTLINE T "well, not much to do here =)"}
 }
  Input {
   inputs 0
   name Input1
   xpos 389
   ypos 207
  }
  Shuffle {
   in pos
   name Shuffle1
   xpos 389
   ypos 294
  }
  BlinkScript {
   kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/BasicLight.cpp
   recompileCount 69
   ProgramGroup 1
   KernelDescription "2 \"PointRender3D\" iterate pixelWise d5452fe7b684561fcfa5182d0c789025a037cc4fe4474c24e065e3fa53fcd8ce 2 \"ppos\" Read Random \"dst\" Write Point 9 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"Zoom\" Float 1 AACAPw== \"half Lambert\" Bool 1 AQ== \"light Mode\" Int 1 AAAAAA== \"light_position\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"light_color\" Float 3 AACAPwAAgD8AAIA/AAAAAA== 9 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"zoom\" 1 1 \"halfLambert\" 1 1 \"lightMode\" 1 1 \"lightPos\" 3 1 \"lightcolor\" 3 1 10 \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"namount\" Float 1 1 AAAAAA=="
   kernelSource "inline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}\n\ninline float saturate(float _in)\n\{\n    return max(0.0f,min(1.0f,_in));\n\}\n\ninline float3 reflect(float3 incidence,float3 normal)\n\{\n  return incidence - 2.f * dot(incidence, normal) * normal;\n\}\n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n    \n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    if (fabs(pScreen.x) > canvasWidth || fabs(pScreen.y) > canvasHeight) \n         return false; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eWrite> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    bool halfLambert;\n    int lightMode;\n    float3 lightPos;\n    float3 lightcolor;\n\n\n  local: //Local variables\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n    float namount; //dither amount\n\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(halfLambert, \"half Lambert\", true);\n    defineParam(lightMode, \"light Mode\", 0);\n    defineParam(lightPos,      \"light_position\", float3(0,0,0));  \n    defineParam(lightcolor,      \"light_color\", float3(1.0,1.0,1.0)); \n  \}\n\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n    namount = 0.0001; //dither amount\n  \}\n\n\n\nfloat3 Reconsile3D(float3 _PointPos)\{\n    vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n    int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    return tRaster;\n\}\n\n\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nfloat3 facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos;\n    float4 V0_Sample,V1_Sample,V2_Sample;\n    float3 normal0,normal1,normal2;\n\n    //for area calculation\n    float area;\n    float3 V0,V1,V2;\n    float3 output = float3(0.0f);\n  if (insideX) \{\n    V2_Sample = ppos(pos.x+1,pos.y);\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(pos.x+1,pos.y-1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n            float3 Normal = CalculateVertexNormals(_vWorld,V2_wPos,V1_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          //write output\n          output +=  float3(Normal.x,Normal.y,Normal.z);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,pos.y+1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n          float3 Normal = CalculateVertexNormals(_vWorld,V1_wPos,V2_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          output += float3(Normal.x,Normal.y,Normal.z);\n\n        \}\n      \}\n    \}\n  \}\n  return output;\n\}\n\n\n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 hitNormal = cross((V1 - V0),(V2 - V0)); \n        return hitNormal;\n\}\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float3 output = float3(0.0f);\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float3 point_pos = float3(_sample.x,_sample.y,_sample.z);\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n      dst() = float4(0.0f);\n      output+=facet_render(pos,float3(_sample.x,_sample.y,_sample.z))*2.0f;\n      _sample = ppos(pos.x-1,pos.y); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x-1,pos.y+1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y+1),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x,pos.y-1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x,pos.y-1),float3(_sample.x,_sample.y,_sample.z));\n\n      output = normalize(output);\n      float3 normal = -output;\n\n      \n\n\n      dst() = float4(normal.x,normal.y,normal.z,1.0f);\n    \}\n  \} //----> process\n\};\n"
   rebuild ""
   "PointRender3D_half Lambert" false
   PointRender3D_light_position {{parent.Axis1.translate} {parent.Axis1.translate} {parent.Axis1.translate}}
   PointRender3D_light_color {0 0 0}
   rebuild_finalise ""
   name BlinkScript1
   xpos 389
   ypos 344
  }
  Grade {
   multiply 0.5
   add 0.5
   black_clamp false
   name Grade1
   xpos 389
   ypos 376
   disable true
  }
  Output {
   name Output1
   xpos 389
   ypos 459
  }
  Axis2 {
   inputs 0
   translate {0.5 0.5 0.5}
   name Axis1
   xpos 661
   ypos 318
   addUserKnob {20 Ivy}
   addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
   addUserKnob {26 divider4 l "" +STARTLINE}
   addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
   _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
   addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
   addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
   addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
   _expressions {{curve}}
   addUserKnob {26 divider0 l "" +STARTLINE}
   addUserKnob {20 dbinfo l "DB Info" n 1}
   dbinfo 0
   addUserKnob {1 twig_dnuuid l "Twig Id"}
   addUserKnob {1 stalk_dnuuid l "Stalk Id"}
   addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
   addUserKnob {1 leaf_dnuuid l "Leaf Id"}
   addUserKnob {26 divider1 l "" +STARTLINE}
   addUserKnob {1 twigtype l "Twig Type"}
   addUserKnob {1 leaf_label l Leaf}
   addUserKnob {1 ivy_version l Version}
   addUserKnob {43 ivy_notes l Notes}
   addUserKnob {26 divider2 l "" +STARTLINE}
   addUserKnob {1 build_label l "Build Label"}
   addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
  }
 end_group
 Switch {
  inputs 2
  which {{parent.connect_aux}}
  name Switch3
  xpos -324
  ypos 498
 }
set N1e437f60 [stack 0]
push $N1e396730
 Expression {
  temp_name0 xd
  temp_expr0 red-Camera1.world_matrix.3
  temp_name1 yd
  temp_expr1 green-Camera1.world_matrix.7
  temp_name2 zd
  temp_expr2 blue-Camera1.world_matrix.11
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  expr3 Distance
  name Expression1
  xpos -456
  ypos -192
 }
 Grade {
  channels rgba
  blackpoint {{parent.FogFar}}
  whitepoint {{parent.FogNear}}
  gamma {{1/(parent.FogExponent+0.000000001)}}
  white_clamp true
  name Grade1
  xpos -456
  ypos -168
 }
push $N1e326270
 Dot {
  name Dot7
  xpos -307
  ypos -513
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge1
  xpos -341
  ypos -168
  disable {{!parent.Fog}}
 }
 Shuffle {
  name Shuffle3
  xpos -341
  ypos 8
 }
set N1e4742d0 [stack 0]
 Shuffle {
  red white
  green white
  blue white
  name Shuffle2
  xpos -28
  ypos 76
 }
push $N1e3c0950
 BlinkScript {
  inputs 4
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Render/3D_PointRender_v18.cpp
  recompileCount 806
  ProgramGroup 1
  KernelDescription "2 \"PointRender3D\" iterate pixelWise b6c79b641c58390f32c944e2b5792a8702107f9cfc926636430288e7e0e1b392 5 \"ppos\" Read Random \"src\" Read Random \"normals\" Read Random \"occlusion\" Read Random \"dst\" Write Random 50 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"vertexformat\" Int 2 CgAAAAoAAAA= \"Zoom\" Float 1 AACAPw== \"Filtering Method\" Int 1 AQAAAA== \"_alphaMultiplier\" Float 1 AACAPw== \"_pointRender\" Bool 1 AQ== \"_wireRender\" Bool 1 AQ== \"_facetRender\" Bool 1 AQ== \"_maxLDistance\" Float 1 AACAPw== \"_maxLConnections\" Int 1 AQAAAA== \"_maxPlexType\" Int 1 AAAAAA== \"_plexLinedefXY\" Bool 1 AA== \"_plexLinedefX\" Bool 1 AA== \"_plexLinedefY\" Bool 1 AA== \"_plexLinedefXtoY\" Bool 1 AA== \"_plexLinedefAUX\" Bool 1 AA== \"_plexConnectX\" Bool 1 AA== \"_plexConnectY\" Bool 1 AA== \"_L_gamma\" Float 1 AACAPw== \"Enable Depth of Field\" Bool 1 AA== \"samples\" Int 1 AwAAAA== \"rings\" Int 1 BQAAAA== \"focalDepth\" Float 1 AACAPw== \"_depthOfField\" Float 1 AACAQA== \"_depthMult\" Float 1 zczMPQ== \"_maxDofSize\" Float 1 AAAAQQ== \"dof_aspect\" Float 1 AACAPw== \"dof_threshold\" Float 1 AACAPw== \"dof_gain\" Float 1 AAAAAA== \"dof_bias\" Float 1 AAAAwA== \"dof_fringe\" Float 1 AAAAAA== \"_flatshading\" Bool 1 AQ== \"_backfacing\" Bool 1 AQ== \"_frontfacing\" Bool 1 AQ== \"_vertexMode\" Int 1 AAAAAA== \"_depthBuffer\" Bool 1 AQ== \"_texoffset\" Float 2 AAAAPwAAAD8= \"_pointSize\" Int 1 AQAAAA== \"_gaussigma\" Float 1 AACAPw== \"_depthOcclusion\" Bool 1 AQ== \"depthMultiplier\" Float 1 AACAPw== \"_maxLineSteps\" Float 1 AAB6RQ== \"_lineOffset\" Float 1 AACAPw== \"_lineInMultiplier\" Float 1 AACAPw== \"_lineOutMultiplier\" Float 1 AACAPw== \"_overscan\" Float 2 AAAAAAAAAAA= \"isDepth\" Bool 1 AA== 50 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"Vformat\" 2 1 \"zoom\" 1 1 \"_filtering\" 1 1 \"_alphaMultiplier\" 1 1 \"_pointRender\" 1 1 \"_wireRender\" 1 1 \"_facetRender\" 1 1 \"_maxPlexDistance\" 1 1 \"_maxPlexConnections\" 1 1 \"_maxPlexType\" 1 1 \"_plexLinedefXY\" 1 1 \"_plexLinedefX\" 1 1 \"_plexLinedefY\" 1 1 \"_plexLinedefXtoY\" 1 1 \"_plexLinedefAUX\" 1 1 \"_plexConnectX\" 1 1 \"_plexConnectY\" 1 1 \"_plex_gamma\" 1 1 \"_dof_enable\" 1 1 \"_dof_samples\" 1 1 \"_dof_rings\" 1 1 \"focalDepth\" 1 1 \"_depthOfField\" 1 1 \"_depthMult\" 1 1 \"_maxDofSize\" 1 1 \"dof_aspect\" 1 1 \"dof_threshold\" 1 1 \"dof_gain\" 1 1 \"dof_bias\" 1 1 \"dof_fringe\" 1 1 \"_flatshading\" 1 1 \"_backfacing\" 1 1 \"_frontfacing\" 1 1 \"_vertexMode\" 1 1 \"_depthBuffer\" 1 1 \"_texoffset\" 2 1 \"_pointSize\" 1 1 \"_gaussigma\" 1 1 \"_depthOcclusion\" 1 1 \"depthMultiplier\" 1 1 \"_maxLineSteps\" 1 1 \"_lineOffset\" 1 1 \"_lineInMultiplier\" 1 1 \"_lineOutMultiplier\" 1 1 \"_overscan\" 2 1 \"isDepth\" 1 1 10 \"max_line_connections\" Int 1 1 AAAAAA== \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "//Some basic generic functions.\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float3 Cross(float3 A,float3 B)\n\{\n    return float3(A.y*B.z - A.z*B.y,A.z*B.x - A.x*B.z,A.x*B.y - A.y*B.x);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}     \n\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\ninline float mix(float _X,float _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}                                                                                              \n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n\n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight,\n    float2 overscan\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f-overscan.x || pRaster.x > imageWidth+overscan.x || \n       pRaster.y < 0.0f-overscan.y || pRaster.y > imageHeight+overscan.y || pRaster.z < 0.0f) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eRead, eAccessRandom, eEdgeClamped> src;     //The texture map\n  Image<eRead, eAccessRandom, eEdgeClamped> normals;     //The texture map  \n  Image<eRead, eAccessRandom, eEdgeClamped> occlusion;     //The texture map \n  Image<eWrite, eAccessRandom> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat,Vformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    int _filtering;        //Filter method\n    float _alphaMultiplier; //Additive multiplier\n    bool _pointRender,_wireRender,_facetRender;\n    float _maxPlexDistance; //Additive multiplier\n    int _maxPlexConnections;\n    int _maxPlexType; // 0==Grid, -1==Nearest\n    bool _plexLinedefXY,_plexLinedefX,_plexLinedefY,_plexLinedefXtoY,_plexLinedefAUX; // Define what connections NOT to include\n    bool _plexConnectX,_plexConnectY; //Connect from the edge of x to 0, or edge of y to 0, usually for spheres\n    float _plex_gamma; //The threshold making shorter paths bright and longer paths dark\n    bool _dof_enable; // Enable DOF\n    int _dof_samples; // How many samples per DOF ring\n    int _dof_rings; // How many rings \n    float focalDepth,_depthOfField,_depthMult,_maxDofSize; //DOF Settings\n    float dof_aspect; //Pixel aspect ratio\n    float dof_threshold;\n    float dof_gain;\n    float dof_bias; //bokeh edge bias\n    float dof_fringe; //bokeh chromatic aberration/fringing\n    bool _flatshading,_backfacing,_frontfacing; //Vertex rendering settings\n    int _vertexMode;  //The rendering output mode, (think AOV)\n    bool _depthBuffer; //Non-additive, only render front most pixel\n    float2 _texoffset;\n    int _pointSize;\n    float _gaussigma;\n    bool _depthOcclusion;\n    float depthMultiplier;\n    float _maxLineSteps; //cap the line length to avoid process lock\n    float _lineOffset; //Alow you to shrink or extend the lines\n    float _lineInMultiplier,_lineOutMultiplier; //Control the brightness of the wires at the tips.\n    float2 _overscan; //This will allow you to render some extra outside the bounds of the image.\n    bool isDepth; //This will allow you to render some extra outside the bounds of the image.\n\n  local: //Local variables\n    int max_line_connections;\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(Vformat,      \"vertexformat\", int2(10,10));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(_filtering, \"Filtering Method\", 1); \n    defineParam(_alphaMultiplier, \"_alphaMultiplier\", 1.0f);     \n    defineParam(_pointRender, \"_pointRender\", true);  \n    defineParam(_wireRender, \"_wireRender\", true);\n    defineParam(_facetRender, \"_facetRender\", true);\n    defineParam(_maxPlexDistance, \"_maxLDistance\", 1.0f);    \n    defineParam(_maxPlexConnections, \"_maxLConnections\", 1);    \n    defineParam(_maxPlexType, \"_maxPlexType\", 0); \n    defineParam(_plexLinedefXY, \"_plexLinedefXY\", false);      \n    defineParam(_plexLinedefXtoY, \"_plexLinedefXtoY\", false); //NYI\n    defineParam(_plexLinedefAUX, \"_plexLinedefAUX\", false); \n    defineParam(_plexLinedefX, \"_plexLinedefX\", false);  \n    defineParam(_plexLinedefY, \"_plexLinedefY\", false);  \n    defineParam(_plexConnectX, \"_plexConnectX\", false);      \n    defineParam(_plexConnectY, \"_plexConnectY\", false);   \n    defineParam(_plex_gamma, \"_L_gamma\", 1.0f);\n    //DOF SETTINGS   \n    defineParam(_dof_enable, \"Enable Depth of Field\", false);   \n    defineParam(_dof_samples, \"samples\", 3);    \n    defineParam(_dof_rings, \"rings\", 5);   \n    defineParam(focalDepth, \"focalDepth\", 1.0f);  \n    defineParam(_depthOfField, \"_depthOfField\", 4.0f);  \n    defineParam(_depthMult, \"_depthMult\", 0.1f);  \n    defineParam(_maxDofSize, \"_maxDofSize\", 8.0f);  \n    defineParam(dof_aspect, \"dof_aspect\", 1.0f);  \n    defineParam(dof_threshold, \"dof_threshold\", 1.0f);  \n    defineParam(dof_gain, \"dof_gain\", 0.0f);  \n    defineParam(dof_bias, \"dof_bias\", -2.0f);  \n    defineParam(dof_fringe, \"dof_fringe\", 0.0f); \n    //SHADING SETTINGS \n    defineParam(_flatshading, \"_flatshading\", true);  \n    defineParam(_vertexMode, \"_vertexMode\", 0);  \n    defineParam(_backfacing, \"_backfacing\", true);    \n    defineParam(_frontfacing, \"_frontfacing\", true);        \n    defineParam(_depthBuffer, \"_depthBuffer\", true);  \n    defineParam(_texoffset, \"_texoffset\", float2(0.5f,0.5f)); \n    defineParam(_pointSize, \"_pointSize\", 1); \n    defineParam(_gaussigma, \"_gaussigma\", 1.0f); \n    defineParam(_depthOcclusion, \"_depthOcclusion\", true); \n    defineParam(depthMultiplier, \"depthMultiplier\", 1.0f); \n    defineParam(_maxLineSteps, \"_maxLineSteps\", 4000.0f); \n    defineParam(_lineOffset, \"_lineOffset\", 1.0f); \n    defineParam(_lineInMultiplier, \"_lineInMultiplier\", 1.0f);   \n    defineParam(_lineOutMultiplier, \"_lineOutMultiplier\", 1.0f);     \n    defineParam(_overscan, \"_overscan\",float2(0.0f,0.0f));    \n\n  \}\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    max_line_connections = 80;\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n  \}\n\n  //Convert a 3d point position into a 2d raster position.\n  float3 Reconsile3D(float3 _PointPos)\{\n      vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      return tRaster;\n  \}\n\n//------------------------------\n//-------DRAW FUNCTIONS---------\n//------------------------------\n  //Write pixels to output.\n  void writepixel(float posx,float posy, float4 color,int index,float weight=1.0f)\n  \{ \n      if (_depthOcclusion)\{\n        float4 depthSample = occlusion(posx,posy);\n        if (depthSample.x<=vRaster.z && depthSample.w>0.0f)\{\n\n          float depth = (vRaster.z-depthSample.x);\n          color = color*(1.0f-depthSample.w);\n          color = color / (((depth*depth)*depthMultiplier)+1.0f);\n          //return;\n        \}\n      \}\n      float4 finalOutput; //This is used to store the final output\n      float4 dstSample; //This is used to store a sample of the destination\n      if ( dst.bounds.inside( posx, posy ) ) \{ //Test if the pixel written to is inside the output image. \n        if (_depthBuffer) \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          if ((dstSample.w>color.w)||dstSample.w==0.0f) \{\n            dst(posx,posy) = color;\n          \}\n        \}\n        else \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          finalOutput = dstSample + (color*_alphaMultiplier*weight);\n          finalOutput.w = dstSample.w + ((color.w*_alphaMultiplier*weight));\n\n          finalOutput.w = (dstSample.w + ((color.w*_alphaMultiplier*weight)))-(dstSample.w * ((color.w*_alphaMultiplier*weight)));\n\n          dst(posx,posy) = finalOutput;\n        \}\n      \} \n  \}\n\n  //Calculate a Bilinear Plot\n  void bilinear_Plot(float2 temppos,float4 color,int index)\n  \{\n    float2 p;\n    p.x=Frac(temppos.x);\n    p.y=Frac(temppos.y);\n    float weights\[] = \{(1.0f-p.x)*(1.0f-p.y), p.x*(1.0f-p.y), (1.0f-p.x)*p.y, p.x*p.y\};\n    int2 _position = int2(floor(temppos.x)-0,floor(temppos.y)-0); \n    writepixel(_position.x,_position.y,color,index,weights\[0]);\n    writepixel(_position.x+1,_position.y,color,index,weights\[1]);\n    writepixel(_position.x,_position.y+1,color,index,weights\[2]);\n    writepixel(_position.x+1,_position.y+1,color,index,weights\[3]);\n  \}\n\n  //NYI, unused!\n  void gaussian(float2 temppos,float4 color,int index)\{\n    float in_x = temppos.x;\n    float in_y = temppos.y;\n    int kernelSize = (_pointSize+1)*2;\n    int subsize = (kernelSize /2)-1;\n    float gKernel\[64]\[64];\n    float sigma = _gaussigma;\n    float intSigma = float(_pointSize);\n    float r, s = intSigma * sigma * sigma;\n\n    float sum = 0.0f;\n\n    // generate 5x5 kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            r = float(sqrt(x*x + y*y));\n            gKernel\[x + subsize]\[y + subsize] = (exp(-(r*r)/s))/(3.141592654f * s);\n            sum += gKernel\[x + subsize]\[y + subsize];\n        \}\n    \}\n\n    // normalize the Kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            gKernel\[x + subsize]\[y + subsize] /= sum;\n            writepixel(in_x+x,in_y+y,color,index,gKernel\[x + subsize]\[y + subsize]);\n        \}\n    \}\n  \}\n\n//-------------------------------------\n// DrawLine\n// ----------\n// Draw a line between two points, \n// x,y being 2d screenspace pos and z being depth.\n//-------------------------------------\n  void DrawLine(float3 origin, float3 endpoint,float4 _colorA,float4 _colorB) \{\n    float4 _color;\n    float3 delta = origin-endpoint;\n    float3 curPoint = origin;\n    float mag = sqrt(delta.x*delta.x+delta.y*delta.y);\n    mag = min(mag,_maxLineSteps); //Lets not go crazy, we cap it at 10.000 to avoid insane unwated processing time \n    for( float a = 0; a < mag*_lineOffset; a = a + 1.0f )\{\n      curPoint -= (delta/mag);\n      _color = (_colorA*(1.0f-(a/mag*1.0f)))+(_colorB*(a/mag*1.00f));\n      if (_dof_enable)\{\n        Bokeh(curPoint,_color);\n      \}\n      else \{\n        if (_depthBuffer && isDepth) \{_color = float4(1.0f,1.0f,1.0f,curPoint.z);\} //Added\n        bilinear_Plot(float2(curPoint.x,curPoint.y),_color,1);\n      \}\n      \n    \}\n  \}\n\n//-------------------------------------\n// Point_Render\n//-------------------------------------\nvoid point_render(int2 pos, float3 screen_pos)\{\n  float4 color = src(pos.x,pos.y);\n\n  if (_filtering == 1)\{\n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        if (_depthBuffer) \{color.w = screen_pos.z;\} //Added\n        bilinear_Plot(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  /*\n  //THIS PART NEEDS TO BE RE-WRITTEN.\n  else if (_filtering == 2)\{ \n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        gaussian(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  */\n  else \{\n      int2 _position = int2(floor(screen_pos.x),floor(screen_pos.y)); \n      if (_depthBuffer) \{color.w = screen_pos.z;\}\n      writepixel(_position.x,_position.y, color,1,1.0f); //OutputSample\n  \}\n\n\}\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nvoid facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x+1,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos,V0_N,V1_N,V2_N;\n    float2 V0_ST,V1_ST,V2_ST;\n    float4 V1_Sample,V2_Sample;\n    float4 _tn;\n    float3 normal0,normal1,normal2;\n    float2 UV_Format = float2(Vformat.x,Vformat.y);\n\n\n    int2 P0 = int2(pos.x-1,pos.y-1);\n    int2 P1 = int2(pos.x+1,pos.y+1);\n    if (_plexConnectX && pos.x == int(Vformat.x))\{\n      insideX == true;\n      P1 = int2(0.0f,pos.y+1);\n    \}\n    if (_plexConnectY && pos.y == int(Vformat.y))\{\n      insideYtop == true;\n      P1 = int2(pos.x+1,0);\n    \} \n\n    if (_plexConnectY && pos.y == 0)\{\n      insideY == true;\n      P0 = int2(pos.x-1,int(UV_Format.y));\n    \} \n\n    if (!_flatshading) \{\n      _tn = normals(pos.x,pos.y);\n      V0_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n    V0_ST = float2(pos.x,pos.y)/UV_Format;\n\n  if (insideX) \{\n    V2_Sample = ppos(P1.x,pos.y);\n    V2_ST = float2(P1.x,pos.y)/UV_Format;\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (!_flatshading) \{\n      _tn = normals(P1.x,pos.y);\n      V2_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n        \n\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(P1.x,P0.y);\n        V1_ST = float2(P1.x,P0.y)/UV_Format;\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(P1.x,P0.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}\n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V2_Pos,V1_Pos,_vWorld,V2_wPos,V1_wPos,V0_N,V2_N,V1_N,V0_ST,V2_ST,V1_ST);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,P1.y);\n        V1_ST = float2(pos.x,P1.y)/UV_Format;        \n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(pos.x,P1.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}        \n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V1_Pos,V2_Pos,_vWorld,V1_wPos,V2_wPos,V0_N,V1_N,V2_N,V0_ST,V1_ST,V2_ST);\n        \}\n      \}\n    \}\n  \}\n\}\n\n\n\n//This function will calculate if pixel C is inside the triangle\nfloat edgeFunction(float3 a, float3 b, float3 c) \n\{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n\} \n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat Distance(float3 _a,float3 _b)\n\{\n          float xd = _a.x - _b.x;\n          float yd = _a.y - _b.y;\n          float zd = _a.z - _b.z;\n          return sqrt(xd*xd + yd*yd + zd*zd);\n\}\n\nvoid DrawTriangle(float3 V0, float3 V1, float3 V2,float3 WP0, float3 WP1, float3 WP2,float3 N0, float3 N1, float3 N2, float2 st0,float2 st1,float2 st2) \{\n\n  // Precompute reciprocal of vertex z-coordinate \n  V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n\n  float2 st0n = st0 * V0.z;\n  float2 st1n = st1 * V1.z; \n  float2 st2n = st2 * V2.z; //Normal version of ST\n\n  bool inside; \n  float X0 = Fmin(V0.x,V1.x,V2.x)-1.0f;\n  float X1 = Fmax(V0.x,V1.x,V2.x)+1.0f;\n  float Y0 = Fmin(V0.y,V1.y,V2.y)-1.0f;\n  float Y1 = Fmax(V0.y,V1.y,V2.y)+1.0f;\n  float area = edgeFunction(V2, V1, V0);\n\n\n  float2 sampos = float2(st0.x*float(Vformat.x),st0.y*float(Vformat.y));\n  float4 text0 = src(sampos.x,sampos.y);\n  sampos = float2(st1.x*float(Vformat.x),st1.y*float(Vformat.y));\n  float4 text1 = src(sampos.x,sampos.y);\n  sampos = float2(st2.x*float(Vformat.x),st2.y*float(Vformat.y));  //Why do we have to do this? =(\n  float4 text2 = src(sampos.x,sampos.y);\n  sampos = float2(min(min(st0.x,st1.x),st2.x)*float(Vformat.x),min(min(st0.y,st1.y),st2.y)*float(Vformat.y));\n  float4 text3 = src(sampos.x,sampos.y);\n\n\n  for( int x = X0; x < X1 ; x++) \{\n    for( int y = Y0; y < Y1 ; y++) \{\n      float3 pixelSample(x + _texoffset.x, y + _texoffset.y,0.0f); \n\n      //This is the part where we test if the current pixel is inside the triangle\n      //We check both for front facing and back faing options\n      float w0 = edgeFunction(V1, V0, pixelSample); //Front Facing\n      float w1 = edgeFunction(V2, V1, pixelSample); \n      float w2 = edgeFunction(V0, V2, pixelSample); \n      float w3 = edgeFunction(V0, V1, pixelSample); //Back Facing\n      float w4 = edgeFunction(V1, V2, pixelSample); \n      float w5 = edgeFunction(V2, V0, pixelSample);\n\n      //writepixel(x,y, float4(w1),1,1.0f);\n      if ((w0 >= 0 && w1 >= 0 && w2 >= 0 && _frontfacing) || (w3 >= 0 && w4 >= 0 && w5 >= 0 && _backfacing)) \{ //The curent pixel is inside the triangle\n\n       // calculate vectors from point f to vertices p1, p2 and p3:\n       float3 f1 = V0-pixelSample;\n       float3 f2 = V1-pixelSample;\n       float3 f3 = V2-pixelSample;\n       // calculate the areas and factors (order of parameters doesn't matter):\n       float a = length(cross(V0-V1,V0-V2 )); // main triangle area a\n       area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n        w0 /= area; \n        w1 /= area; \n        w2 /= area; \n\n        w3 /= area; \n        w4 /= area; \n        w5 /= area; \n\n       float a1 = length(cross(f2, f3)) / a; // p1's triangle area / a\n       float a2 = length(cross(f3, f1)) / a; // p2's triangle area / a \n       float a3 = length(cross(f1, f2)) / a; // p3's triangle area / a\n       float a_magnitude = a1+a2+a3;\n       a1 = a1/a_magnitude;\n       a2 = a2/a_magnitude;\n       a3 = a3/a_magnitude;\n       float z = 1.0f / (V0.z * a1 + V1.z * a2 + V2.z * a3); \n\n\n        // find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):\n        float2 uv = st0 * a1 + st1 * a2 + st2 * a3;\n        float2 st = st0 * w0 + st1 * w1 + st2 * w2; \n        st *= z;      \n\n\n        //Calculate normals. Eighter we have flat shading, else we calculate a normal per pixel\n        float3 normalB;\n        if (_flatshading) \{\n          normalB = CalculateSurfaceNormals(WP0,WP1,WP2);\n\n        \}\n        else \{\n          float3 c0 = N2/float3(V0.z); \n          float3 c1 = N0/float3(V1.z); \n          float3 c2 = N1/float3(V2.z);  \n\n          normalB.x = w0 * c0.x + w1 * c1.x + w2 * c2.x; \n          normalB.y = w0 * c0.y + w1 * c1.y + w2 * c2.y; \n          normalB.z = w0 * c0.z + w1 * c1.z + w2 * c2.z; \n\n          normalB.x *= z, normalB.y *= z, normalB.z *= z; \n        \}\n        normalB = normalize(normalB);\n\n        //CALCULATE THE OBJECT TEXTURE COORDINATES\n        float zn = 1.0f / (V0.z * w0 + V1.z * w1 + V2.z * w2); \n        st = st0n * w0 + st1n * w1 + st2n * w2; \n        st *= zn;   \n        //--END \n\n        float3 Wpos = WP0*a1 + WP1*a2 + WP2*a3; //World Position.\n        float3 ViewNormal = normalize(float3(cameraToWorld\[3]\[0],cameraToWorld\[3]\[1],cameraToWorld\[3]\[2])-Wpos);\n\n        float nDotView =  dot(normalB,ViewNormal);\n        nDotView = 1.0f-fabs(nDotView); //make sure that the view normal ramps back around when doing backface\n        float4 tempout;\n\n        //Flatshading or regular?\n        if (!_flatshading) \{\n          tempout = text0 * a1 + text1 * a2 + text2 * a3; \n        \}\n        else\{\n          tempout = text3;\n        \}\n\n        //Additional Render Modes\n        if (_vertexMode == 1)\{\n          tempout = float4(a1,a2,a3,1.0f);\n        \}\n        else if (_vertexMode == 2)\{\n          tempout = float4(normalB.x,normalB.y,normalB.z,1.0f);\n        \}\n        else if (_vertexMode == 3)\{\n          tempout = float4(nDotView,nDotView,nDotView,1.0f);\n        \}\n        else if (_vertexMode == 4)\{\n          tempout = float4(uv.x,uv.y,0.0f,1.0f);\n        \}       \n        else if (_vertexMode == 5)\{\n          tempout = float4(st.x,st.y,0.0f,1.0f);\n        \}               \n        else if (_vertexMode == 6)\{\n          tempout = float4(ViewNormal.x,ViewNormal.y,ViewNormal.z,1.0f);\n        \}             \n        else if (_vertexMode == 7)\{\n          tempout = float4(Wpos.x,Wpos.y,Wpos.z,1.0f);\n        \}   \n\n        if (_depthBuffer)\{\n          writepixel(x,y, float4(tempout.x,tempout.y,tempout.z,z),1,1.0f);  \n        \}\n        else \{\n          if (_dof_enable)\{\n            Bokeh(float3(x,y,z),float4(tempout.x,tempout.y,tempout.z,z));\n          \}\n          else \{\n            bilinear_Plot(float2(x,y),float4(tempout.x,tempout.y,tempout.z,z),1);\n          \}\n        \}\n\n      \}  \n\n    \}\n  \}\n\}\n\n//-------------------------------------\n// Wire_Render\n//-------------------------------------\nvoid wire_render(int2 pos) \{\n  float4 temp = float4(0.0f,0.0f,0.0f,FLT_MAX);\n  float4 wire_ref_sample;\n  int2 tempXY = int2(0,0);\n  float4 plexlist\[11] = \{temp,temp,temp,temp,temp,temp,temp,temp,temp,temp,temp\}; \n  int2 plexlistXY\[11] = \{tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY\};\n  int plex_count = 0; //We use this to figure how many points that should connect.\n  float plex_dist;\n  float3 plex_position,plex_position_b;\n  float4 temp_pos, temp_pos_b; //Temporary Position Containers\n  if (_maxPlexType == -1) \{ //Used for random connection types\n    for( int x = 0; x < max_line_connections ; x++)\{ //THIS 80 NUMBER IS THE LIMIT TO AVOID TOO SLOW PROCESSING!\n      for( int y = 0; y < max_line_connections ; y++)\{\n        wire_ref_sample = ppos(x,y);\n        if (wire_ref_sample.w != 0.0f && pos.x!=x && pos.y != y) \{ \n          plex_position = float3(wire_ref_sample.x,wire_ref_sample.y,wire_ref_sample.z)*(zoom);\n          float xd = plex_position.x - vWorld.x;\n          float yd = plex_position.y - vWorld.y;\n          float zd = plex_position.z - vWorld.z;\n          float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n          if (plex_dist<_maxPlexDistance)\{\n            plex_count = min(10,plex_count+1); //Add one to the count\n            for( int h = 0; h < plex_count+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n              if (plex_dist < plexlist\[h].w) \{                  \n                for( int i = plex_count+1; i > h ; i--) \{\n                  plexlist\[i] = plexlist\[i-1];\n                  plexlistXY\[i] = plexlistXY\[i-1];\n                \}\n                plexlist\[h] = float4(plex_position.x,plex_position.y,plex_position.z,plex_dist);\n                plexlistXY\[h] = int2(x,y);\n                break;        \n              \}\n            \}\n          \} \n        \}\n      \}\n    \}\n  \}\n  else\{ //Used for standard connection types\n    float4 temp_pos;\n    bool insideX = !(Vformat.x < pos.x+1);\n    bool insideY = !(Vformat.y < pos.y+1);\n\n\n    if (!_plexLinedefAUX)\{\n      temp_pos = normals(pos.x,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,vWorld+plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideX && !_plexLinedefX) \{\n      temp_pos = ppos(pos.x+1,pos.y );\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && !_plexLinedefX) \{\n      temp_pos = ppos(0,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideY && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\}                          \n    \}\n    else if ( _plexConnectY  && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,0);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    //_plexConnect\n    if ( insideX && insideY && !_plexLinedefXY) \{              \n      temp_pos = ppos(pos.x+1,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && _plexConnectY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && insideY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectY && insideX && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n  \}   \n\n  //now that all the connections have been sorted by distance then we connect the dots.\n  for( int x = 0; x < min(_maxPlexConnections,plex_count) ; x++)\{\n    plex_position = float3(plexlist\[x].x,plexlist\[x].y,plexlist\[x].z);\n    plex_dist = plexlist\[x].w;\n\n\n    float plex_distribution = 1.0f-((plexlist\[x].w-plexlist\[0].w)/((plexlist\[min(_maxPlexConnections,plex_count)].w-plexlist\[0].w)+0.00001f)); //Where does it lie between the best and the worst distance?\n    //plexlistXY\n\n    float4 plex_col = float4(pow(1.0f-(plex_dist/_maxPlexDistance),1.0f/_plex_gamma))*float4(plex_distribution); //This one is quite cool aswell, but does leave the center ones a bit too focused \n    float4 plex_colorA = src(pos.x,pos.y);\n    float4 plex_colorB = src( plexlistXY\[x].x,plexlistXY\[x].y);\n    plex_col *= 0.1f;\n\n    computePixelCoordinates(plex_position, pRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n    if (dst.bounds.inside(int(vRaster.x),int(vRaster.y)) || dst.bounds.inside(int(pRaster.x),int(pRaster.y)))\{\n        DrawLine(vRaster,pRaster,(plex_colorA*plex_col)*_lineInMultiplier,(plex_colorB*plex_col)*_lineOutMultiplier);\n    \}\n  \}\n\}\n\nvoid wire_connection(float3 p_source,float3 p_target, float4 (&p_plexlist)\[11], int2 (&p_plexlistXY)\[11],int &p_plexcount,int2 position) \{\n  float xd = p_target.x - p_source.x;\n  float yd = p_target.y - p_source.y;\n  float zd = p_target.z - p_source.z;\n  float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n  if (plex_dist<_maxPlexDistance)\{\n    p_plexcount = min(11,p_plexcount+1); //Add one to the count\n    for( int h = 0; h < p_plexcount+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n      if (plex_dist < p_plexlist\[h].w) \{                  \n        for( int i = p_plexcount+1; i > h ; i--) \{\n          p_plexlist\[i] = p_plexlist\[i-1];\n          p_plexlistXY\[i] = p_plexlistXY\[i-1];\n        \}\n        p_plexlist\[h] = float4(p_target.x,p_target.y,p_target.z,plex_dist);\n        p_plexlistXY\[h] = int2(position.x,position.y);\n        break;        \n      \}\n    \}  \n  \}\n\}\n//-------END OF WIRE RENDER FUNCTIONS---------\n\n\n\n\n//-------------------------------\n//-------BOKEH FUNCTIONS---------\n//thanks to: http://devlog-martinsh.blogspot.dk/2011/11/glsl-depth-of-field-with-bokeh-v21.html\nfloat2 rand(float2 coord) //generating noise/pattern texture for dithering\n\{\n  float noiseX = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.25)+(Frac(coord.y*(WHformat\[1]/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.75)+(Frac(coord.y*(WHformat\[1]/2.0))*0.25))*2.0-1.0;\n  noiseX = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f))) * 43758.5453f),0.0f,1.0f)*2.0f-1.0f;\n  noiseY = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f)*2.0f)) * 43758.5453f),0.0f,1.0f)*2.0-1.0f;\n  return float2(noiseX,noiseY);\n\}\n//-------------------------------------\n// Bokeh\n//-------------------------------------\nvoid Bokeh(float3 pos,float4 color)\{\n  float blur = 0.0;\n  blur = clamp((fabs(pos.z - focalDepth)/_depthOfField)*100.0f,-_maxDofSize,_maxDofSize);\n  \n  float w = (1.0/WHformat.x)*blur;//+noise.x;\n  float h = (1.0/(WHformat.x*dof_aspect))*blur;//+noise.y;\n  float3 v3_col = float3(color.x,color.y,color.z);\n  int ringsamples;\n  float s = 1.0;  \n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples; \n    for (int j = 0 ; j < ringsamples ; j += 1)  \n    \{ \n      s += (1.0f*mix(1.0f,(float(i))/(float(_dof_rings)),dof_bias)*1.0f); //No need to do this in the loop\n    \}\n  \}\n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples;\n     \n    for (int j = 0 ; j < ringsamples ; j += 1)   \n    \{\n      float step = PI*2.0 / float(ringsamples);\n      float pw = (cos(float(j)*step)*(float(i)/_dof_rings));\n      float ph = (sin(float(j)*step)*(float(i)/_dof_rings));\n      float p = 1.0;\n\n      float posx = pos.x+((pw*w)*blur);\n      float posy = pos.y+((ph*h)*blur);\n\n\n      float3 lumcoeff = float3(0.299,0.587,0.114);\n      float lum = dot(v3_col, lumcoeff);\n      float thresh = max((lum-dof_threshold)*dof_gain, 0.0f);\n      v3_col+mix(float3(0.0),v3_col,thresh*blur);\n\n      float3 col = (v3_col*mix(1.0,(float(i))/(float(_dof_rings)),dof_bias)*p)/s; \n      bilinear_Plot(float2(posx,posy),float4(col.x,col.y,col.z,color.w/(_dof_rings*_dof_rings)),1);\n    \}\n  \}\n\}\n//-------END OF BOKEH FUNCTIONS---------\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float2 posf = float2(pos.x,pos.y);\n\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n\n      //Convert worldspace coordinates to screenspcace coordinates.\n      vWorld = float3(_sample.x,_sample.y,_sample.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, vRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      if (ret) \{ //Only create points that are visible on screen\n        if (_pointRender)\{\n          point_render(pos,vRaster);\n        \}\n      \} //Pointrender over\n\n      if (_wireRender && _maxPlexConnections>=1) \{\n        if (max(pos.x,pos.y)<=max_line_connections || (_maxPlexType==0))\{ // Don't process more wires than allowed in nearest mode.\n          wire_render(pos);\n        \}\n      \} //WireRender over\n\n      if (_facetRender) \{\n        facet_render(pos,float3(_sample.x,_sample.y,_sample.z));\n      \}  //FacetRender over\n      \n    \}\n  \} //----> process\n\};\n"
  useGPUIfAvailable false
  rebuild ""
  PointRender3D_cam_Matrix {
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
    }
  PointRender3D_focallength {{parent.Camera1.focal}}
  PointRender3D_hapeture {{parent.Camera1.haperture}}
  PointRender3D_format {{!proxy?Settings_Format.width:Settings_Format.width*proxy_scale} {!proxy?Settings_Format.height:Settings_Format.height*proxy_scale}}
  PointRender3D_vertexformat {{parent.InputFormat.box.r-1} {parent.InputFormat.box.t-1}}
  PointRender3D__alphaMultiplier {{parent.AlphaMultiplier}}
  PointRender3D__pointRender {{parent.RenderMode==0}}
  PointRender3D__wireRender {{parent.RenderMode==1}}
  PointRender3D__facetRender {{parent.RenderMode==2}}
  PointRender3D__maxLDistance {{parent.wire_maxdistance}}
  PointRender3D__maxLConnections {{parent.wire_connections}}
  PointRender3D__maxPlexType {{-parent.wire_type}}
  PointRender3D__plexLinedefXY {{!parent.connect_xy}}
  PointRender3D__plexLinedefX {{!parent.connect_x}}
  PointRender3D__plexLinedefY {{!parent.connect_y}}
  PointRender3D__plexLinedefAUX {{!connect_aux}}
  PointRender3D__plexConnectX {{parent.CloseX}}
  PointRender3D__plexConnectY {{parent.CloseY}}
  PointRender3D__L_gamma {{parent.wire_Threshold}}
  "PointRender3D_Enable Depth of Field" {{parent.dof_enable}}
  PointRender3D_samples {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_rings {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_focalDepth {{parent.dof_focaldepth}}
  PointRender3D__depthOfField {{parent.dof_dof}}
  PointRender3D__depthMult 0
  PointRender3D__maxDofSize {{parent.dof_maxSize*400}}
  PointRender3D_dof_aspect {{parent.dof_Aspect}}
  PointRender3D_dof_bias {{parent.dof_bias}}
  PointRender3D__flatshading {{parent.facet_flatShading}}
  PointRender3D__backfacing {{parent.facet_backface}}
  PointRender3D__frontfacing {{parent.facet_front}}
  PointRender3D__vertexMode {{parent.renderMode}}
  PointRender3D__texoffset {-0.5 0.5}
  PointRender3D__pointSize 0
  PointRender3D__depthOcclusion {{parent.UseOcclusionMap}}
  PointRender3D__maxLineSteps {{parent.maxSamples}}
  PointRender3D__lineOffset {{parent.lineoffset}}
  PointRender3D__lineInMultiplier {{parent.inGain}}
  PointRender3D__lineOutMultiplier {{parent.outGain}}
  PointRender3D__overscan {{parent.overscan} {parent.overscan}}
  PointRender3D_isDepth true
  format "1280 720 0 0 1280 720 1 HD_720"
  rebuild_finalise ""
  name BlinkScriptZdepth
  label Zdepth
  xpos -28
  ypos 100
 }
 Dot {
  name Dot10
  xpos 97
  ypos 112
 }
 TimeBlur {
  divisions {{parent.Samples}}
  shutter {{parent.Shutter}}
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur1
  xpos 63
  ypos 300
  disable {{1-parent.mb_enable x89 0}}
 }
 Expression {
  expr3 a!=0?a/r:0
  name Expression3
  selected true
  xpos 63
  ypos 324
 }
 Dot {
  name Dot9
  xpos 97
  ypos 414
 }
push $N1e36fc90
push $N1e437f60
push $N1e4742d0
push $N1e3c0950
 BlinkScript {
  inputs 4
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Render/3D_PointRender_v17.cpp
  recompileCount 803
  ProgramGroup 1
  KernelDescription "2 \"PointRender3D\" iterate pixelWise 0c100cf8a634aa2c2e18f544ec8abfd6d5d138cc25ae8f7d7127230910c2e91f 5 \"ppos\" Read Random \"src\" Read Random \"normals\" Read Random \"occlusion\" Read Random \"dst\" Write Random 49 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"vertexformat\" Int 2 CgAAAAoAAAA= \"Zoom\" Float 1 AACAPw== \"Filtering Method\" Int 1 AQAAAA== \"_alphaMultiplier\" Float 1 AACAPw== \"_pointRender\" Bool 1 AQ== \"_wireRender\" Bool 1 AQ== \"_facetRender\" Bool 1 AQ== \"_maxLDistance\" Float 1 AACAPw== \"_maxLConnections\" Int 1 AQAAAA== \"_maxPlexType\" Int 1 AAAAAA== \"_plexLinedefXY\" Bool 1 AA== \"_plexLinedefX\" Bool 1 AA== \"_plexLinedefY\" Bool 1 AA== \"_plexLinedefXtoY\" Bool 1 AA== \"_plexLinedefAUX\" Bool 1 AA== \"_plexConnectX\" Bool 1 AA== \"_plexConnectY\" Bool 1 AA== \"_L_gamma\" Float 1 AACAPw== \"Enable Depth of Field\" Bool 1 AA== \"samples\" Int 1 AwAAAA== \"rings\" Int 1 BQAAAA== \"focalDepth\" Float 1 AACAPw== \"_depthOfField\" Float 1 AACAQA== \"_depthMult\" Float 1 zczMPQ== \"_maxDofSize\" Float 1 AAAAQQ== \"dof_aspect\" Float 1 AACAPw== \"dof_threshold\" Float 1 AACAPw== \"dof_gain\" Float 1 AAAAAA== \"dof_bias\" Float 1 AAAAwA== \"dof_fringe\" Float 1 AAAAAA== \"_flatshading\" Bool 1 AQ== \"_backfacing\" Bool 1 AQ== \"_frontfacing\" Bool 1 AQ== \"_vertexMode\" Int 1 AAAAAA== \"_depthBuffer\" Bool 1 AQ== \"_texoffset\" Float 2 AAAAPwAAAD8= \"_pointSize\" Int 1 AQAAAA== \"_gaussigma\" Float 1 AACAPw== \"_depthOcclusion\" Bool 1 AQ== \"depthMultiplier\" Float 1 AACAPw== \"_maxLineSteps\" Float 1 AAB6RQ== \"_lineOffset\" Float 1 AACAPw== \"_lineInMultiplier\" Float 1 AACAPw== \"_lineOutMultiplier\" Float 1 AACAPw== \"_overscan\" Float 2 AAAAAAAAAAA= 49 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"Vformat\" 2 1 \"zoom\" 1 1 \"_filtering\" 1 1 \"_alphaMultiplier\" 1 1 \"_pointRender\" 1 1 \"_wireRender\" 1 1 \"_facetRender\" 1 1 \"_maxPlexDistance\" 1 1 \"_maxPlexConnections\" 1 1 \"_maxPlexType\" 1 1 \"_plexLinedefXY\" 1 1 \"_plexLinedefX\" 1 1 \"_plexLinedefY\" 1 1 \"_plexLinedefXtoY\" 1 1 \"_plexLinedefAUX\" 1 1 \"_plexConnectX\" 1 1 \"_plexConnectY\" 1 1 \"_plex_gamma\" 1 1 \"_dof_enable\" 1 1 \"_dof_samples\" 1 1 \"_dof_rings\" 1 1 \"focalDepth\" 1 1 \"_depthOfField\" 1 1 \"_depthMult\" 1 1 \"_maxDofSize\" 1 1 \"dof_aspect\" 1 1 \"dof_threshold\" 1 1 \"dof_gain\" 1 1 \"dof_bias\" 1 1 \"dof_fringe\" 1 1 \"_flatshading\" 1 1 \"_backfacing\" 1 1 \"_frontfacing\" 1 1 \"_vertexMode\" 1 1 \"_depthBuffer\" 1 1 \"_texoffset\" 2 1 \"_pointSize\" 1 1 \"_gaussigma\" 1 1 \"_depthOcclusion\" 1 1 \"depthMultiplier\" 1 1 \"_maxLineSteps\" 1 1 \"_lineOffset\" 1 1 \"_lineInMultiplier\" 1 1 \"_lineOutMultiplier\" 1 1 \"_overscan\" 2 1 10 \"max_line_connections\" Int 1 1 AAAAAA== \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "//Some basic generic functions.\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float3 Cross(float3 A,float3 B)\n\{\n    return float3(A.y*B.z - A.z*B.y,A.z*B.x - A.x*B.z,A.x*B.y - A.y*B.x);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}     \n\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\ninline float mix(float _X,float _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}                                                                                              \n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n\n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight,\n    float2 overscan\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f-overscan.x || pRaster.x > imageWidth+overscan.x || \n       pRaster.y < 0.0f-overscan.y || pRaster.y > imageHeight+overscan.y || pRaster.z < 0.0f) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eRead, eAccessRandom, eEdgeClamped> src;     //The texture map\n  Image<eRead, eAccessRandom, eEdgeClamped> normals;     //The texture map  \n  Image<eRead, eAccessRandom, eEdgeClamped> occlusion;     //The texture map \n  Image<eWrite, eAccessRandom> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat,Vformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    int _filtering;        //Filter method\n    float _alphaMultiplier; //Additive multiplier\n    bool _pointRender,_wireRender,_facetRender;\n    float _maxPlexDistance; //Additive multiplier\n    int _maxPlexConnections;\n    int _maxPlexType; // 0==Grid, -1==Nearest\n    bool _plexLinedefXY,_plexLinedefX,_plexLinedefY,_plexLinedefXtoY,_plexLinedefAUX; // Define what connections NOT to include\n    bool _plexConnectX,_plexConnectY; //Connect from the edge of x to 0, or edge of y to 0, usually for spheres\n    float _plex_gamma; //The threshold making shorter paths bright and longer paths dark\n    bool _dof_enable; // Enable DOF\n    int _dof_samples; // How many samples per DOF ring\n    int _dof_rings; // How many rings \n    float focalDepth,_depthOfField,_depthMult,_maxDofSize; //DOF Settings\n    float dof_aspect; //Pixel aspect ratio\n    float dof_threshold;\n    float dof_gain;\n    float dof_bias; //bokeh edge bias\n    float dof_fringe; //bokeh chromatic aberration/fringing\n    bool _flatshading,_backfacing,_frontfacing; //Vertex rendering settings\n    int _vertexMode;  //The rendering output mode, (think AOV)\n    bool _depthBuffer; //Non-additive, only render front most pixel\n    float2 _texoffset;\n    int _pointSize;\n    float _gaussigma;\n    bool _depthOcclusion;\n    float depthMultiplier;\n    float _maxLineSteps; //cap the line length to avoid process lock\n    float _lineOffset; //Alow you to shrink or extend the lines\n    float _lineInMultiplier,_lineOutMultiplier; //Control the brightness of the wires at the tips.\n    float2 _overscan; //This will allow you to render some extra outside the bounds of the image.\n\n  local: //Local variables\n    int max_line_connections;\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(Vformat,      \"vertexformat\", int2(10,10));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(_filtering, \"Filtering Method\", 1); \n    defineParam(_alphaMultiplier, \"_alphaMultiplier\", 1.0f);     \n    defineParam(_pointRender, \"_pointRender\", true);  \n    defineParam(_wireRender, \"_wireRender\", true);\n    defineParam(_facetRender, \"_facetRender\", true);\n    defineParam(_maxPlexDistance, \"_maxLDistance\", 1.0f);    \n    defineParam(_maxPlexConnections, \"_maxLConnections\", 1);    \n    defineParam(_maxPlexType, \"_maxPlexType\", 0); \n    defineParam(_plexLinedefXY, \"_plexLinedefXY\", false);      \n    defineParam(_plexLinedefXtoY, \"_plexLinedefXtoY\", false); //NYI\n    defineParam(_plexLinedefAUX, \"_plexLinedefAUX\", false); \n    defineParam(_plexLinedefX, \"_plexLinedefX\", false);  \n    defineParam(_plexLinedefY, \"_plexLinedefY\", false);  \n    defineParam(_plexConnectX, \"_plexConnectX\", false);      \n    defineParam(_plexConnectY, \"_plexConnectY\", false);   \n    defineParam(_plex_gamma, \"_L_gamma\", 1.0f);\n    //DOF SETTINGS   \n    defineParam(_dof_enable, \"Enable Depth of Field\", false);   \n    defineParam(_dof_samples, \"samples\", 3);    \n    defineParam(_dof_rings, \"rings\", 5);   \n    defineParam(focalDepth, \"focalDepth\", 1.0f);  \n    defineParam(_depthOfField, \"_depthOfField\", 4.0f);  \n    defineParam(_depthMult, \"_depthMult\", 0.1f);  \n    defineParam(_maxDofSize, \"_maxDofSize\", 8.0f);  \n    defineParam(dof_aspect, \"dof_aspect\", 1.0f);  \n    defineParam(dof_threshold, \"dof_threshold\", 1.0f);  \n    defineParam(dof_gain, \"dof_gain\", 0.0f);  \n    defineParam(dof_bias, \"dof_bias\", -2.0f);  \n    defineParam(dof_fringe, \"dof_fringe\", 0.0f); \n    //SHADING SETTINGS \n    defineParam(_flatshading, \"_flatshading\", true);  \n    defineParam(_vertexMode, \"_vertexMode\", 0);  \n    defineParam(_backfacing, \"_backfacing\", true);    \n    defineParam(_frontfacing, \"_frontfacing\", true);        \n    defineParam(_depthBuffer, \"_depthBuffer\", true);  \n    defineParam(_texoffset, \"_texoffset\", float2(0.5f,0.5f)); \n    defineParam(_pointSize, \"_pointSize\", 1); \n    defineParam(_gaussigma, \"_gaussigma\", 1.0f); \n    defineParam(_depthOcclusion, \"_depthOcclusion\", true); \n    defineParam(depthMultiplier, \"depthMultiplier\", 1.0f); \n    defineParam(_maxLineSteps, \"_maxLineSteps\", 4000.0f); \n    defineParam(_lineOffset, \"_lineOffset\", 1.0f); \n    defineParam(_lineInMultiplier, \"_lineInMultiplier\", 1.0f);   \n    defineParam(_lineOutMultiplier, \"_lineOutMultiplier\", 1.0f);     \n    defineParam(_overscan, \"_overscan\",float2(0.0f,0.0f));    \n\n  \}\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    max_line_connections = 80;\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n  \}\n\n  //Convert a 3d point position into a 2d raster position.\n  float3 Reconsile3D(float3 _PointPos)\{\n      vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      return tRaster;\n  \}\n\n//------------------------------\n//-------DRAW FUNCTIONS---------\n//------------------------------\n  //Write pixels to output.\n  void writepixel(float posx,float posy, float4 color,int index,float weight=1.0f)\n  \{ \n      if (_depthOcclusion)\{\n        float4 depthSample = occlusion(posx,posy);\n        if (depthSample.x<=vRaster.z && depthSample.w>0.0f)\{\n\n          float depth = (vRaster.z-depthSample.x);\n          color = color*(1.0f-depthSample.w);\n          color = color / (((depth*depth)*depthMultiplier)+1.0f);\n          //return;\n        \}\n      \}\n      float4 finalOutput; //This is used to store the final output\n      float4 dstSample; //This is used to store a sample of the destination\n      if ( dst.bounds.inside( posx, posy ) ) \{ //Test if the pixel written to is inside the output image. \n        if (_depthBuffer) \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          if ((dstSample.w>color.w)||dstSample.w==0.0f) \{\n            dst(posx,posy) = color;\n          \}\n        \}\n        else \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          finalOutput = dstSample + (color*_alphaMultiplier*weight);\n          finalOutput.w = dstSample.w + ((color.w*_alphaMultiplier*weight));\n\n          finalOutput.w = (dstSample.w + ((color.w*_alphaMultiplier*weight)))-(dstSample.w * ((color.w*_alphaMultiplier*weight)));\n\n          dst(posx,posy) = finalOutput;\n        \}\n      \} \n  \}\n\n  //Calculate a Bilinear Plot\n  void bilinear_Plot(float2 temppos,float4 color,int index)\n  \{\n    float2 p;\n    p.x=Frac(temppos.x);\n    p.y=Frac(temppos.y);\n    float weights\[] = \{(1.0f-p.x)*(1.0f-p.y), p.x*(1.0f-p.y), (1.0f-p.x)*p.y, p.x*p.y\};\n    int2 _position = int2(floor(temppos.x)-0,floor(temppos.y)-0); \n    writepixel(_position.x,_position.y,color,index,weights\[0]);\n    writepixel(_position.x+1,_position.y,color,index,weights\[1]);\n    writepixel(_position.x,_position.y+1,color,index,weights\[2]);\n    writepixel(_position.x+1,_position.y+1,color,index,weights\[3]);\n  \}\n\n  //NYI, unused!\n  void gaussian(float2 temppos,float4 color,int index)\{\n    float in_x = temppos.x;\n    float in_y = temppos.y;\n    int kernelSize = (_pointSize+1)*2;\n    int subsize = (kernelSize /2)-1;\n    float gKernel\[64]\[64];\n    float sigma = _gaussigma;\n    float intSigma = float(_pointSize);\n    float r, s = intSigma * sigma * sigma;\n\n    float sum = 0.0f;\n\n    // generate 5x5 kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            r = float(sqrt(x*x + y*y));\n            gKernel\[x + subsize]\[y + subsize] = (exp(-(r*r)/s))/(3.141592654f * s);\n            sum += gKernel\[x + subsize]\[y + subsize];\n        \}\n    \}\n\n    // normalize the Kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            gKernel\[x + subsize]\[y + subsize] /= sum;\n            writepixel(in_x+x,in_y+y,color,index,gKernel\[x + subsize]\[y + subsize]);\n        \}\n    \}\n  \}\n\n//-------------------------------------\n// DrawLine\n// ----------\n// Draw a line between two points, \n// x,y being 2d screenspace pos and z being depth.\n//-------------------------------------\n  void DrawLine(float3 origin, float3 endpoint,float4 _colorA,float4 _colorB) \{\n    float4 _color;\n    float3 delta = origin-endpoint;\n    float3 curPoint = origin;\n    float mag = sqrt(delta.x*delta.x+delta.y*delta.y);\n    mag = min(mag,_maxLineSteps); //Lets not go crazy, we cap it at 10.000 to avoid insane unwated processing time \n    for( float a = 0; a < mag*_lineOffset; a = a + 1.0f )\{\n      curPoint -= (delta/mag);\n      _color = (_colorA*(1.0f-(a/mag*1.0f)))+(_colorB*(a/mag*1.00f));\n      if (_dof_enable)\{\n        Bokeh(curPoint,_color);\n      \}\n      else \{\n        bilinear_Plot(float2(curPoint.x,curPoint.y),_color,1);\n      \}\n      \n    \}\n  \}\n\n//-------------------------------------\n// Point_Render\n//-------------------------------------\nvoid point_render(int2 pos, float3 screen_pos)\{\n  float4 color = src(pos.x,pos.y);\n\n  if (_filtering == 1)\{\n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        if (_depthBuffer) \{color.w = screen_pos.z;\} //Added\n        bilinear_Plot(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  /*\n  //THIS PART NEEDS TO BE RE-WRITTEN.\n  else if (_filtering == 2)\{ \n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        gaussian(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  */\n  else \{\n      int2 _position = int2(floor(screen_pos.x),floor(screen_pos.y)); \n      if (_depthBuffer) \{color.w = screen_pos.z;\}\n      writepixel(_position.x,_position.y, color,1,1.0f); //OutputSample\n  \}\n\n\}\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nvoid facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x+1,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos,V0_N,V1_N,V2_N;\n    float2 V0_ST,V1_ST,V2_ST;\n    float4 V1_Sample,V2_Sample;\n    float4 _tn;\n    float3 normal0,normal1,normal2;\n    float2 UV_Format = float2(Vformat.x,Vformat.y);\n\n\n    int2 P0 = int2(pos.x-1,pos.y-1);\n    int2 P1 = int2(pos.x+1,pos.y+1);\n    if (_plexConnectX && pos.x == int(Vformat.x))\{\n      insideX == true;\n      P1 = int2(0.0f,pos.y+1);\n    \}\n    if (_plexConnectY && pos.y == int(Vformat.y))\{\n      insideYtop == true;\n      P1 = int2(pos.x+1,0);\n    \} \n\n    if (_plexConnectY && pos.y == 0)\{\n      insideY == true;\n      P0 = int2(pos.x-1,int(UV_Format.y));\n    \} \n\n    if (!_flatshading) \{\n      _tn = normals(pos.x,pos.y);\n      V0_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n    V0_ST = float2(pos.x,pos.y)/UV_Format;\n\n  if (insideX) \{\n    V2_Sample = ppos(P1.x,pos.y);\n    V2_ST = float2(P1.x,pos.y)/UV_Format;\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (!_flatshading) \{\n      _tn = normals(P1.x,pos.y);\n      V2_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n        \n\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(P1.x,P0.y);\n        V1_ST = float2(P1.x,P0.y)/UV_Format;\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(P1.x,P0.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}\n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V2_Pos,V1_Pos,_vWorld,V2_wPos,V1_wPos,V0_N,V2_N,V1_N,V0_ST,V2_ST,V1_ST);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,P1.y);\n        V1_ST = float2(pos.x,P1.y)/UV_Format;        \n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(pos.x,P1.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}        \n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V1_Pos,V2_Pos,_vWorld,V1_wPos,V2_wPos,V0_N,V1_N,V2_N,V0_ST,V1_ST,V2_ST);\n        \}\n      \}\n    \}\n  \}\n\}\n\n\n\n//This function will calculate if pixel C is inside the triangle\nfloat edgeFunction(float3 a, float3 b, float3 c) \n\{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n\} \n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat Distance(float3 _a,float3 _b)\n\{\n          float xd = _a.x - _b.x;\n          float yd = _a.y - _b.y;\n          float zd = _a.z - _b.z;\n          return sqrt(xd*xd + yd*yd + zd*zd);\n\}\n\nvoid DrawTriangle(float3 V0, float3 V1, float3 V2,float3 WP0, float3 WP1, float3 WP2,float3 N0, float3 N1, float3 N2, float2 st0,float2 st1,float2 st2) \{\n\n  // Precompute reciprocal of vertex z-coordinate \n  V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n\n  float2 st0n = st0 * V0.z;\n  float2 st1n = st1 * V1.z; \n  float2 st2n = st2 * V2.z; //Normal version of ST\n\n  bool inside; \n  float X0 = Fmin(V0.x,V1.x,V2.x)-1.0f;\n  float X1 = Fmax(V0.x,V1.x,V2.x)+1.0f;\n  float Y0 = Fmin(V0.y,V1.y,V2.y)-1.0f;\n  float Y1 = Fmax(V0.y,V1.y,V2.y)+1.0f;\n  float area = edgeFunction(V2, V1, V0);\n\n\n  float2 sampos = float2(st0.x*float(Vformat.x),st0.y*float(Vformat.y));\n  float4 text0 = src(sampos.x,sampos.y);\n  sampos = float2(st1.x*float(Vformat.x),st1.y*float(Vformat.y));\n  float4 text1 = src(sampos.x,sampos.y);\n  sampos = float2(st2.x*float(Vformat.x),st2.y*float(Vformat.y));  //Why do we have to do this? =(\n  float4 text2 = src(sampos.x,sampos.y);\n  sampos = float2(min(min(st0.x,st1.x),st2.x)*float(Vformat.x),min(min(st0.y,st1.y),st2.y)*float(Vformat.y));\n  float4 text3 = src(sampos.x,sampos.y);\n\n\n  for( int x = X0; x < X1 ; x++) \{\n    for( int y = Y0; y < Y1 ; y++) \{\n      float3 pixelSample(x + _texoffset.x, y + _texoffset.y,0.0f); \n\n      //This is the part where we test if the current pixel is inside the triangle\n      //We check both for front facing and back faing options\n      float w0 = edgeFunction(V1, V0, pixelSample); //Front Facing\n      float w1 = edgeFunction(V2, V1, pixelSample); \n      float w2 = edgeFunction(V0, V2, pixelSample); \n      float w3 = edgeFunction(V0, V1, pixelSample); //Back Facing\n      float w4 = edgeFunction(V1, V2, pixelSample); \n      float w5 = edgeFunction(V2, V0, pixelSample);\n\n      //writepixel(x,y, float4(w1),1,1.0f);\n      if ((w0 >= 0 && w1 >= 0 && w2 >= 0 && _frontfacing) || (w3 >= 0 && w4 >= 0 && w5 >= 0 && _backfacing)) \{ //The curent pixel is inside the triangle\n\n       // calculate vectors from point f to vertices p1, p2 and p3:\n       float3 f1 = V0-pixelSample;\n       float3 f2 = V1-pixelSample;\n       float3 f3 = V2-pixelSample;\n       // calculate the areas and factors (order of parameters doesn't matter):\n       float a = length(cross(V0-V1,V0-V2 )); // main triangle area a\n       area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n        w0 /= area; \n        w1 /= area; \n        w2 /= area; \n\n        w3 /= area; \n        w4 /= area; \n        w5 /= area; \n\n       float a1 = length(cross(f2, f3)) / a; // p1's triangle area / a\n       float a2 = length(cross(f3, f1)) / a; // p2's triangle area / a \n       float a3 = length(cross(f1, f2)) / a; // p3's triangle area / a\n       float a_magnitude = a1+a2+a3;\n       a1 = a1/a_magnitude;\n       a2 = a2/a_magnitude;\n       a3 = a3/a_magnitude;\n       float z = 1.0f / (V0.z * a1 + V1.z * a2 + V2.z * a3); \n\n\n        // find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):\n        float2 uv = st0 * a1 + st1 * a2 + st2 * a3;\n        float2 st = st0 * w0 + st1 * w1 + st2 * w2; \n        st *= z;      \n\n\n        //Calculate normals. Eighter we have flat shading, else we calculate a normal per pixel\n        float3 normalB;\n        if (_flatshading) \{\n          normalB = CalculateSurfaceNormals(WP0,WP1,WP2);\n\n        \}\n        else \{\n          float3 c0 = N2/float3(V0.z); \n          float3 c1 = N0/float3(V1.z); \n          float3 c2 = N1/float3(V2.z);  \n\n          normalB.x = w0 * c0.x + w1 * c1.x + w2 * c2.x; \n          normalB.y = w0 * c0.y + w1 * c1.y + w2 * c2.y; \n          normalB.z = w0 * c0.z + w1 * c1.z + w2 * c2.z; \n\n          normalB.x *= z, normalB.y *= z, normalB.z *= z; \n        \}\n        normalB = normalize(normalB);\n\n        //CALCULATE THE OBJECT TEXTURE COORDINATES\n        float zn = 1.0f / (V0.z * w0 + V1.z * w1 + V2.z * w2); \n        st = st0n * w0 + st1n * w1 + st2n * w2; \n        st *= zn;   \n        //--END \n\n        float3 Wpos = WP0*a1 + WP1*a2 + WP2*a3; //World Position.\n        float3 ViewNormal = normalize(float3(cameraToWorld\[3]\[0],cameraToWorld\[3]\[1],cameraToWorld\[3]\[2])-Wpos);\n\n        float nDotView =  dot(normalB,ViewNormal);\n        nDotView = 1.0f-fabs(nDotView); //make sure that the view normal ramps back around when doing backface\n        float4 tempout;\n\n        //Flatshading or regular?\n        if (!_flatshading) \{\n          tempout = text0 * a1 + text1 * a2 + text2 * a3; \n        \}\n        else\{\n          tempout = text3;\n        \}\n\n        //Additional Render Modes\n        if (_vertexMode == 1)\{\n          tempout = float4(a1,a2,a3,1.0f);\n        \}\n        else if (_vertexMode == 2)\{\n          tempout = float4(normalB.x,normalB.y,normalB.z,1.0f);\n        \}\n        else if (_vertexMode == 3)\{\n          tempout = float4(nDotView,nDotView,nDotView,1.0f);\n        \}\n        else if (_vertexMode == 4)\{\n          tempout = float4(uv.x,uv.y,0.0f,1.0f);\n        \}       \n        else if (_vertexMode == 5)\{\n          tempout = float4(st.x,st.y,0.0f,1.0f);\n        \}               \n        else if (_vertexMode == 6)\{\n          tempout = float4(ViewNormal.x,ViewNormal.y,ViewNormal.z,1.0f);\n        \}             \n        else if (_vertexMode == 7)\{\n          tempout = float4(Wpos.x,Wpos.y,Wpos.z,1.0f);\n        \}   \n\n        if (_depthBuffer)\{\n          writepixel(x,y, float4(tempout.x,tempout.y,tempout.z,z),1,1.0f);  \n        \}\n        else \{\n          if (_dof_enable)\{\n            Bokeh(float3(x,y,z),float4(tempout.x,tempout.y,tempout.z,z));\n          \}\n          else \{\n            bilinear_Plot(float2(x,y),float4(tempout.x,tempout.y,tempout.z,z),1);\n          \}\n        \}\n\n      \}  \n\n    \}\n  \}\n\}\n\n//-------------------------------------\n// Wire_Render\n//-------------------------------------\nvoid wire_render(int2 pos) \{\n  float4 temp = float4(0.0f,0.0f,0.0f,FLT_MAX);\n  float4 wire_ref_sample;\n  int2 tempXY = int2(0,0);\n  float4 plexlist\[11] = \{temp,temp,temp,temp,temp,temp,temp,temp,temp,temp,temp\}; \n  int2 plexlistXY\[11] = \{tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY\};\n  int plex_count = 0; //We use this to figure how many points that should connect.\n  float plex_dist;\n  float3 plex_position,plex_position_b;\n  float4 temp_pos, temp_pos_b; //Temporary Position Containers\n  if (_maxPlexType == -1) \{ //Used for random connection types\n    for( int x = 0; x < max_line_connections ; x++)\{ //THIS 80 NUMBER IS THE LIMIT TO AVOID TOO SLOW PROCESSING!\n      for( int y = 0; y < max_line_connections ; y++)\{\n        wire_ref_sample = ppos(x,y);\n        if (wire_ref_sample.w != 0.0f && pos.x!=x && pos.y != y) \{ \n          plex_position = float3(wire_ref_sample.x,wire_ref_sample.y,wire_ref_sample.z)*(zoom);\n          float xd = plex_position.x - vWorld.x;\n          float yd = plex_position.y - vWorld.y;\n          float zd = plex_position.z - vWorld.z;\n          float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n          if (plex_dist<_maxPlexDistance)\{\n            plex_count = min(10,plex_count+1); //Add one to the count\n            for( int h = 0; h < plex_count+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n              if (plex_dist < plexlist\[h].w) \{                  \n                for( int i = plex_count+1; i > h ; i--) \{\n                  plexlist\[i] = plexlist\[i-1];\n                  plexlistXY\[i] = plexlistXY\[i-1];\n                \}\n                plexlist\[h] = float4(plex_position.x,plex_position.y,plex_position.z,plex_dist);\n                plexlistXY\[h] = int2(x,y);\n                break;        \n              \}\n            \}\n          \} \n        \}\n      \}\n    \}\n  \}\n  else\{ //Used for standard connection types\n    float4 temp_pos;\n    bool insideX = !(Vformat.x < pos.x+1);\n    bool insideY = !(Vformat.y < pos.y+1);\n\n\n    if (!_plexLinedefAUX)\{\n      temp_pos = normals(pos.x,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,vWorld+plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideX && !_plexLinedefX) \{\n      temp_pos = ppos(pos.x+1,pos.y );\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && !_plexLinedefX) \{\n      temp_pos = ppos(0,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideY && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\}                          \n    \}\n    else if ( _plexConnectY  && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,0);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    //_plexConnect\n    if ( insideX && insideY && !_plexLinedefXY) \{              \n      temp_pos = ppos(pos.x+1,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && _plexConnectY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && insideY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectY && insideX && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n  \}   \n\n  //now that all the connections have been sorted by distance then we connect the dots.\n  for( int x = 0; x < min(_maxPlexConnections,plex_count) ; x++)\{\n    plex_position = float3(plexlist\[x].x,plexlist\[x].y,plexlist\[x].z);\n    plex_dist = plexlist\[x].w;\n\n\n    float plex_distribution = 1.0f-((plexlist\[x].w-plexlist\[0].w)/((plexlist\[min(_maxPlexConnections,plex_count)].w-plexlist\[0].w)+0.00001f)); //Where does it lie between the best and the worst distance?\n    //plexlistXY\n\n    float4 plex_col = float4(pow(1.0f-(plex_dist/_maxPlexDistance),1.0f/_plex_gamma))*float4(plex_distribution); //This one is quite cool aswell, but does leave the center ones a bit too focused \n    float4 plex_colorA = src(pos.x,pos.y);\n    float4 plex_colorB = src( plexlistXY\[x].x,plexlistXY\[x].y);\n    plex_col *= 0.1f;\n\n    computePixelCoordinates(plex_position, pRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n    if (dst.bounds.inside(int(vRaster.x),int(vRaster.y)) || dst.bounds.inside(int(pRaster.x),int(pRaster.y)))\{\n        DrawLine(vRaster,pRaster,(plex_colorA*plex_col)*_lineInMultiplier,(plex_colorB*plex_col)*_lineOutMultiplier);\n    \}\n  \}\n\}\n\nvoid wire_connection(float3 p_source,float3 p_target, float4 (&p_plexlist)\[11], int2 (&p_plexlistXY)\[11],int &p_plexcount,int2 position) \{\n  float xd = p_target.x - p_source.x;\n  float yd = p_target.y - p_source.y;\n  float zd = p_target.z - p_source.z;\n  float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n  if (plex_dist<_maxPlexDistance)\{\n    p_plexcount = min(11,p_plexcount+1); //Add one to the count\n    for( int h = 0; h < p_plexcount+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n      if (plex_dist < p_plexlist\[h].w) \{                  \n        for( int i = p_plexcount+1; i > h ; i--) \{\n          p_plexlist\[i] = p_plexlist\[i-1];\n          p_plexlistXY\[i] = p_plexlistXY\[i-1];\n        \}\n        p_plexlist\[h] = float4(p_target.x,p_target.y,p_target.z,plex_dist);\n        p_plexlistXY\[h] = int2(position.x,position.y);\n        break;        \n      \}\n    \}  \n  \}\n\}\n//-------END OF WIRE RENDER FUNCTIONS---------\n\n\n\n\n//-------------------------------\n//-------BOKEH FUNCTIONS---------\n//thanks to: http://devlog-martinsh.blogspot.dk/2011/11/glsl-depth-of-field-with-bokeh-v21.html\nfloat2 rand(float2 coord) //generating noise/pattern texture for dithering\n\{\n  float noiseX = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.25)+(Frac(coord.y*(WHformat\[1]/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.75)+(Frac(coord.y*(WHformat\[1]/2.0))*0.25))*2.0-1.0;\n  noiseX = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f))) * 43758.5453f),0.0f,1.0f)*2.0f-1.0f;\n  noiseY = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f)*2.0f)) * 43758.5453f),0.0f,1.0f)*2.0-1.0f;\n  return float2(noiseX,noiseY);\n\}\n//-------------------------------------\n// Bokeh\n//-------------------------------------\nvoid Bokeh(float3 pos,float4 color)\{\n  float blur = 0.0;\n  blur = clamp((fabs(pos.z - focalDepth)/_depthOfField)*100.0f,-_maxDofSize,_maxDofSize);\n  \n  float w = (1.0/WHformat.x)*blur;//+noise.x;\n  float h = (1.0/(WHformat.x*dof_aspect))*blur;//+noise.y;\n  float3 v3_col = float3(color.x,color.y,color.z);\n  int ringsamples;\n  float s = 1.0;  \n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples; \n    for (int j = 0 ; j < ringsamples ; j += 1)  \n    \{ \n      s += (1.0f*mix(1.0f,(float(i))/(float(_dof_rings)),dof_bias)*1.0f); //No need to do this in the loop\n    \}\n  \}\n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples;\n     \n    for (int j = 0 ; j < ringsamples ; j += 1)   \n    \{\n      float step = PI*2.0 / float(ringsamples);\n      float pw = (cos(float(j)*step)*(float(i)/_dof_rings));\n      float ph = (sin(float(j)*step)*(float(i)/_dof_rings));\n      float p = 1.0;\n\n      float posx = pos.x+((pw*w)*blur);\n      float posy = pos.y+((ph*h)*blur);\n\n\n      float3 lumcoeff = float3(0.299,0.587,0.114);\n      float lum = dot(v3_col, lumcoeff);\n      float thresh = max((lum-dof_threshold)*dof_gain, 0.0f);\n      v3_col+mix(float3(0.0),v3_col,thresh*blur);\n\n      float3 col = (v3_col*mix(1.0,(float(i))/(float(_dof_rings)),dof_bias)*p)/s; \n      bilinear_Plot(float2(posx,posy),float4(col.x,col.y,col.z,color.w/(_dof_rings*_dof_rings)),1);\n    \}\n  \}\n\}\n//-------END OF BOKEH FUNCTIONS---------\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float2 posf = float2(pos.x,pos.y);\n\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n\n      //Convert worldspace coordinates to screenspcace coordinates.\n      vWorld = float3(_sample.x,_sample.y,_sample.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, vRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      if (ret) \{ //Only create points that are visible on screen\n        if (_pointRender)\{\n          point_render(pos,vRaster);\n        \}\n      \} //Pointrender over\n\n      if (_wireRender && _maxPlexConnections>=1) \{\n        if (max(pos.x,pos.y)<=max_line_connections || (_maxPlexType==0))\{ // Don't process more wires than allowed in nearest mode.\n          wire_render(pos);\n        \}\n      \} //WireRender over\n\n      if (_facetRender) \{\n        facet_render(pos,float3(_sample.x,_sample.y,_sample.z));\n      \}  //FacetRender over\n      \n    \}\n  \} //----> process\n\};\n"
  useGPUIfAvailable false
  rebuild ""
  PointRender3D_cam_Matrix {
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
    }
  PointRender3D_focallength {{parent.Camera1.focal}}
  PointRender3D_hapeture {{parent.Camera1.haperture}}
  PointRender3D_format {{!proxy?Settings_Format.width:Settings_Format.width*proxy_scale} {!proxy?Settings_Format.height:Settings_Format.height*proxy_scale}}
  PointRender3D_vertexformat {{parent.InputFormat.box.r-1} {parent.InputFormat.box.t-1}}
  PointRender3D__alphaMultiplier {{parent.AlphaMultiplier}}
  PointRender3D__pointRender {{parent.RenderMode==0}}
  PointRender3D__wireRender {{parent.RenderMode==1}}
  PointRender3D__facetRender {{parent.RenderMode==2}}
  PointRender3D__maxLDistance {{parent.wire_maxdistance}}
  PointRender3D__maxLConnections {{parent.wire_connections}}
  PointRender3D__maxPlexType {{-parent.wire_type}}
  PointRender3D__plexLinedefXY {{!parent.connect_xy}}
  PointRender3D__plexLinedefX {{!parent.connect_x}}
  PointRender3D__plexLinedefY {{!parent.connect_y}}
  PointRender3D__plexLinedefAUX {{!connect_aux}}
  PointRender3D__plexConnectX {{parent.CloseX}}
  PointRender3D__plexConnectY {{parent.CloseY}}
  PointRender3D__L_gamma {{parent.wire_Threshold}}
  "PointRender3D_Enable Depth of Field" {{parent.dof_enable}}
  PointRender3D_samples {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_rings {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_focalDepth {{parent.dof_focaldepth}}
  PointRender3D__depthOfField {{parent.dof_dof}}
  PointRender3D__depthMult 0
  PointRender3D__maxDofSize {{parent.dof_maxSize*400}}
  PointRender3D_dof_aspect {{parent.dof_Aspect}}
  PointRender3D_dof_bias {{parent.dof_bias}}
  PointRender3D__flatshading {{parent.facet_flatShading}}
  PointRender3D__backfacing {{parent.facet_backface}}
  PointRender3D__frontfacing {{parent.facet_front}}
  PointRender3D__vertexMode {{parent.renderMode}}
  PointRender3D__depthBuffer {{parent.facet_depth}}
  PointRender3D__texoffset {-0.5 0.5}
  PointRender3D__pointSize 0
  PointRender3D__depthOcclusion {{parent.UseOcclusionMap}}
  PointRender3D__maxLineSteps {{parent.maxSamples}}
  PointRender3D__lineOffset {{parent.lineoffset}}
  PointRender3D__lineInMultiplier {{parent.inGain}}
  PointRender3D__lineOutMultiplier {{parent.outGain}}
  PointRender3D__overscan {{parent.overscan} {parent.overscan}}
  format "1280 720 0 0 1280 720 1 HD_720"
  rebuild_finalise ""
  name BlinkScript1
  xpos -27
  ypos 159
 }
set N1e52c7a0 [stack 0]
 TimeBlur {
  divisions {{parent.Samples}}
  shutter {{parent.Shutter}}
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur
  xpos -27
  ypos 301
  disable {{1-parent.mb_enable x89 0}}
 }
 ShuffleCopy {
  inputs 2
  alpha alpha2
  black alpha
  out2 depth
  name ShuffleCopy2
  xpos -27
  ypos 411
  disable {{!parent.OutputZdepth}}
 }
 CopyBBox {
  inputs 2
  name CopyBBox1
  xpos -27
  ypos 521
 }
 Reformat {
  format {{{Settings_Format.format}}}
  resize none
  center false
  pbb {{max(parent.overscan.w,parent.overscan.h)!=0}}
  name Reformat1
  xpos -27
  ypos 545
 }
 Group {
  name SoftLook
  xpos -27
  ypos 647
  disable {{!parent.HighlightCompression}}
  addUserKnob {20 User}
  addUserKnob {26 ""}
  addUserKnob {7 Add R 0 4}
  Add {{parent.HighlightCeiling}}
  addUserKnob {7 Offset R 0 4}
  Offset {{parent.Compression}}
 }
  Input {
   inputs 0
   name Input1
   xpos -248
   ypos 500
  }
set N1e5c8680 [stack 0]
  Expression {
   expr0 r/(r+parent.Offset)*parent.Add
   expr1 g/(g+parent.Offset)*parent.Add
   expr2 b/(b+parent.Offset)*parent.Add
   expr3 a/(a+parent.Offset)*parent.Add
   name Expression1
   xpos -339
   ypos 576
  }
push $N1e5c8680
  ShuffleCopy {
   inputs 2
   red red
   green green
   blue blue
   alpha alpha2
   name ShuffleCopy1
   xpos -248
   ypos 576
  }
  Output {
   name Output1
   xpos -248
   ypos 651
  }
 end_group
 ShuffleCopy {
  inputs 2
  in pos
  red red
  green green
  blue blue
  out pos
  name ShuffleCopy1
  xpos -27
  ypos 860
  disable true
 }
 Output {
  name Output1
  xpos -27
  ypos 897
 }
push $N1e4742d0
 PositionToPoints2 {
  display textured
  render_mode textured
  P_channel pos
  detail 0.25
  pointSize 0.6
  name PreviewNode
  xpos -22
  ypos 8
  disable {{!parent.Enable3DPreview}}
 }
push $N1e2a9ea0
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize none
  filter Impulse
  black_outside true
  name Reformat3
  xpos -633
  ypos -1109
  disable {{!wire_type==1}}
 }
push $N1e2ee4e0
push $N1e30e360
push $N1e312ec0
 Merge2 {
  inputs 2
  operation min
  Achannels {-pos.red -pos.green -pos.blue pos.alpha}
  Bchannels {-pos.red -pos.green -pos.blue pos.alpha}
  output {-pos.red -pos.green -pos.blue pos.alpha}
  name Merge4
  xpos -582
  ypos -634
 }
 Merge2 {
  inputs 2
  operation min
  Achannels {-pos.red -pos.green -pos.blue pos.alpha}
  Bchannels {-pos.red -pos.green -pos.blue pos.alpha}
  output {-pos.red -pos.green -pos.blue pos.alpha}
  name Merge5
  xpos -582
  ypos -602
 }
push $N1e326270
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -456
  ypos -402
 }
push $N1e52c7a0
 Viewer {
  frame 36
  frame_range 1-100
  name Viewer1
  xpos -27
  ypos 325
 }
 Input {
  inputs 0
  name InputCamera
  xpos -1271
  ypos 89
  number 1
 }
 Camera {
  useMatrix true
  matrix {
      {1 0 0 0}
      {0 {1/Settings_Format.actual_format.pixel_aspect} 0 0}
      {0 0 1 0}
      {0 0 0 1}
    }
  projection_mode {{"\[value the_cam]projection_mode"}}
  focal {{"\[value \[value the_cam]focal]"}}
  haperture {{"\[value \[value the_cam]haperture]"}}
  vaperture {{"\[value \[value the_cam]vaperture]"}}
  near {{"\[value \[value the_cam]near]"}}
  far {{"\[value \[value the_cam]far]"}}
  win_translate {{"\[lindex \[value \[value the_cam]win_translate] 0]"} {"\[lindex \[value \[value the_cam]win_translate] 1]"}}
  win_scale {{"\[lindex \[value \[value the_cam]win_scale] 0]"} {"\[lindex \[value \[value the_cam]win_scale] 1]"}}
  winroll {{"\[value \[value the_cam]winroll]"}}
  focal_point {{"\[value \[value the_cam]focal_point]"}}
  fstop {{"\[value \[value the_cam]fstop]"}}
  name Camera1
  help "DummyCam by Adrian Pueyo\n\nCamera that apart from the matrices also grabs all the \"Projection\" values from the upstream camera that it's connected to. Turns into a default Camera if not Camera connected.\n\nCan also be used inside of groups and gizmos, as many levels deep as you want :D\n\nAll using live and super fast TCL.\n\nadrianpueyo.com, 2019"
  onCreate "n = nuke.thisNode()\nfor k in \[\"projection_mode\",\"focal\",\"haperture\",\"vaperture\",\"near\",\"far\",\"win_translate\",\"win_scale\",\"winroll\",\"focal_point\",\"fstop\"]:\n    n\[k].setFlag(0x0000000010000000)"
  label "(thanks to Adrian Pueyo and Ernest Dios)"
  xpos -1261
  ypos 198
  addUserKnob {20 DummyCam l Defaults}
  addUserKnob {43 the_cam +INVISIBLE}
  the_cam "\[\nset the_knob \"focal\"\nset knob_index 0\nset starting_point \"this.input0\"\nset default \"this\"\nset default \[append default \".d_\"]\n\n# If cam has no inputs, return the default...\nif \{\[exists \$starting_point]\} \{\n    set x \[node \$starting_point]\n\} \{ \n    return \$default\n\}\n\nset finished 0\nwhile \{\$finished != 1\} \{\n\n    # First look for a Cam or Input or topnode.\n    while \{\[class \$x] != \"Camera2\" && \[class \$x] != \"Camera\" && \[class \$x] != \"Input\" && \$x != \[topnode \$x]\} \{\n        set x \[node \$x.input0]\n    \}\n\n    # Then, check if node is a cam (and return), and otherwise, if it's an input, see if the parent exists and move to it.\n    if \{\[class \$x]==\"Camera2\"||\[class \$x]==\"Camera\"\} \{\n        set x \[append x \".\"]\n        return \$x\n    \} \{ \n        if \{\[class \$x]==\"Input\"\} \{ \n            set inp \"\$x.parent.input\"\n            set inputNum \[value \$x.number]\n            set inp \[append inp \$inputNum]\n            if \{\[exists \$inp]\} \{\n                set x \[node \$inp]\n            \} \{ \n                set finished 1\n            \}\n        \} \{ \n            set finished 1\n        \}\n    \}\n\}\nreturn \$default\n]"
  addUserKnob {4 d_projection_mode l projection M {perspective orthographic uv spherical ""}}
  addUserKnob {7 d_focal l focal R 0 100}
  d_focal 50
  addUserKnob {7 d_haperture l "horiz aperture" R 0 50}
  d_haperture 24.576
  addUserKnob {7 d_vaperture l "vert aperture" R 0 50}
  d_vaperture 18.672
  addUserKnob {7 d_near l near R 0 10}
  d_near 0.1
  addUserKnob {7 d_far l far R 0 10000}
  d_far 10000
  addUserKnob {12 d_win_translate l "window translate"}
  addUserKnob {12 d_win_scale l "window scale"}
  d_win_scale {1 1}
  addUserKnob {7 d_winroll l "window roll" R 0 45}
  addUserKnob {7 d_focal_point l "focal distance" R 0 10}
  d_focal_point 2
  addUserKnob {7 d_fstop l fstop R 0 30}
  d_fstop 16
  addUserKnob {26 text l " " T "<span style=\"color:#666\"><br/><b>DummyCam v1.0</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2019</span>"}
 }
end_group
FrameRange {
 first_frame -1000
 last_frame 2000
 time ""
 name FrameRange14
 xpos 2574
 ypos 2074
}
Retime {
 input.first -1000
 input.first_lock true
 input.last 2000
 input.last_lock true
 output.first 1000
 output.first_lock true
 output.last 1020
 output.last_lock true
 speed 142.9047619
 before continue
 after continue
 filter none
 time ""
 name Retime3
 xpos 2574
 ypos 2098
}
FrameRange {
 first_frame 1000
 last_frame 1020
 time ""
 name FrameRange15
 xpos 2574
 ypos 2122
}
StickyNote {
 inputs 0
 name StickyNote4
 label "this setup allows you to quickly generate patterns \nbased on different shapes of bokeh (like hexagons, \ncircles, triangles and many, many others) "
 note_font_size 40
 xpos -2297
 ypos -2837
}
StickyNote {
 inputs 0
 name StickyNote7
 label "examples of manipulation of position point cloud's \nshape by converting it from / to different color spaces"
 note_font_size 40
 xpos 550
 ypos 1084
}
StickyNote {
 inputs 0
 name StickyNote1
 label "Following presentation of my script's structure \nwith so-called \"TECHNICAL HIGHWAY\", I finisheda \ncode snippet for linking a StickynNte with a Backdrop. \nThat allows to easily catch that big element from a \ndistance (from great zoom out) and resize a backdrop"
 note_font_size 70
 xpos -2387
 ypos -8765
}
StickyNote {
 inputs 0
 name BDcorner_2
 knobChanged "\nif nuke.thisKnob().name() in ('xpos','ypos'):\n    bd = nuke.toNode('BDx_' + nuke.thisNode()\['name'].getValue().split('_')\[1])\n    bd\['bdwidth'].setValue(abs(bd.xpos() - nuke.thisNode().xpos() - 200))   \n    bd\['bdheight'].setValue(abs(bd.ypos() - nuke.thisNode().ypos() - 200)) \n"
 label <
 note_font Webdings
 note_font_size 400
 xpos -1550
 ypos -7374
 addUserKnob {20 User}
 addUserKnob {3 p +INVISIBLE}
 p {{"\[python -exec \{\n\nnuke.thisNode().knob('knobChanged').setValue(\"\"\"\nif nuke.thisKnob().name() in ('xpos','ypos'):\n    bd = nuke.toNode('BDx_' + nuke.thisNode()\['name'].getValue().split('_')\[1])\n    bd\['bdwidth'].setValue(abs(bd.xpos() - nuke.thisNode().xpos() - 200))   \n    bd\['bdheight'].setValue(abs(bd.ypos() - nuke.thisNode().ypos() - 200)) \n\"\"\")\n\}]\n"}}
}
push $N1d048e50
push $N1d213ae0
Dot {
 name Dot52
 label "upades 3d view in LIVE \nmode (while playing)"
 note_font_size 21
 xpos 765
 ypos 2025
}
PositionToPoints2 {
 display textured
 render_mode textured
 P_channel pos
 detail 1
 pointSize 1
 name PositionToPoints3
 xpos 737
 ypos 2153
}
Constant {
 inputs 0
 channels rgb
 format "1920 1080 0 0 1920 1080 1 HD_1080"
 name Constant1
 xpos 853
 ypos 2194
}
ScanlineRender {
 inputs 3
 conservative_shader_sampling false
 overscan 150
 samples 10
 shutteroffset centred
 motion_vectors_type distance
 name ScanlineRender4
 xpos 737
 ypos 2218
}
RotoPaint {
 inputs 0
 cliptype none
 curves {{{v x3f99999a}
  {f 0}
  {n
   {layer Root
    {f 2097152}
    {t x433c0000 x43c70000}
    {a pt1x 0 pt1y 0 pt2x 0 pt2y 0 pt3x 0 pt3y 0 pt4x 0 pt4y 0 ptex00 0 ptex01 0 ptex02 0 ptex03 0 ptex10 0 ptex11 0 ptex12 0 ptex13 0 ptex20 0 ptex21 0 ptex22 0 ptex23 0 ptex30 0 ptex31 0 ptex32 0 ptex33 0 ptof1x 0 ptof1y 0 ptof2x 0 ptof2y 0 ptof3x 0 ptof3y 0 ptof4x 0 ptof4y 0 pterr 0 ptrefset 0 ptmot x40800000 ptref 0}
    {curvegroup Rectangle1 512 bezier
     {{cc
       {f 8192}
       {px x447e4000
        {0 xc3701706}
        {x4387e002 x444210a4}
        {xc204aaac 0}
        {x4204aaac 0}
        {x432c4002 x444210a4}
        {0 xc3701706}
        {0 x4370170c}
        {x432c4002 x425ff5c9}
        {x4204aaac 0}
        {xc204aaac 0}
        {x4387e002 x425ff5c9}
        {0 x4370170c}}}     idem}
     {tx x447e4000 x435f4000 x43bda000}
     {a osw x41200000 osf 0 str 1 spx x433c0000 spy x43c70000 sb 1 ltn x447e4000 ltm x447e4000 tt x41000000}}}}}}
 toolbox {selectAll {
  { selectAll str 1 ssx 1 ssy 1 sf 1 }
  { createBezier str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createBezierCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createBSpline str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createEllipse str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createRectangle str 1 ssx 1 ssy 1 sf 1 sb 1 tt 8 }
  { createRectangleCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { brush str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { eraser src 2 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { clone src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { reveal src 3 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { dodge src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { burn src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { blur src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { sharpen src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { smear src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
} }
 toolbar_brush_hardness 0.200000003
 toolbar_source_transform_scale {1 1}
 toolbar_source_transform_center {188 398}
 colorOverlay {0 0 0 0}
 lifetime_type "all frames"
 lifetime_start 1017
 lifetime_end 1017
 motionblur_shutter_offset_type centred
 source_black_outside true
 name RotoPaint3
 xpos -841
 ypos -7835
}
EdgeDetectWrapper {
 name EdgeDetect5
 xpos -841
 ypos -7811
}
Read {
 inputs 0
 file_type png
 file /jobs/TRAINVFX/REF/montreal/general_reference/data/2021/Elements/script_structure_example.png
 localizationPolicy off
 format "376 796 0 0 376 796 1 "
 proxy_format "640 480 0 0 640 480 1 "
 origset true
 version 2
 name Read2
 xpos -937
 ypos -7964
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 _ivyFile "no results were found for query (Leaf) (WHERE Leaf.job = 'TRAINVFX' AND Leaf.location = '/jobs/TRAINVFX/REF/montreal/general_reference/data/2021/Elements/script_structure_example.png' AND Leaf.deleted = '0000-00-00 00:00:00' AND Leaf.archived = '0000-00-00 00:00:00' AND Leaf.provisional = '0')"
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 addUserKnob {1 leaf_label l Leaf}
 addUserKnob {1 ivy_version l Version}
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
Grade {
 inputs 1+1
 black {10 0 0 0}
 name Grade2
 xpos -937
 ypos -7805
}
Text {
 message "technical highway"
 font /usr/share/fonts/msttcore/trebuc.ttf
 size 41
 kerning 0.2
 yjustify top
 Transform 1
 box {-30.5575 481.67 567.5575 558.33}
 translate {254 -5.5}
 rotate 90
 center {188 398}
 name Text3
 xpos -937
 ypos -7739
 addUserKnob {20 dneg l DNeg}
 addUserKnob {26 _version l "" +STARTLINE +INVISIBLE T 1.0}
 addUserKnob {7 padding l "padding %" R 0 20}
 padding 4
 addUserKnob {15 orig_box +HIDDEN}
 orig_box {-45.5975 449.83 582.5975 590.17}
}
Text {
 message "beauty stream"
 font /usr/share/fonts/msttcore/trebuc.ttf
 size 41
 kerning 0.2
 yjustify top
 Transform 1
 box {-30.5575 481.67 567.5575 558.33}
 rotate 90
 center {188 398}
 name Text2
 xpos -937
 ypos -7691
 addUserKnob {20 dneg l DNeg}
 addUserKnob {26 _version l "" +STARTLINE +INVISIBLE T 1.0}
 addUserKnob {7 padding l "padding %" R 0 20}
 padding 4
 addUserKnob {15 orig_box +HIDDEN}
 orig_box {-45.5975 449.83 582.5975 590.17}
}
push $Nc031ec0
FrameHold {
 first_frame 1051
 name FrameHold7
 xpos -2160
 ypos -5898
 addUserKnob {20 dneg l DNeg}
 addUserKnob {26 _version l "" +STARTLINE +INVISIBLE T 1.1}
 addUserKnob {22 documentation l Documentation -STARTLINE T nukescripts.start('http://dnet/x/PwBDBg')}
 addUserKnob {26 ""}
}
Write {
 channels rgba
 name Write2
 xpos -2160
 ypos -5862
 addUserKnob {20 caravr l CaraVR}
 addUserKnob {4 viewPresets l "View Presets" M {main stereo cams "stereo cams" all}}
 addUserKnob {22 set l Set -STARTLINE T "w = nuke.thisNode()\nscriptViews = nuke.views()\nviewPreset = w\['viewPresets'].getValue()\nselectedViews = None\nif viewPreset == 0:\n  selectedViews = \['main']\nif viewPreset == 1:\n  stereoViews = \['left', 'right']\n  if set(stereoViews).issubset(set(scriptViews)):\n    selectedViews = stereoViews\n  else:\n    selectedViews = None\nelif viewPreset == 2:\n  selectedViews = \[v for v in scriptViews if 'cam' in v and not ('_left' in v or '_right' in v)]\nelif viewPreset == 3:\n  selectedViews = \[v for v in scriptViews if 'cam' in v and ('_left' in v or '_right' in v)]\nelif viewPreset == 4:\n  selectedViews = scriptViews\nif selectedViews:\n  w\['views'].fromScript(' '.join(selectedViews))\n"}
}
push $N17cc6b60
FrameHold {
 first_frame 1051
 name FrameHold6
 xpos -1695
 ypos -5902
 addUserKnob {20 dneg l DNeg}
 addUserKnob {26 _version l "" +STARTLINE +INVISIBLE T 1.1}
 addUserKnob {22 documentation l Documentation -STARTLINE T nukescripts.start('http://dnet/x/PwBDBg')}
 addUserKnob {26 ""}
}
Write {
 channels rgba
 in_colorspace linear
 out_colorspace linear
 name Write3
 xpos -1695
 ypos -5866
 addUserKnob {20 caravr l CaraVR}
 addUserKnob {4 viewPresets l "View Presets" M {main stereo cams "stereo cams" all}}
 addUserKnob {22 set l Set -STARTLINE T "w = nuke.thisNode()\nscriptViews = nuke.views()\nviewPreset = w\['viewPresets'].getValue()\nselectedViews = None\nif viewPreset == 0:\n  selectedViews = \['main']\nif viewPreset == 1:\n  stereoViews = \['left', 'right']\n  if set(stereoViews).issubset(set(scriptViews)):\n    selectedViews = stereoViews\n  else:\n    selectedViews = None\nelif viewPreset == 2:\n  selectedViews = \[v for v in scriptViews if 'cam' in v and not ('_left' in v or '_right' in v)]\nelif viewPreset == 3:\n  selectedViews = \[v for v in scriptViews if 'cam' in v and ('_left' in v or '_right' in v)]\nelif viewPreset == 4:\n  selectedViews = scriptViews\nif selectedViews:\n  w\['views'].fromScript(' '.join(selectedViews))\n"}
}
Grid {
 inputs 0
 number {0 {"height / (width / Grid12.number.0 / 0.576441) "}}
 size {{parent.Grid12.size}}
 name Grid10
 xpos 3968
 ypos -1636
}
Grade {
 channels alpha
 white 1000000
 white_clamp true
 name Grade23
 xpos 3968
 ypos -1604
}
CropPadded {
 inputs 0
 name CropPadded4
 xpos 4093
 ypos -1899
 box {0 0 2224 1548}
 padding 100
 intersect false
}
Expression {
 expr3 0
 name Expression4
 xpos 4093
 ypos -1875
}
set N1e86be80 [stack 0]
Grid {
 number {0 {"height / (width / Grid12.number.0 / (23/39.9) / 2 ) "}}
 size {{parent.Grid12.size}}
 name Grid11
 xpos 4149
 ypos -1807
}
push $N1e86be80
Grid {
 number {20 0}
 size 1.01
 name Grid12
 xpos 4013
 ypos -1812
}
ChannelMerge {
 inputs 2
 operation multiply
 name ChannelMerge7
 xpos 4093
 ypos -1733
}
Shuffle {
 in alpha
 name Shuffle19
 xpos 4093
 ypos -1685
}
TransformMasked {
 inputs 1+1
 translate {{"width / Grid12.number.0 / 2"} 0}
 center {1112 774}
 filter Impulse
 shutteroffset centred
 name Transform6
 xpos 4093
 ypos -1604
}
Crop {
 box {0 0 2224 1548}
 name Crop10
 xpos 4093
 ypos -1568
}
Grade {
 channels rgba
 gamma 0.8
 name Grade24
 xpos 4093
 ypos -1523
}
Dot {
 name Dot32
 xpos 4121
 ypos -1457
}
set N1e8dfc10 [stack 0]
Noise {
 replace true
 size 100
 zoffset {{frame/10}}
 octaves 1
 lacunarity 0
 gain 1
 gamma 0.4
 center {1112 774}
 name Noise7
 xpos 3962
 ypos -1409
}
Grade {
 channels rgba
 white 2.9
 name Grade25
 xpos 3962
 ypos -1385
}
push $N1e8dfc10
Multiply {
 inputs 1+1
 value 0
 name Multiply4
 xpos 4093
 ypos -1391
}
Crop {
 box {0 0 1920 1080}
 name Crop12
 xpos 4093
 ypos -1355
}
ZDefocus2 {
 math depth
 size {{frame-1000}}
 max_size {{size}}
 layers 10
 layerCurve 10
 filter_type bladed
 legacy_resize_mode false
 show_legacy_resize_mode false
 blades 10
 roundness 1
 inner_size 1
 inner_brightness 1
 name ZDefocus12
 xpos 4093
 ypos -1305
 addUserKnob {20 camera_tab l "Camera (DNeg)"}
 addUserKnob {22 create_camera_knobs l "create camera knobs and expressions" -STARTLINE T "__import__('dnnuke.menu.toolbar.filter.zdefocus', fromlist=\['createZDefocusCameraKnobs']).createZDefocusCameraKnobs(nuke.thisNode())"}
 addUserKnob {43 camera_knobs_info l "" +STARTLINE}
 camera_knobs_info "For a more intuitive way of controlling the depth of field, you can have camera knobs here (such as focal length, fstop etc.) along with expressions to drive ZDefocus.\n\nThe ZDefocus knobs that will be affected are:\n   depth channel\n   math\n   size\n   maximum\n   filter shape\n   aspect ratio\n\nIf you want to drive the camera knobs as well as the focal point from an existing camera you can use the Tools->Create Node from Selected Node->ZDefocus from ZenCamera, after selecting the ZenCamera node.\n\nThe same applies for BokehZDefocus."
}
Grade {
 channels rgba
 white 2000
 name Grade26
 xpos 4093
 ypos -1244
}
Shuffle {
 red alpha
 green alpha
 blue alpha
 name Shuffle20
 xpos 4093
 ypos -1220
}
FilterErode {
 channels rgba
 size 9
 filter gaussian
 name FilterErode11
 xpos 4093
 ypos -1184
}
FilterErode {
 channels rgba
 size {{-parent.FilterErode11.size}}
 filter gaussian
 name FilterErode12
 xpos 4093
 ypos -1151
}
Clamp {
 maximum 14
 name Clamp7
 xpos 4093
 ypos -1127
}
Grade {
 channels rgba
 white {{curve x1003 1 x1260 4.239437 x1500 15}}
 name Grade27
 xpos 4093
 ypos -1064
}
EdgeDetectWrapper {
 channels rgba
 name EdgeDetect9
 xpos 4093
 ypos -1040
}
FrameRange {
 first_frame 1003
 last_frame 1500
 time ""
 name FrameRange7
 xpos 4093
 ypos -1004
}
Write {
 channels rgba
 name Write6
 xpos 4093
 ypos -947
 addUserKnob {20 caravr l CaraVR}
 addUserKnob {4 viewPresets l "View Presets" M {main stereo cams "stereo cams" all}}
 addUserKnob {22 set l Set -STARTLINE T "w = nuke.thisNode()\nscriptViews = nuke.views()\nviewPreset = w\['viewPresets'].getValue()\nselectedViews = None\nif viewPreset == 0:\n  selectedViews = \['main']\nif viewPreset == 1:\n  stereoViews = \['left', 'right']\n  if set(stereoViews).issubset(set(scriptViews)):\n    selectedViews = stereoViews\n  else:\n    selectedViews = None\nelif viewPreset == 2:\n  selectedViews = \[v for v in scriptViews if 'cam' in v and not ('_left' in v or '_right' in v)]\nelif viewPreset == 3:\n  selectedViews = \[v for v in scriptViews if 'cam' in v and ('_left' in v or '_right' in v)]\nelif viewPreset == 4:\n  selectedViews = scriptViews\nif selectedViews:\n  w\['views'].fromScript(' '.join(selectedViews))\n"}
}
Read {
 inputs 0
 file_type jpeg
 file /jobs/TRAINVFX/REF/montreal/general_reference/data/2021/Elements/evolving_pattern/evolving_pattern_v01.####.jpg
 localizationPolicy off
 format "1920 1080 0 0 1920 1080 1 Canon 5D mkIII HD"
 proxy_format "640 480 0 0 640 480 1 "
 first 1000
 last 1500
 origfirst 1000
 origlast 1500
 origset true
 name Read5
 xpos 4095
 ypos -926
 postage_stamp_frame 1250
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 _ivyFile "no results were found for query (Leaf) (WHERE Leaf.job = 'TRAINVFX' AND Leaf.location = '/jobs/TRAINVFX/REF/montreal/general_reference/data/2021/Elements/evolving_pattern/evolving_pattern_v01.#.jpg' AND Leaf.deleted = '0000-00-00 00:00:00' AND Leaf.archived = '0000-00-00 00:00:00' AND Leaf.provisional = '0')"
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 addUserKnob {1 leaf_label l Leaf}
 addUserKnob {1 ivy_version l Version}
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
Camera2 {
 inputs 0
 translate {-21.79999924 -1 -10.39999962}
 rotate {0 -113.8716627 0}
 name Camera1
 xpos -1673
 ypos 2238
 addUserKnob {20 DNeg}
 addUserKnob {26 _version l "" +STARTLINE +INVISIBLE T 1.0}
 addUserKnob {41 "horiz aperture" T haperture}
 addUserKnob {41 "vert aperture" T vaperture}
 addUserKnob {4 setApertureValues l "" t "Set aperture values based on registered camera sensor data. The 'read from file' knob needs to be disabled and any potential curves deleted." +STARTLINE M {"Set Aperture Values" ANNI/Delivery "Alexa 65/Full" "Alexa 65/Half Res" "Alexa MINI/4:3 Full Ana" "Alexa MINI/16:9 Full" "Alexa MINI/OpenGate" "Alexa MINI/16:9 1.78 Ana" "Alexa Mini/OpenGate" "Alexa XT/OpenGate" "Alexa XT/4:3 Full Ana" "Alexa XT/16:9 1.78" "Alexa XT/16:9 1.78 Ana" "Alexa XT/4:3 Full" "Alexa XT/Open Gate" "Alexa XT/Open Gate TC" "Alexa XT/SuperOpenGate" "Alexa XT/SuperOpenGate Cropped" "Arri 65/6k 1.3 ana" "Arri 65/6k 2.11" BF/Delivery "BOND /Anamorphic" "Blackmagic Prod 4K/4K" "Canon 5D mkIII/HD" "Canon C300/16:9" "Delivery Extractions/Arri 65 1.3 ana Working" "Delivery Extractions/Arri 65 Working" "Extractions/CFW Delivery" "Film 35mm/Cinemascope Centred" "Film 35mm/Full Aperture" "Generic/1080p HD" Generic/Anamorphic Generic/Spherical "GoPro/Generic 16:9" HERC/Alexa IMAX/8K "Internal Movie Extractions/TRAINVFX Working" "Internal Movie Extractions/Alexa XT OpenGate" "Internal Movie Extractions/Previs" "Internal Movie Extractions/Arri 65 1.3 ana Working" "Internal Movie Extractions/MLOU Delivery" "Internal Movie Extractions/MAGIC Working" "Movie Extractions/Alexa XT OpenGate" "Movie Extractions/Alexa XT 4:3 Full Ana" "Movie Extractions/Alexa MINI 4:3 Full Ana" "Movie Extractions/Alexa MINI 16:9 1.78" "Movie Extractions/Alexa XT 16:9 1.78" "Movie Extractions/Alexa MINI OpenGate" "Movie Extractions/Alexa XT 16:9 1.78 Ana" "Movie Extractions/Alexa MINI 16:9 1.78 Ana" "Movie Extractions/Phantom Flex 4k" "Movie Extractions/MAE Working 2" "Movie Extractions/TS Anamorphic 4K" "Movie Extractions/EXO Working" "Movie Extractions/Previs" "Movie Extractions/MAGIC Working" "Movie Extractions/DOTN Working" "Phantom Flex/4k" Previs/Anamorphic Previs/Spherical "Red Epic/5K" "Red Epic Dragon/6K HD" "Red Epic Dragon/5K Full" "Red Epic Dragon/5K FullFrame Scaled" "TM/Alexa MINI 4:3 Full Ana" "Working Extractions/Arri 65 6k 1.3 ana" "Working Extractions/Alexa XT 4:3 Full Ana" "Working Extractions/Alexa XT OpenGate" "Working Extractions/Alexa XT 16:9 1.78" "Working Extractions/Alexa MINI 4:3 Full Ana" "Working Extractions/Alexa MINI OpenGate" "Working Extractions/Alexa MINI 16:9 1.78" "Working Extractions/Phantom Flex 4k" "Working Extractions/Alexa XT 16:9 1.78 Ana" "Working Extractions/Alexa MINI 16:9 1.78 Ana" "Working Extractions/EXO Working" "Working Extractions/EXO Working 2" "Working Extractions/Arri 65 6k" "Working Extractions/Alexa LF 4.5k OpenGate" "Working Extractions/DOTN Working" "internal Movie Extractions/Red Epic Dragon 5k FullFrame Scaled" "internal Movie Extractions/Red Epic Dragon 5K FullFrame" "internal Movie Extractions/IMAX 6K" "internal Movie Extractions/IMAX 8K" "Alexa LF/4.5k OpenGate" "Digital SLR/Full Frame" "Digital SLR/Full Frame Portrait" "Digital SLR/APS-C" "Digital SLR/APS-C Portrait" Generic/HD LatLong/360 LatLong/180}}
 addUserKnob {26 ""}
 addUserKnob {22 makeProjector l "Make Projector..." T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeProjectorNode']).makeProjectorNode()" +STARTLINE}
 addUserKnob {22 makeLinkedProjector l "Make Linked Projector..." -STARTLINE T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeProjectorNode']).makeLinkedProjectorNode()"}
 addUserKnob {26 ""}
 addUserKnob {7 hshake l "hero horiz shake" R -1 1}
 addUserKnob {7 vshake l "hero vert shake" R -1 1}
 addUserKnob {7 shakeroll l "hero shake roll" R -180 180}
 addUserKnob {7 ahshake l "ambient horiz shake" R -1 1}
 addUserKnob {7 avshake l "ambient vert shake" R -1 1}
 addUserKnob {7 ashakeroll l "ambient shake roll" R -180 180}
 addUserKnob {26 ""}
 addUserKnob {22 makeShakeCamera l "Make Shake Camera" T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeAmbientHeroShakeCamera']).makeAmbientHeroShakeCamera()" +STARTLINE}
 addUserKnob {22 makeShakeTransform l "Make Shake Transform" -STARTLINE T "__import__('dnnuke.init.callbacks.on_user_create.tabs.camera', fromlist=\['makeAmbientHeroShakeTransform']).makeAmbientHeroShakeTransform()"}
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 addUserKnob {1 leaf_label l Leaf}
 addUserKnob {1 ivy_version l Version}
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
push $N1cb36c00
Dot {
 name Dot50
 label "third party tool\na lot of controls and \nquality settings"
 note_font_size 31
 xpos -1764
 ypos 2133
}
Group {
 inputs 2
 name Point_Render
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 xpos -1792
 ypos 2259
 addUserKnob {20 User l "Point Render" t dd}
 addUserKnob {26 info_header l "" +STARTLINE T "Point Render v1.2"}
 addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {4 RenderMode l "Render Mode" t "Some generators support multiple render modes other than just point rendering. This should be considered a experimental feature, but can be used to great effect.\n\nIn the Render Settings tab you can find more controls relating to Wire and Facet rendering modes.\n\nNote that Facet Render can be slow when really close to a object. " M {"Point Render" "Wire Render" "Facet Render (experimental)" "" "" ""}}
 addUserKnob {7 FocalLength l "Focal Length" t "The point render does not take the focal length from the input camera, so if you want to match it to a camera you should link the focal length from the camera to this." +INVISIBLE R 0 200}
 FocalLength 40
 addUserKnob {7 horizontalApeture l "Horiz Apeture" +INVISIBLE R 0 100}
 horizontalApeture 24.576
 addUserKnob {14 overscan l Overscan R 0 100}
 addUserKnob {7 AlphaMultiplier l Exposure t "This is a general exposure modifier that lets you adjust the overall brightness of the render." R 0 2}
 AlphaMultiplier 1
 addUserKnob {6 OutputZdepth l "Output Z-depth" t "Will output a Z-depth channel. This will cause reduced rendering performence." +STARTLINE}
 addUserKnob {6 UseOcclusionMap l "Use Occlusion Map" t "Enable the Occlusion map input. This lets you use a depth map as a holdout.\n\nNote:\nThe Red channal should contain the depth (absolute distance, not 1/depth)\nThe Alpha channal must be 1 for the areas that you want to holdout." +STARTLINE}
 addUserKnob {4 occ_method l "" t "Real Depth - input RGB should be the distance to the camera, and A should be the alpha (White occlude, Black ingore).\n\n1/depth.z (Scanline Render) - Will use the depth.Z channal from the scanline render and convert to real depth internally. Alpha is still required." -STARTLINE M {"Real Depth" "1/depth.z (Scanline Render)" ""}}
 occ_method "1/depth.z (Scanline Render)"
 addUserKnob {26 devider_cc l "<b><font color=#7DADF9>Preview</font><b>"}
 addUserKnob {6 FastPreview l "Fast Preview" t "Reduce the number of points for a quick preview of the final render." +STARTLINE}
 addUserKnob {6 HighlightCompression l "Hilight Compression" t "Compresses the highlights to make it easier to see bright details." +STARTLINE}
 addUserKnob {7 HighlightCeiling l "Highlight Ceiling" t "Adjust the cealing for the highlight compression." R 1 10}
 HighlightCeiling 1.15
 addUserKnob {7 Compression t "The compression amount." -STARTLINE R 0 5}
 Compression 1
 addUserKnob {26 devider_format l "<b><font color=#7DADF9>Format</font><b>"}
 addUserKnob {41 format l "output format" T Settings_Format.format}
 addUserKnob {20 WireRender l "Render Settings"}
 addUserKnob {26 devider_wirerender l "<b><font color=#7DADF9>Wire Rendering</font><b>"}
 addUserKnob {4 wire_type l "Connection Mode" t "*Normal\nConnect lines between the local neigbours of the 2d position map\n\n*Nearest\nConnect lines to the nearest points (in 3D space). This mode is limited to 100x100 points for performence reasons!" M {Normal Nearest "" "" "" "" "" "" "" ""}}
 addUserKnob {26 text l "Normal Mode Wires" T " "}
 addUserKnob {6 connect_x l x t "Connect wires in the (uv) X axis." -STARTLINE}
 connect_x true
 addUserKnob {6 connect_xy l xy t "Connect wires in the (uv) XY axis." -STARTLINE}
 connect_xy true
 addUserKnob {6 connect_y l y t "Connect wires in the (uv) Y axis." -STARTLINE}
 connect_y true
 addUserKnob {6 connect_aux l aux t "If you input a vector map into the Aux input for this node, and enable this option, you will get a wire from each point along that vector." -STARTLINE}
 addUserKnob {7 wire_maxdistance l "Max Distance" t "The maximum distance that the wires connect." R 0 10}
 wire_maxdistance 6
 addUserKnob {7 wire_Threshold l "Distance Threshold" t "Control the max distance threshold" R 0 2}
 wire_Threshold 0.5
 addUserKnob {3 wire_connections l "Max Connections" t "The maximum number of connections (Not Yet Implemented)"}
 wire_connections 4
 addUserKnob {7 maxSamples l "Max Line Samples" t "The maximum length of a line. Once a line is longer than this, it will start break up. \nThis can also be used as a creative effect if you set it low, try setting it to 10 in wire mode to get dotted lines" R 0 10000}
 maxSamples 10000
 addUserKnob {7 lineoffset l "Line Offset" t "Expand or contract the lines."}
 lineoffset 1
 addUserKnob {7 inGain l "In Gain" t "Gain the brightness of the in-point of the lines"}
 inGain 1
 addUserKnob {7 outGain l "Out Gain" t "Gain the brightness of the out-point of the lines" -STARTLINE}
 outGain 1
 addUserKnob {26 devider_facet l "<b><font color=#7DADF9>Facet Rendering</font><b>"}
 addUserKnob {4 renderMode l "Render Mode" t "Pick the desidered render mode." M {Diffuse "Local ST" Normal "Facing Ratio" UV ST "View Normal" "World Position" "" ""}}
 addUserKnob {6 facet_flatShading l "Flat Shading" t "Flat shading" +STARTLINE}
 addUserKnob {6 facet_depth l "Depth Buffer" t "Enable depth sorting to avoid additive surfaces." -STARTLINE}
 addUserKnob {6 facet_front l "Front Face" t "Render front facing facets" +STARTLINE}
 facet_front true
 addUserKnob {6 facet_backface l "Back Face" t "Render backfacing faces" -STARTLINE}
 facet_backface true
 addUserKnob {26 _1 l "<b><font color=#7DADF9>Other</font><b>"}
 addUserKnob {6 CloseX l "Close X" t "On spheres or round objects this closes the loop" +STARTLINE}
 addUserKnob {6 CloseY l "Close Y" t "On spheres or round objects this closes the loop" -STARTLINE}
 addUserKnob {20 Fog_1 l Fog}
 addUserKnob {26 Devider_Fog l "<b><font color=#7DADF9>Fog</font><b>"}
 addUserKnob {6 Fog t "Fog reduces the brightness of poins far from the camera." +STARTLINE}
 addUserKnob {7 FogNear l "Fog Near" R 0 200}
 FogNear 1
 addUserKnob {7 FogFar l "Fog Far" R 0 200}
 FogFar 150
 addUserKnob {7 FogExponent l "Fog Exponent" R 0 8}
 FogExponent 8
 addUserKnob {20 DepthOfField l "Depth of Field"}
 addUserKnob {26 devider_dof l "<b><font color=#7DADF9>Depth Of Field</font><b>"}
 addUserKnob {6 dof_enable l Enable +STARTLINE}
 dof_enable true
 addUserKnob {7 dof_focaldepth l "Focal Depth" R 0 40}
 dof_focaldepth 24.1
 addUserKnob {7 dof_dof l "Depth of Field" R 0 10}
 dof_dof 1
 addUserKnob {7 dof_maxSize l "Max Size"}
 dof_maxSize 0.6
 addUserKnob {7 dof_Aspect l "Aspect Ratio"}
 dof_Aspect 1
 addUserKnob {7 dof_bias l Bias R -3 3}
 dof_bias -0.2
 addUserKnob {4 Dof_Quality l Quality M {Low Medium High Extreme}}
 addUserKnob {20 MotionBlur}
 addUserKnob {26 devider_MotionBlur l "<b><font color=#7DADF9>Motion Blur</font><b>"}
 addUserKnob {6 mb_enable l Enable +STARTLINE}
 mb_enable true
 addUserKnob {6 Fast l "Fast (Interpolated)" -STARTLINE}
 Fast true
 addUserKnob {3 Samples}
 Samples 4
 addUserKnob {7 Shutter R 0 2}
 Shutter 0.5
 addUserKnob {4 pulldown l "Shutter Offset" M {Centered Start End ""}}
 addUserKnob {20 preview_3d l "3D Preview"}
 addUserKnob {6 Enable3DPreview l "Enable 3D Preview" t "Display a preview of the points in the Nuke 3D view." +STARTLINE}
 Enable3DPreview true
 addUserKnob {41 pointSize l "point size" T PreviewNode.pointSize}
 addUserKnob {41 detail l "point detail" T PreviewNode.detail}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x388e8e00
  label "Output Format Manager"
  note_font_size 22
  xpos -1079
  ypos 117
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode10
  tile_color 0x388e8e00
  label "AUX Input"
  note_font_size 22
  xpos -385
  ypos 178
  bdwidth 207
  bdheight 178
 }
 BackdropNode {
  inputs 0
  name BackdropNode11
  tile_color 0x388e8e00
  label "Point Render"
  note_font_size 22
  xpos -96
  ypos 99
  bdwidth 203
  bdheight 131
 }
 BackdropNode {
  inputs 0
  name BackdropNode12
  tile_color 0x388e8e00
  label "Normal Generator\nFor Vertex Normals"
  note_font_size 22
  xpos -616
  ypos 243
  bdwidth 191
  bdheight 122
 }
 BackdropNode {
  inputs 0
  name BackdropNode13
  tile_color 0x388e8e00
  label "Ensure output format"
  note_font_size 22
  xpos -622
  ypos -41
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode14
  tile_color 0x388e8e00
  label "Motion Blur"
  note_font_size 22
  xpos -85
  ypos 255
  bdwidth 264
  bdheight 96
 }
 BackdropNode {
  inputs 0
  name BackdropNode15
  tile_color 0x388e8e00
  label "Soft Preview"
  note_font_size 22
  xpos -83
  ypos 601
  bdwidth 191
  bdheight 94
 }
 BackdropNode {
  inputs 0
  name BackdropNode16
  tile_color 0x388e8e00
  label "Final format"
  note_font_size 22
  xpos -84
  ypos 482
  bdwidth 192
  bdheight 95
 }
 BackdropNode {
  inputs 0
  name BackdropNode17
  tile_color 0x388e8e00
  label "No Clue =)"
  note_font_size 22
  xpos -385
  ypos -41
  bdwidth 160
  bdheight 87
 }
 BackdropNode {
  inputs 0
  name BackdropNode18
  tile_color 0x388e8e00
  label "Z-Depth Shuffle"
  note_font_size 22
  xpos -85
  ypos 367
  bdwidth 264
  bdheight 96
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0x388e8e00
  label Motionblur
  note_font_size 22
  xpos -672
  ypos -781
  bdwidth 258
  bdheight 246
 }
 BackdropNode {
  inputs 0
  name BackdropNode3
  tile_color 0x388e8e00
  label "Fast Preview"
  note_font_size 22
  xpos -669
  ypos -971
  bdwidth 254
  bdheight 138
 }
 BackdropNode {
  inputs 0
  name BackdropNode4
  tile_color 0x388e8e00
  label "Nearest Wire Mode Clamp"
  note_font_size 22
  xpos -666
  ypos -1184
  bdwidth 253
  bdheight 111
 }
 BackdropNode {
  inputs 0
  name BackdropNode5
  tile_color 0x388e8e00
  label Occlusion
  note_font_size 22
  xpos 208
  ypos 27
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode6
  tile_color 0x388e8e00
  label "Input Camera Container"
  note_font_size 22
  xpos -1357
  ypos 121
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode7
  tile_color 0x388e8e00
  label "3D Preview"
  note_font_size 22
  xpos -88
  ypos -45
  bdwidth 207
  bdheight 102
 }
 BackdropNode {
  inputs 0
  name BackdropNode8
  tile_color 0x388e8e00
  label "Input Format Manager"
  note_font_size 22
  xpos -526
  ypos -459
  bdwidth 208
  bdheight 97
 }
 BackdropNode {
  inputs 0
  name BackdropNode9
  tile_color 0x388e8e00
  label FOG
  note_font_size 22
  xpos -602
  ypos -253
  bdwidth 370
  bdheight 152
 }
 Input {
  inputs 0
  name InputPointData
  xpos -584
  ypos -1321
 }
 Dot {
  name Dot4
  xpos -550
  ypos -1234
 }
set N1cbc0dc0 [stack 0]
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize fill
  filter Impulse
  black_outside true
  name Reformat5
  xpos -584
  ypos -906
  disable {{!parent.FastPreview==1}}
 }
 Grade {
  white 10
  name Grade2
  xpos -584
  ypos -874
  disable {{!parent.FastPreview}}
 }
 Dot {
  name Dot2
  xpos -550
  ypos -712
 }
set N1cbe5410 [stack 0]
 Group {
  name FrameHold3
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -501
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame+1}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot6
  xpos -467
  ypos -659
 }
set N1cc053f0 [stack 0]
push $N1cbe5410
 Group {
  name FrameHold2
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -660
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot5
  xpos -626
  ypos -659
 }
set N1cc25260 [stack 0]
 Dissolve {
  inputs 2
  which {{frame-floor(frame)}}
  name Dissolve1
  xpos -582
  ypos -666
  disable {{1-parent.mb_enable}}
 }
set N1cc29dc0 [stack 0]
push $N1cbe5410
 Switch {
  inputs 2
  which {{parent.Fast}}
  name Switch2
  xpos -584
  ypos -567
 }
 Dot {
  name DataFetch
  label "data fetch\t"
  note_font_color 0xff21ff
  xpos -550
  ypos -513
  addUserKnob {20 User}
  addUserKnob {3 n_particles l "Number of Particles"}
  addUserKnob {3 gentype l "Type Of Generator"}
  addUserKnob {26 info l "" -STARTLINE T "0 = unknown, 1 = Card, 2 = Sphere, 3 = Grid"}
 }
set N1cc3d170 [stack 0]
 Dot {
  name Dot3
  xpos -635
  ypos -513
 }
 Dot {
  name Dot1
  xpos -635
  ypos 863
 }
 Reformat {
  inputs 0
  format "1920 1080 0 0 1920 1080 1 HD_1080"
  resize distort
  center false
  black_outside true
  name Settings_Format
  xpos -992
  ypos 209
 }
 AdjBBox {
  numpixels {{parent.overscan} {parent.overscan}}
  name AdjBBox2
  xpos -992
  ypos 241
 }
 Input {
  inputs 0
  name InputOcclusion
  xpos 238
  ypos 75
  number 2
 }
 Expression {
  expr0 depth.Z>0?1/depth.Z:0
  name Expression2
  xpos 238
  ypos 104
  disable {{!parent.occ_method}}
 }
 Constant {
  inputs 0
  channels rgb
  color 1
  format {{{parent.Settings_Format.format}}}
  name Empty
  xpos 371
  ypos 139
 }
 Switch {
  inputs 2
  which {{parent.UseOcclusionMap}}
  name Switch1
  xpos 238
  ypos 163
 }
 AdjBBox {
  numpixels {{parent.overscan} {parent.overscan}}
  name AdjBBox1
  xpos 118
  ypos 163
 }
set N1cc86ba0 [stack 0]
 Input {
  inputs 0
  name Aux
  xpos -324
  ypos 214
  number 3
 }
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter Impulse
  black_outside true
  name Reformat2
  xpos -324
  ypos 238
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop1
  xpos -324
  ypos 462
 }
push $N1cc3d170
 Shuffle {
  in pos
  name Shuffle1
  xpos -584
  ypos -192
 }
set N1ccad640 [stack 0]
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter Impulse
  black_outside true
  name Reformat4
  xpos -584
  ypos 18
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop2
  xpos -584
  ypos 48
 }
 Dot {
  name Dot8
  xpos -550
  ypos 166
 }
set N1ccd7850 [stack 0]
 Group {
  name Point_Normal2
  tile_color 0x434343ff
  note_font_color 0x55ffffff
  xpos -584
  ypos 498
  disable {{!(renderMode==2&&RenderMode==2)}}
  addUserKnob {20 User}
  addUserKnob {26 info l "" +STARTLINE T "Point Normal v1.0"}
  addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
  addUserKnob {26 info_1 l "" +STARTLINE T "well, not much to do here =)"}
 }
  Input {
   inputs 0
   name Input1
   xpos 389
   ypos 207
  }
  Shuffle {
   in pos
   name Shuffle1
   xpos 389
   ypos 294
  }
  BlinkScript {
   kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/BasicLight.cpp
   recompileCount 69
   ProgramGroup 1
   KernelDescription "2 \"PointRender3D\" iterate pixelWise d5452fe7b684561fcfa5182d0c789025a037cc4fe4474c24e065e3fa53fcd8ce 2 \"ppos\" Read Random \"dst\" Write Point 9 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"Zoom\" Float 1 AACAPw== \"half Lambert\" Bool 1 AQ== \"light Mode\" Int 1 AAAAAA== \"light_position\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"light_color\" Float 3 AACAPwAAgD8AAIA/AAAAAA== 9 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"zoom\" 1 1 \"halfLambert\" 1 1 \"lightMode\" 1 1 \"lightPos\" 3 1 \"lightcolor\" 3 1 10 \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"namount\" Float 1 1 AAAAAA=="
   kernelSource "inline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}\n\ninline float saturate(float _in)\n\{\n    return max(0.0f,min(1.0f,_in));\n\}\n\ninline float3 reflect(float3 incidence,float3 normal)\n\{\n  return incidence - 2.f * dot(incidence, normal) * normal;\n\}\n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n    \n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    if (fabs(pScreen.x) > canvasWidth || fabs(pScreen.y) > canvasHeight) \n         return false; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eWrite> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    bool halfLambert;\n    int lightMode;\n    float3 lightPos;\n    float3 lightcolor;\n\n\n  local: //Local variables\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n    float namount; //dither amount\n\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(halfLambert, \"half Lambert\", true);\n    defineParam(lightMode, \"light Mode\", 0);\n    defineParam(lightPos,      \"light_position\", float3(0,0,0));  \n    defineParam(lightcolor,      \"light_color\", float3(1.0,1.0,1.0)); \n  \}\n\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n    namount = 0.0001; //dither amount\n  \}\n\n\n\nfloat3 Reconsile3D(float3 _PointPos)\{\n    vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n    int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    return tRaster;\n\}\n\n\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nfloat3 facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos;\n    float4 V0_Sample,V1_Sample,V2_Sample;\n    float3 normal0,normal1,normal2;\n\n    //for area calculation\n    float area;\n    float3 V0,V1,V2;\n    float3 output = float3(0.0f);\n  if (insideX) \{\n    V2_Sample = ppos(pos.x+1,pos.y);\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(pos.x+1,pos.y-1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n            float3 Normal = CalculateVertexNormals(_vWorld,V2_wPos,V1_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          //write output\n          output +=  float3(Normal.x,Normal.y,Normal.z);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,pos.y+1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n          float3 Normal = CalculateVertexNormals(_vWorld,V1_wPos,V2_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          output += float3(Normal.x,Normal.y,Normal.z);\n\n        \}\n      \}\n    \}\n  \}\n  return output;\n\}\n\n\n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 hitNormal = cross((V1 - V0),(V2 - V0)); \n        return hitNormal;\n\}\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float3 output = float3(0.0f);\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float3 point_pos = float3(_sample.x,_sample.y,_sample.z);\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n      dst() = float4(0.0f);\n      output+=facet_render(pos,float3(_sample.x,_sample.y,_sample.z))*2.0f;\n      _sample = ppos(pos.x-1,pos.y); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x-1,pos.y+1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y+1),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x,pos.y-1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x,pos.y-1),float3(_sample.x,_sample.y,_sample.z));\n\n      output = normalize(output);\n      float3 normal = -output;\n\n      \n\n\n      dst() = float4(normal.x,normal.y,normal.z,1.0f);\n    \}\n  \} //----> process\n\};\n"
   rebuild ""
   "PointRender3D_half Lambert" false
   PointRender3D_light_position {{parent.Axis1.translate} {parent.Axis1.translate} {parent.Axis1.translate}}
   PointRender3D_light_color {0 0 0}
   rebuild_finalise ""
   name BlinkScript1
   xpos 389
   ypos 344
  }
  Grade {
   multiply 0.5
   add 0.5
   black_clamp false
   name Grade1
   xpos 389
   ypos 376
   disable true
  }
  Output {
   name Output1
   xpos 389
   ypos 459
  }
  Axis2 {
   inputs 0
   translate {0.5 0.5 0.5}
   name Axis1
   xpos 661
   ypos 318
   addUserKnob {20 Ivy}
   addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
   addUserKnob {26 divider4 l "" +STARTLINE}
   addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
   _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
   addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
   addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
   addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
   _expressions {{curve}}
   addUserKnob {26 divider0 l "" +STARTLINE}
   addUserKnob {20 dbinfo l "DB Info" n 1}
   dbinfo 0
   addUserKnob {1 twig_dnuuid l "Twig Id"}
   addUserKnob {1 stalk_dnuuid l "Stalk Id"}
   addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
   addUserKnob {1 leaf_dnuuid l "Leaf Id"}
   addUserKnob {26 divider1 l "" +STARTLINE}
   addUserKnob {1 twigtype l "Twig Type"}
   addUserKnob {1 leaf_label l Leaf}
   addUserKnob {1 ivy_version l Version}
   addUserKnob {43 ivy_notes l Notes}
   addUserKnob {26 divider2 l "" +STARTLINE}
   addUserKnob {1 build_label l "Build Label"}
   addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
  }
 end_group
 Switch {
  inputs 2
  which {{parent.connect_aux}}
  name Switch3
  xpos -324
  ypos 498
 }
set N1cd4ee60 [stack 0]
push $N1ccad640
 Expression {
  temp_name0 xd
  temp_expr0 red-Camera1.world_matrix.3
  temp_name1 yd
  temp_expr1 green-Camera1.world_matrix.7
  temp_name2 zd
  temp_expr2 blue-Camera1.world_matrix.11
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  expr3 Distance
  name Expression1
  xpos -456
  ypos -192
 }
 Grade {
  channels rgba
  blackpoint {{parent.FogFar}}
  whitepoint {{parent.FogNear}}
  gamma {{1/(parent.FogExponent+0.000000001)}}
  white_clamp true
  name Grade1
  xpos -456
  ypos -168
 }
push $N1cc3d170
 Dot {
  name Dot7
  xpos -307
  ypos -513
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge1
  xpos -341
  ypos -168
  disable {{!parent.Fog}}
 }
 Shuffle {
  name Shuffle3
  xpos -341
  ypos 8
 }
set N1cd8b1e0 [stack 0]
 Shuffle {
  red white
  green white
  blue white
  name Shuffle2
  xpos -28
  ypos 76
 }
push $N1ccd7850
 BlinkScript {
  inputs 4
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Render/3D_PointRender_v18.cpp
  recompileCount 806
  ProgramGroup 1
  KernelDescription "2 \"PointRender3D\" iterate pixelWise b6c79b641c58390f32c944e2b5792a8702107f9cfc926636430288e7e0e1b392 5 \"ppos\" Read Random \"src\" Read Random \"normals\" Read Random \"occlusion\" Read Random \"dst\" Write Random 50 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"vertexformat\" Int 2 CgAAAAoAAAA= \"Zoom\" Float 1 AACAPw== \"Filtering Method\" Int 1 AQAAAA== \"_alphaMultiplier\" Float 1 AACAPw== \"_pointRender\" Bool 1 AQ== \"_wireRender\" Bool 1 AQ== \"_facetRender\" Bool 1 AQ== \"_maxLDistance\" Float 1 AACAPw== \"_maxLConnections\" Int 1 AQAAAA== \"_maxPlexType\" Int 1 AAAAAA== \"_plexLinedefXY\" Bool 1 AA== \"_plexLinedefX\" Bool 1 AA== \"_plexLinedefY\" Bool 1 AA== \"_plexLinedefXtoY\" Bool 1 AA== \"_plexLinedefAUX\" Bool 1 AA== \"_plexConnectX\" Bool 1 AA== \"_plexConnectY\" Bool 1 AA== \"_L_gamma\" Float 1 AACAPw== \"Enable Depth of Field\" Bool 1 AA== \"samples\" Int 1 AwAAAA== \"rings\" Int 1 BQAAAA== \"focalDepth\" Float 1 AACAPw== \"_depthOfField\" Float 1 AACAQA== \"_depthMult\" Float 1 zczMPQ== \"_maxDofSize\" Float 1 AAAAQQ== \"dof_aspect\" Float 1 AACAPw== \"dof_threshold\" Float 1 AACAPw== \"dof_gain\" Float 1 AAAAAA== \"dof_bias\" Float 1 AAAAwA== \"dof_fringe\" Float 1 AAAAAA== \"_flatshading\" Bool 1 AQ== \"_backfacing\" Bool 1 AQ== \"_frontfacing\" Bool 1 AQ== \"_vertexMode\" Int 1 AAAAAA== \"_depthBuffer\" Bool 1 AQ== \"_texoffset\" Float 2 AAAAPwAAAD8= \"_pointSize\" Int 1 AQAAAA== \"_gaussigma\" Float 1 AACAPw== \"_depthOcclusion\" Bool 1 AQ== \"depthMultiplier\" Float 1 AACAPw== \"_maxLineSteps\" Float 1 AAB6RQ== \"_lineOffset\" Float 1 AACAPw== \"_lineInMultiplier\" Float 1 AACAPw== \"_lineOutMultiplier\" Float 1 AACAPw== \"_overscan\" Float 2 AAAAAAAAAAA= \"isDepth\" Bool 1 AA== 50 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"Vformat\" 2 1 \"zoom\" 1 1 \"_filtering\" 1 1 \"_alphaMultiplier\" 1 1 \"_pointRender\" 1 1 \"_wireRender\" 1 1 \"_facetRender\" 1 1 \"_maxPlexDistance\" 1 1 \"_maxPlexConnections\" 1 1 \"_maxPlexType\" 1 1 \"_plexLinedefXY\" 1 1 \"_plexLinedefX\" 1 1 \"_plexLinedefY\" 1 1 \"_plexLinedefXtoY\" 1 1 \"_plexLinedefAUX\" 1 1 \"_plexConnectX\" 1 1 \"_plexConnectY\" 1 1 \"_plex_gamma\" 1 1 \"_dof_enable\" 1 1 \"_dof_samples\" 1 1 \"_dof_rings\" 1 1 \"focalDepth\" 1 1 \"_depthOfField\" 1 1 \"_depthMult\" 1 1 \"_maxDofSize\" 1 1 \"dof_aspect\" 1 1 \"dof_threshold\" 1 1 \"dof_gain\" 1 1 \"dof_bias\" 1 1 \"dof_fringe\" 1 1 \"_flatshading\" 1 1 \"_backfacing\" 1 1 \"_frontfacing\" 1 1 \"_vertexMode\" 1 1 \"_depthBuffer\" 1 1 \"_texoffset\" 2 1 \"_pointSize\" 1 1 \"_gaussigma\" 1 1 \"_depthOcclusion\" 1 1 \"depthMultiplier\" 1 1 \"_maxLineSteps\" 1 1 \"_lineOffset\" 1 1 \"_lineInMultiplier\" 1 1 \"_lineOutMultiplier\" 1 1 \"_overscan\" 2 1 \"isDepth\" 1 1 10 \"max_line_connections\" Int 1 1 AAAAAA== \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "//Some basic generic functions.\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float3 Cross(float3 A,float3 B)\n\{\n    return float3(A.y*B.z - A.z*B.y,A.z*B.x - A.x*B.z,A.x*B.y - A.y*B.x);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}     \n\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\ninline float mix(float _X,float _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}                                                                                              \n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n\n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight,\n    float2 overscan\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f-overscan.x || pRaster.x > imageWidth+overscan.x || \n       pRaster.y < 0.0f-overscan.y || pRaster.y > imageHeight+overscan.y || pRaster.z < 0.0f) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eRead, eAccessRandom, eEdgeClamped> src;     //The texture map\n  Image<eRead, eAccessRandom, eEdgeClamped> normals;     //The texture map  \n  Image<eRead, eAccessRandom, eEdgeClamped> occlusion;     //The texture map \n  Image<eWrite, eAccessRandom> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat,Vformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    int _filtering;        //Filter method\n    float _alphaMultiplier; //Additive multiplier\n    bool _pointRender,_wireRender,_facetRender;\n    float _maxPlexDistance; //Additive multiplier\n    int _maxPlexConnections;\n    int _maxPlexType; // 0==Grid, -1==Nearest\n    bool _plexLinedefXY,_plexLinedefX,_plexLinedefY,_plexLinedefXtoY,_plexLinedefAUX; // Define what connections NOT to include\n    bool _plexConnectX,_plexConnectY; //Connect from the edge of x to 0, or edge of y to 0, usually for spheres\n    float _plex_gamma; //The threshold making shorter paths bright and longer paths dark\n    bool _dof_enable; // Enable DOF\n    int _dof_samples; // How many samples per DOF ring\n    int _dof_rings; // How many rings \n    float focalDepth,_depthOfField,_depthMult,_maxDofSize; //DOF Settings\n    float dof_aspect; //Pixel aspect ratio\n    float dof_threshold;\n    float dof_gain;\n    float dof_bias; //bokeh edge bias\n    float dof_fringe; //bokeh chromatic aberration/fringing\n    bool _flatshading,_backfacing,_frontfacing; //Vertex rendering settings\n    int _vertexMode;  //The rendering output mode, (think AOV)\n    bool _depthBuffer; //Non-additive, only render front most pixel\n    float2 _texoffset;\n    int _pointSize;\n    float _gaussigma;\n    bool _depthOcclusion;\n    float depthMultiplier;\n    float _maxLineSteps; //cap the line length to avoid process lock\n    float _lineOffset; //Alow you to shrink or extend the lines\n    float _lineInMultiplier,_lineOutMultiplier; //Control the brightness of the wires at the tips.\n    float2 _overscan; //This will allow you to render some extra outside the bounds of the image.\n    bool isDepth; //This will allow you to render some extra outside the bounds of the image.\n\n  local: //Local variables\n    int max_line_connections;\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(Vformat,      \"vertexformat\", int2(10,10));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(_filtering, \"Filtering Method\", 1); \n    defineParam(_alphaMultiplier, \"_alphaMultiplier\", 1.0f);     \n    defineParam(_pointRender, \"_pointRender\", true);  \n    defineParam(_wireRender, \"_wireRender\", true);\n    defineParam(_facetRender, \"_facetRender\", true);\n    defineParam(_maxPlexDistance, \"_maxLDistance\", 1.0f);    \n    defineParam(_maxPlexConnections, \"_maxLConnections\", 1);    \n    defineParam(_maxPlexType, \"_maxPlexType\", 0); \n    defineParam(_plexLinedefXY, \"_plexLinedefXY\", false);      \n    defineParam(_plexLinedefXtoY, \"_plexLinedefXtoY\", false); //NYI\n    defineParam(_plexLinedefAUX, \"_plexLinedefAUX\", false); \n    defineParam(_plexLinedefX, \"_plexLinedefX\", false);  \n    defineParam(_plexLinedefY, \"_plexLinedefY\", false);  \n    defineParam(_plexConnectX, \"_plexConnectX\", false);      \n    defineParam(_plexConnectY, \"_plexConnectY\", false);   \n    defineParam(_plex_gamma, \"_L_gamma\", 1.0f);\n    //DOF SETTINGS   \n    defineParam(_dof_enable, \"Enable Depth of Field\", false);   \n    defineParam(_dof_samples, \"samples\", 3);    \n    defineParam(_dof_rings, \"rings\", 5);   \n    defineParam(focalDepth, \"focalDepth\", 1.0f);  \n    defineParam(_depthOfField, \"_depthOfField\", 4.0f);  \n    defineParam(_depthMult, \"_depthMult\", 0.1f);  \n    defineParam(_maxDofSize, \"_maxDofSize\", 8.0f);  \n    defineParam(dof_aspect, \"dof_aspect\", 1.0f);  \n    defineParam(dof_threshold, \"dof_threshold\", 1.0f);  \n    defineParam(dof_gain, \"dof_gain\", 0.0f);  \n    defineParam(dof_bias, \"dof_bias\", -2.0f);  \n    defineParam(dof_fringe, \"dof_fringe\", 0.0f); \n    //SHADING SETTINGS \n    defineParam(_flatshading, \"_flatshading\", true);  \n    defineParam(_vertexMode, \"_vertexMode\", 0);  \n    defineParam(_backfacing, \"_backfacing\", true);    \n    defineParam(_frontfacing, \"_frontfacing\", true);        \n    defineParam(_depthBuffer, \"_depthBuffer\", true);  \n    defineParam(_texoffset, \"_texoffset\", float2(0.5f,0.5f)); \n    defineParam(_pointSize, \"_pointSize\", 1); \n    defineParam(_gaussigma, \"_gaussigma\", 1.0f); \n    defineParam(_depthOcclusion, \"_depthOcclusion\", true); \n    defineParam(depthMultiplier, \"depthMultiplier\", 1.0f); \n    defineParam(_maxLineSteps, \"_maxLineSteps\", 4000.0f); \n    defineParam(_lineOffset, \"_lineOffset\", 1.0f); \n    defineParam(_lineInMultiplier, \"_lineInMultiplier\", 1.0f);   \n    defineParam(_lineOutMultiplier, \"_lineOutMultiplier\", 1.0f);     \n    defineParam(_overscan, \"_overscan\",float2(0.0f,0.0f));    \n\n  \}\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    max_line_connections = 80;\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n  \}\n\n  //Convert a 3d point position into a 2d raster position.\n  float3 Reconsile3D(float3 _PointPos)\{\n      vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      return tRaster;\n  \}\n\n//------------------------------\n//-------DRAW FUNCTIONS---------\n//------------------------------\n  //Write pixels to output.\n  void writepixel(float posx,float posy, float4 color,int index,float weight=1.0f)\n  \{ \n      if (_depthOcclusion)\{\n        float4 depthSample = occlusion(posx,posy);\n        if (depthSample.x<=vRaster.z && depthSample.w>0.0f)\{\n\n          float depth = (vRaster.z-depthSample.x);\n          color = color*(1.0f-depthSample.w);\n          color = color / (((depth*depth)*depthMultiplier)+1.0f);\n          //return;\n        \}\n      \}\n      float4 finalOutput; //This is used to store the final output\n      float4 dstSample; //This is used to store a sample of the destination\n      if ( dst.bounds.inside( posx, posy ) ) \{ //Test if the pixel written to is inside the output image. \n        if (_depthBuffer) \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          if ((dstSample.w>color.w)||dstSample.w==0.0f) \{\n            dst(posx,posy) = color;\n          \}\n        \}\n        else \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          finalOutput = dstSample + (color*_alphaMultiplier*weight);\n          finalOutput.w = dstSample.w + ((color.w*_alphaMultiplier*weight));\n\n          finalOutput.w = (dstSample.w + ((color.w*_alphaMultiplier*weight)))-(dstSample.w * ((color.w*_alphaMultiplier*weight)));\n\n          dst(posx,posy) = finalOutput;\n        \}\n      \} \n  \}\n\n  //Calculate a Bilinear Plot\n  void bilinear_Plot(float2 temppos,float4 color,int index)\n  \{\n    float2 p;\n    p.x=Frac(temppos.x);\n    p.y=Frac(temppos.y);\n    float weights\[] = \{(1.0f-p.x)*(1.0f-p.y), p.x*(1.0f-p.y), (1.0f-p.x)*p.y, p.x*p.y\};\n    int2 _position = int2(floor(temppos.x)-0,floor(temppos.y)-0); \n    writepixel(_position.x,_position.y,color,index,weights\[0]);\n    writepixel(_position.x+1,_position.y,color,index,weights\[1]);\n    writepixel(_position.x,_position.y+1,color,index,weights\[2]);\n    writepixel(_position.x+1,_position.y+1,color,index,weights\[3]);\n  \}\n\n  //NYI, unused!\n  void gaussian(float2 temppos,float4 color,int index)\{\n    float in_x = temppos.x;\n    float in_y = temppos.y;\n    int kernelSize = (_pointSize+1)*2;\n    int subsize = (kernelSize /2)-1;\n    float gKernel\[64]\[64];\n    float sigma = _gaussigma;\n    float intSigma = float(_pointSize);\n    float r, s = intSigma * sigma * sigma;\n\n    float sum = 0.0f;\n\n    // generate 5x5 kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            r = float(sqrt(x*x + y*y));\n            gKernel\[x + subsize]\[y + subsize] = (exp(-(r*r)/s))/(3.141592654f * s);\n            sum += gKernel\[x + subsize]\[y + subsize];\n        \}\n    \}\n\n    // normalize the Kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            gKernel\[x + subsize]\[y + subsize] /= sum;\n            writepixel(in_x+x,in_y+y,color,index,gKernel\[x + subsize]\[y + subsize]);\n        \}\n    \}\n  \}\n\n//-------------------------------------\n// DrawLine\n// ----------\n// Draw a line between two points, \n// x,y being 2d screenspace pos and z being depth.\n//-------------------------------------\n  void DrawLine(float3 origin, float3 endpoint,float4 _colorA,float4 _colorB) \{\n    float4 _color;\n    float3 delta = origin-endpoint;\n    float3 curPoint = origin;\n    float mag = sqrt(delta.x*delta.x+delta.y*delta.y);\n    mag = min(mag,_maxLineSteps); //Lets not go crazy, we cap it at 10.000 to avoid insane unwated processing time \n    for( float a = 0; a < mag*_lineOffset; a = a + 1.0f )\{\n      curPoint -= (delta/mag);\n      _color = (_colorA*(1.0f-(a/mag*1.0f)))+(_colorB*(a/mag*1.00f));\n      if (_dof_enable)\{\n        Bokeh(curPoint,_color);\n      \}\n      else \{\n        if (_depthBuffer && isDepth) \{_color = float4(1.0f,1.0f,1.0f,curPoint.z);\} //Added\n        bilinear_Plot(float2(curPoint.x,curPoint.y),_color,1);\n      \}\n      \n    \}\n  \}\n\n//-------------------------------------\n// Point_Render\n//-------------------------------------\nvoid point_render(int2 pos, float3 screen_pos)\{\n  float4 color = src(pos.x,pos.y);\n\n  if (_filtering == 1)\{\n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        if (_depthBuffer) \{color.w = screen_pos.z;\} //Added\n        bilinear_Plot(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  /*\n  //THIS PART NEEDS TO BE RE-WRITTEN.\n  else if (_filtering == 2)\{ \n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        gaussian(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  */\n  else \{\n      int2 _position = int2(floor(screen_pos.x),floor(screen_pos.y)); \n      if (_depthBuffer) \{color.w = screen_pos.z;\}\n      writepixel(_position.x,_position.y, color,1,1.0f); //OutputSample\n  \}\n\n\}\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nvoid facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x+1,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos,V0_N,V1_N,V2_N;\n    float2 V0_ST,V1_ST,V2_ST;\n    float4 V1_Sample,V2_Sample;\n    float4 _tn;\n    float3 normal0,normal1,normal2;\n    float2 UV_Format = float2(Vformat.x,Vformat.y);\n\n\n    int2 P0 = int2(pos.x-1,pos.y-1);\n    int2 P1 = int2(pos.x+1,pos.y+1);\n    if (_plexConnectX && pos.x == int(Vformat.x))\{\n      insideX == true;\n      P1 = int2(0.0f,pos.y+1);\n    \}\n    if (_plexConnectY && pos.y == int(Vformat.y))\{\n      insideYtop == true;\n      P1 = int2(pos.x+1,0);\n    \} \n\n    if (_plexConnectY && pos.y == 0)\{\n      insideY == true;\n      P0 = int2(pos.x-1,int(UV_Format.y));\n    \} \n\n    if (!_flatshading) \{\n      _tn = normals(pos.x,pos.y);\n      V0_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n    V0_ST = float2(pos.x,pos.y)/UV_Format;\n\n  if (insideX) \{\n    V2_Sample = ppos(P1.x,pos.y);\n    V2_ST = float2(P1.x,pos.y)/UV_Format;\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (!_flatshading) \{\n      _tn = normals(P1.x,pos.y);\n      V2_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n        \n\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(P1.x,P0.y);\n        V1_ST = float2(P1.x,P0.y)/UV_Format;\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(P1.x,P0.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}\n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V2_Pos,V1_Pos,_vWorld,V2_wPos,V1_wPos,V0_N,V2_N,V1_N,V0_ST,V2_ST,V1_ST);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,P1.y);\n        V1_ST = float2(pos.x,P1.y)/UV_Format;        \n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(pos.x,P1.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}        \n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V1_Pos,V2_Pos,_vWorld,V1_wPos,V2_wPos,V0_N,V1_N,V2_N,V0_ST,V1_ST,V2_ST);\n        \}\n      \}\n    \}\n  \}\n\}\n\n\n\n//This function will calculate if pixel C is inside the triangle\nfloat edgeFunction(float3 a, float3 b, float3 c) \n\{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n\} \n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat Distance(float3 _a,float3 _b)\n\{\n          float xd = _a.x - _b.x;\n          float yd = _a.y - _b.y;\n          float zd = _a.z - _b.z;\n          return sqrt(xd*xd + yd*yd + zd*zd);\n\}\n\nvoid DrawTriangle(float3 V0, float3 V1, float3 V2,float3 WP0, float3 WP1, float3 WP2,float3 N0, float3 N1, float3 N2, float2 st0,float2 st1,float2 st2) \{\n\n  // Precompute reciprocal of vertex z-coordinate \n  V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n\n  float2 st0n = st0 * V0.z;\n  float2 st1n = st1 * V1.z; \n  float2 st2n = st2 * V2.z; //Normal version of ST\n\n  bool inside; \n  float X0 = Fmin(V0.x,V1.x,V2.x)-1.0f;\n  float X1 = Fmax(V0.x,V1.x,V2.x)+1.0f;\n  float Y0 = Fmin(V0.y,V1.y,V2.y)-1.0f;\n  float Y1 = Fmax(V0.y,V1.y,V2.y)+1.0f;\n  float area = edgeFunction(V2, V1, V0);\n\n\n  float2 sampos = float2(st0.x*float(Vformat.x),st0.y*float(Vformat.y));\n  float4 text0 = src(sampos.x,sampos.y);\n  sampos = float2(st1.x*float(Vformat.x),st1.y*float(Vformat.y));\n  float4 text1 = src(sampos.x,sampos.y);\n  sampos = float2(st2.x*float(Vformat.x),st2.y*float(Vformat.y));  //Why do we have to do this? =(\n  float4 text2 = src(sampos.x,sampos.y);\n  sampos = float2(min(min(st0.x,st1.x),st2.x)*float(Vformat.x),min(min(st0.y,st1.y),st2.y)*float(Vformat.y));\n  float4 text3 = src(sampos.x,sampos.y);\n\n\n  for( int x = X0; x < X1 ; x++) \{\n    for( int y = Y0; y < Y1 ; y++) \{\n      float3 pixelSample(x + _texoffset.x, y + _texoffset.y,0.0f); \n\n      //This is the part where we test if the current pixel is inside the triangle\n      //We check both for front facing and back faing options\n      float w0 = edgeFunction(V1, V0, pixelSample); //Front Facing\n      float w1 = edgeFunction(V2, V1, pixelSample); \n      float w2 = edgeFunction(V0, V2, pixelSample); \n      float w3 = edgeFunction(V0, V1, pixelSample); //Back Facing\n      float w4 = edgeFunction(V1, V2, pixelSample); \n      float w5 = edgeFunction(V2, V0, pixelSample);\n\n      //writepixel(x,y, float4(w1),1,1.0f);\n      if ((w0 >= 0 && w1 >= 0 && w2 >= 0 && _frontfacing) || (w3 >= 0 && w4 >= 0 && w5 >= 0 && _backfacing)) \{ //The curent pixel is inside the triangle\n\n       // calculate vectors from point f to vertices p1, p2 and p3:\n       float3 f1 = V0-pixelSample;\n       float3 f2 = V1-pixelSample;\n       float3 f3 = V2-pixelSample;\n       // calculate the areas and factors (order of parameters doesn't matter):\n       float a = length(cross(V0-V1,V0-V2 )); // main triangle area a\n       area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n        w0 /= area; \n        w1 /= area; \n        w2 /= area; \n\n        w3 /= area; \n        w4 /= area; \n        w5 /= area; \n\n       float a1 = length(cross(f2, f3)) / a; // p1's triangle area / a\n       float a2 = length(cross(f3, f1)) / a; // p2's triangle area / a \n       float a3 = length(cross(f1, f2)) / a; // p3's triangle area / a\n       float a_magnitude = a1+a2+a3;\n       a1 = a1/a_magnitude;\n       a2 = a2/a_magnitude;\n       a3 = a3/a_magnitude;\n       float z = 1.0f / (V0.z * a1 + V1.z * a2 + V2.z * a3); \n\n\n        // find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):\n        float2 uv = st0 * a1 + st1 * a2 + st2 * a3;\n        float2 st = st0 * w0 + st1 * w1 + st2 * w2; \n        st *= z;      \n\n\n        //Calculate normals. Eighter we have flat shading, else we calculate a normal per pixel\n        float3 normalB;\n        if (_flatshading) \{\n          normalB = CalculateSurfaceNormals(WP0,WP1,WP2);\n\n        \}\n        else \{\n          float3 c0 = N2/float3(V0.z); \n          float3 c1 = N0/float3(V1.z); \n          float3 c2 = N1/float3(V2.z);  \n\n          normalB.x = w0 * c0.x + w1 * c1.x + w2 * c2.x; \n          normalB.y = w0 * c0.y + w1 * c1.y + w2 * c2.y; \n          normalB.z = w0 * c0.z + w1 * c1.z + w2 * c2.z; \n\n          normalB.x *= z, normalB.y *= z, normalB.z *= z; \n        \}\n        normalB = normalize(normalB);\n\n        //CALCULATE THE OBJECT TEXTURE COORDINATES\n        float zn = 1.0f / (V0.z * w0 + V1.z * w1 + V2.z * w2); \n        st = st0n * w0 + st1n * w1 + st2n * w2; \n        st *= zn;   \n        //--END \n\n        float3 Wpos = WP0*a1 + WP1*a2 + WP2*a3; //World Position.\n        float3 ViewNormal = normalize(float3(cameraToWorld\[3]\[0],cameraToWorld\[3]\[1],cameraToWorld\[3]\[2])-Wpos);\n\n        float nDotView =  dot(normalB,ViewNormal);\n        nDotView = 1.0f-fabs(nDotView); //make sure that the view normal ramps back around when doing backface\n        float4 tempout;\n\n        //Flatshading or regular?\n        if (!_flatshading) \{\n          tempout = text0 * a1 + text1 * a2 + text2 * a3; \n        \}\n        else\{\n          tempout = text3;\n        \}\n\n        //Additional Render Modes\n        if (_vertexMode == 1)\{\n          tempout = float4(a1,a2,a3,1.0f);\n        \}\n        else if (_vertexMode == 2)\{\n          tempout = float4(normalB.x,normalB.y,normalB.z,1.0f);\n        \}\n        else if (_vertexMode == 3)\{\n          tempout = float4(nDotView,nDotView,nDotView,1.0f);\n        \}\n        else if (_vertexMode == 4)\{\n          tempout = float4(uv.x,uv.y,0.0f,1.0f);\n        \}       \n        else if (_vertexMode == 5)\{\n          tempout = float4(st.x,st.y,0.0f,1.0f);\n        \}               \n        else if (_vertexMode == 6)\{\n          tempout = float4(ViewNormal.x,ViewNormal.y,ViewNormal.z,1.0f);\n        \}             \n        else if (_vertexMode == 7)\{\n          tempout = float4(Wpos.x,Wpos.y,Wpos.z,1.0f);\n        \}   \n\n        if (_depthBuffer)\{\n          writepixel(x,y, float4(tempout.x,tempout.y,tempout.z,z),1,1.0f);  \n        \}\n        else \{\n          if (_dof_enable)\{\n            Bokeh(float3(x,y,z),float4(tempout.x,tempout.y,tempout.z,z));\n          \}\n          else \{\n            bilinear_Plot(float2(x,y),float4(tempout.x,tempout.y,tempout.z,z),1);\n          \}\n        \}\n\n      \}  \n\n    \}\n  \}\n\}\n\n//-------------------------------------\n// Wire_Render\n//-------------------------------------\nvoid wire_render(int2 pos) \{\n  float4 temp = float4(0.0f,0.0f,0.0f,FLT_MAX);\n  float4 wire_ref_sample;\n  int2 tempXY = int2(0,0);\n  float4 plexlist\[11] = \{temp,temp,temp,temp,temp,temp,temp,temp,temp,temp,temp\}; \n  int2 plexlistXY\[11] = \{tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY\};\n  int plex_count = 0; //We use this to figure how many points that should connect.\n  float plex_dist;\n  float3 plex_position,plex_position_b;\n  float4 temp_pos, temp_pos_b; //Temporary Position Containers\n  if (_maxPlexType == -1) \{ //Used for random connection types\n    for( int x = 0; x < max_line_connections ; x++)\{ //THIS 80 NUMBER IS THE LIMIT TO AVOID TOO SLOW PROCESSING!\n      for( int y = 0; y < max_line_connections ; y++)\{\n        wire_ref_sample = ppos(x,y);\n        if (wire_ref_sample.w != 0.0f && pos.x!=x && pos.y != y) \{ \n          plex_position = float3(wire_ref_sample.x,wire_ref_sample.y,wire_ref_sample.z)*(zoom);\n          float xd = plex_position.x - vWorld.x;\n          float yd = plex_position.y - vWorld.y;\n          float zd = plex_position.z - vWorld.z;\n          float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n          if (plex_dist<_maxPlexDistance)\{\n            plex_count = min(10,plex_count+1); //Add one to the count\n            for( int h = 0; h < plex_count+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n              if (plex_dist < plexlist\[h].w) \{                  \n                for( int i = plex_count+1; i > h ; i--) \{\n                  plexlist\[i] = plexlist\[i-1];\n                  plexlistXY\[i] = plexlistXY\[i-1];\n                \}\n                plexlist\[h] = float4(plex_position.x,plex_position.y,plex_position.z,plex_dist);\n                plexlistXY\[h] = int2(x,y);\n                break;        \n              \}\n            \}\n          \} \n        \}\n      \}\n    \}\n  \}\n  else\{ //Used for standard connection types\n    float4 temp_pos;\n    bool insideX = !(Vformat.x < pos.x+1);\n    bool insideY = !(Vformat.y < pos.y+1);\n\n\n    if (!_plexLinedefAUX)\{\n      temp_pos = normals(pos.x,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,vWorld+plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideX && !_plexLinedefX) \{\n      temp_pos = ppos(pos.x+1,pos.y );\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && !_plexLinedefX) \{\n      temp_pos = ppos(0,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideY && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\}                          \n    \}\n    else if ( _plexConnectY  && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,0);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    //_plexConnect\n    if ( insideX && insideY && !_plexLinedefXY) \{              \n      temp_pos = ppos(pos.x+1,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && _plexConnectY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && insideY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectY && insideX && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n  \}   \n\n  //now that all the connections have been sorted by distance then we connect the dots.\n  for( int x = 0; x < min(_maxPlexConnections,plex_count) ; x++)\{\n    plex_position = float3(plexlist\[x].x,plexlist\[x].y,plexlist\[x].z);\n    plex_dist = plexlist\[x].w;\n\n\n    float plex_distribution = 1.0f-((plexlist\[x].w-plexlist\[0].w)/((plexlist\[min(_maxPlexConnections,plex_count)].w-plexlist\[0].w)+0.00001f)); //Where does it lie between the best and the worst distance?\n    //plexlistXY\n\n    float4 plex_col = float4(pow(1.0f-(plex_dist/_maxPlexDistance),1.0f/_plex_gamma))*float4(plex_distribution); //This one is quite cool aswell, but does leave the center ones a bit too focused \n    float4 plex_colorA = src(pos.x,pos.y);\n    float4 plex_colorB = src( plexlistXY\[x].x,plexlistXY\[x].y);\n    plex_col *= 0.1f;\n\n    computePixelCoordinates(plex_position, pRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n    if (dst.bounds.inside(int(vRaster.x),int(vRaster.y)) || dst.bounds.inside(int(pRaster.x),int(pRaster.y)))\{\n        DrawLine(vRaster,pRaster,(plex_colorA*plex_col)*_lineInMultiplier,(plex_colorB*plex_col)*_lineOutMultiplier);\n    \}\n  \}\n\}\n\nvoid wire_connection(float3 p_source,float3 p_target, float4 (&p_plexlist)\[11], int2 (&p_plexlistXY)\[11],int &p_plexcount,int2 position) \{\n  float xd = p_target.x - p_source.x;\n  float yd = p_target.y - p_source.y;\n  float zd = p_target.z - p_source.z;\n  float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n  if (plex_dist<_maxPlexDistance)\{\n    p_plexcount = min(11,p_plexcount+1); //Add one to the count\n    for( int h = 0; h < p_plexcount+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n      if (plex_dist < p_plexlist\[h].w) \{                  \n        for( int i = p_plexcount+1; i > h ; i--) \{\n          p_plexlist\[i] = p_plexlist\[i-1];\n          p_plexlistXY\[i] = p_plexlistXY\[i-1];\n        \}\n        p_plexlist\[h] = float4(p_target.x,p_target.y,p_target.z,plex_dist);\n        p_plexlistXY\[h] = int2(position.x,position.y);\n        break;        \n      \}\n    \}  \n  \}\n\}\n//-------END OF WIRE RENDER FUNCTIONS---------\n\n\n\n\n//-------------------------------\n//-------BOKEH FUNCTIONS---------\n//thanks to: http://devlog-martinsh.blogspot.dk/2011/11/glsl-depth-of-field-with-bokeh-v21.html\nfloat2 rand(float2 coord) //generating noise/pattern texture for dithering\n\{\n  float noiseX = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.25)+(Frac(coord.y*(WHformat\[1]/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.75)+(Frac(coord.y*(WHformat\[1]/2.0))*0.25))*2.0-1.0;\n  noiseX = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f))) * 43758.5453f),0.0f,1.0f)*2.0f-1.0f;\n  noiseY = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f)*2.0f)) * 43758.5453f),0.0f,1.0f)*2.0-1.0f;\n  return float2(noiseX,noiseY);\n\}\n//-------------------------------------\n// Bokeh\n//-------------------------------------\nvoid Bokeh(float3 pos,float4 color)\{\n  float blur = 0.0;\n  blur = clamp((fabs(pos.z - focalDepth)/_depthOfField)*100.0f,-_maxDofSize,_maxDofSize);\n  \n  float w = (1.0/WHformat.x)*blur;//+noise.x;\n  float h = (1.0/(WHformat.x*dof_aspect))*blur;//+noise.y;\n  float3 v3_col = float3(color.x,color.y,color.z);\n  int ringsamples;\n  float s = 1.0;  \n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples; \n    for (int j = 0 ; j < ringsamples ; j += 1)  \n    \{ \n      s += (1.0f*mix(1.0f,(float(i))/(float(_dof_rings)),dof_bias)*1.0f); //No need to do this in the loop\n    \}\n  \}\n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples;\n     \n    for (int j = 0 ; j < ringsamples ; j += 1)   \n    \{\n      float step = PI*2.0 / float(ringsamples);\n      float pw = (cos(float(j)*step)*(float(i)/_dof_rings));\n      float ph = (sin(float(j)*step)*(float(i)/_dof_rings));\n      float p = 1.0;\n\n      float posx = pos.x+((pw*w)*blur);\n      float posy = pos.y+((ph*h)*blur);\n\n\n      float3 lumcoeff = float3(0.299,0.587,0.114);\n      float lum = dot(v3_col, lumcoeff);\n      float thresh = max((lum-dof_threshold)*dof_gain, 0.0f);\n      v3_col+mix(float3(0.0),v3_col,thresh*blur);\n\n      float3 col = (v3_col*mix(1.0,(float(i))/(float(_dof_rings)),dof_bias)*p)/s; \n      bilinear_Plot(float2(posx,posy),float4(col.x,col.y,col.z,color.w/(_dof_rings*_dof_rings)),1);\n    \}\n  \}\n\}\n//-------END OF BOKEH FUNCTIONS---------\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float2 posf = float2(pos.x,pos.y);\n\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n\n      //Convert worldspace coordinates to screenspcace coordinates.\n      vWorld = float3(_sample.x,_sample.y,_sample.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, vRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      if (ret) \{ //Only create points that are visible on screen\n        if (_pointRender)\{\n          point_render(pos,vRaster);\n        \}\n      \} //Pointrender over\n\n      if (_wireRender && _maxPlexConnections>=1) \{\n        if (max(pos.x,pos.y)<=max_line_connections || (_maxPlexType==0))\{ // Don't process more wires than allowed in nearest mode.\n          wire_render(pos);\n        \}\n      \} //WireRender over\n\n      if (_facetRender) \{\n        facet_render(pos,float3(_sample.x,_sample.y,_sample.z));\n      \}  //FacetRender over\n      \n    \}\n  \} //----> process\n\};\n"
  useGPUIfAvailable false
  rebuild ""
  PointRender3D_cam_Matrix {
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
    }
  PointRender3D_focallength {{parent.Camera1.focal}}
  PointRender3D_hapeture {{parent.Camera1.haperture}}
  PointRender3D_format {{!proxy?Settings_Format.width:Settings_Format.width*proxy_scale} {!proxy?Settings_Format.height:Settings_Format.height*proxy_scale}}
  PointRender3D_vertexformat {{parent.InputFormat.box.r-1} {parent.InputFormat.box.t-1}}
  PointRender3D__alphaMultiplier {{parent.AlphaMultiplier}}
  PointRender3D__pointRender {{parent.RenderMode==0}}
  PointRender3D__wireRender {{parent.RenderMode==1}}
  PointRender3D__facetRender {{parent.RenderMode==2}}
  PointRender3D__maxLDistance {{parent.wire_maxdistance}}
  PointRender3D__maxLConnections {{parent.wire_connections}}
  PointRender3D__maxPlexType {{-parent.wire_type}}
  PointRender3D__plexLinedefXY {{!parent.connect_xy}}
  PointRender3D__plexLinedefX {{!parent.connect_x}}
  PointRender3D__plexLinedefY {{!parent.connect_y}}
  PointRender3D__plexLinedefAUX {{!connect_aux}}
  PointRender3D__plexConnectX {{parent.CloseX}}
  PointRender3D__plexConnectY {{parent.CloseY}}
  PointRender3D__L_gamma {{parent.wire_Threshold}}
  "PointRender3D_Enable Depth of Field" {{parent.dof_enable}}
  PointRender3D_samples {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_rings {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_focalDepth {{parent.dof_focaldepth}}
  PointRender3D__depthOfField {{parent.dof_dof}}
  PointRender3D__depthMult 0
  PointRender3D__maxDofSize {{parent.dof_maxSize*400}}
  PointRender3D_dof_aspect {{parent.dof_Aspect}}
  PointRender3D_dof_bias {{parent.dof_bias}}
  PointRender3D__flatshading {{parent.facet_flatShading}}
  PointRender3D__backfacing {{parent.facet_backface}}
  PointRender3D__frontfacing {{parent.facet_front}}
  PointRender3D__vertexMode {{parent.renderMode}}
  PointRender3D__texoffset {-0.5 0.5}
  PointRender3D__pointSize 0
  PointRender3D__depthOcclusion {{parent.UseOcclusionMap}}
  PointRender3D__maxLineSteps {{parent.maxSamples}}
  PointRender3D__lineOffset {{parent.lineoffset}}
  PointRender3D__lineInMultiplier {{parent.inGain}}
  PointRender3D__lineOutMultiplier {{parent.outGain}}
  PointRender3D__overscan {{parent.overscan} {parent.overscan}}
  PointRender3D_isDepth true
  format "1280 720 0 0 1280 720 1 HD_720"
  rebuild_finalise ""
  name BlinkScriptZdepth
  label Zdepth
  xpos -28
  ypos 100
 }
 Dot {
  name Dot10
  xpos 97
  ypos 112
 }
 TimeBlur {
  divisions {{parent.Samples}}
  shutter {{parent.Shutter}}
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur1
  xpos 63
  ypos 300
  disable {{1-parent.mb_enable x89 0}}
 }
 Expression {
  expr3 a!=0?a/r:0
  name Expression3
  selected true
  xpos 63
  ypos 324
 }
 Dot {
  name Dot9
  xpos 97
  ypos 414
 }
push $N1cc86ba0
push $N1cd4ee60
push $N1cd8b1e0
push $N1ccd7850
 BlinkScript {
  inputs 4
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Render/3D_PointRender_v17.cpp
  recompileCount 803
  ProgramGroup 1
  KernelDescription "2 \"PointRender3D\" iterate pixelWise 0c100cf8a634aa2c2e18f544ec8abfd6d5d138cc25ae8f7d7127230910c2e91f 5 \"ppos\" Read Random \"src\" Read Random \"normals\" Read Random \"occlusion\" Read Random \"dst\" Write Random 49 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"vertexformat\" Int 2 CgAAAAoAAAA= \"Zoom\" Float 1 AACAPw== \"Filtering Method\" Int 1 AQAAAA== \"_alphaMultiplier\" Float 1 AACAPw== \"_pointRender\" Bool 1 AQ== \"_wireRender\" Bool 1 AQ== \"_facetRender\" Bool 1 AQ== \"_maxLDistance\" Float 1 AACAPw== \"_maxLConnections\" Int 1 AQAAAA== \"_maxPlexType\" Int 1 AAAAAA== \"_plexLinedefXY\" Bool 1 AA== \"_plexLinedefX\" Bool 1 AA== \"_plexLinedefY\" Bool 1 AA== \"_plexLinedefXtoY\" Bool 1 AA== \"_plexLinedefAUX\" Bool 1 AA== \"_plexConnectX\" Bool 1 AA== \"_plexConnectY\" Bool 1 AA== \"_L_gamma\" Float 1 AACAPw== \"Enable Depth of Field\" Bool 1 AA== \"samples\" Int 1 AwAAAA== \"rings\" Int 1 BQAAAA== \"focalDepth\" Float 1 AACAPw== \"_depthOfField\" Float 1 AACAQA== \"_depthMult\" Float 1 zczMPQ== \"_maxDofSize\" Float 1 AAAAQQ== \"dof_aspect\" Float 1 AACAPw== \"dof_threshold\" Float 1 AACAPw== \"dof_gain\" Float 1 AAAAAA== \"dof_bias\" Float 1 AAAAwA== \"dof_fringe\" Float 1 AAAAAA== \"_flatshading\" Bool 1 AQ== \"_backfacing\" Bool 1 AQ== \"_frontfacing\" Bool 1 AQ== \"_vertexMode\" Int 1 AAAAAA== \"_depthBuffer\" Bool 1 AQ== \"_texoffset\" Float 2 AAAAPwAAAD8= \"_pointSize\" Int 1 AQAAAA== \"_gaussigma\" Float 1 AACAPw== \"_depthOcclusion\" Bool 1 AQ== \"depthMultiplier\" Float 1 AACAPw== \"_maxLineSteps\" Float 1 AAB6RQ== \"_lineOffset\" Float 1 AACAPw== \"_lineInMultiplier\" Float 1 AACAPw== \"_lineOutMultiplier\" Float 1 AACAPw== \"_overscan\" Float 2 AAAAAAAAAAA= 49 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"Vformat\" 2 1 \"zoom\" 1 1 \"_filtering\" 1 1 \"_alphaMultiplier\" 1 1 \"_pointRender\" 1 1 \"_wireRender\" 1 1 \"_facetRender\" 1 1 \"_maxPlexDistance\" 1 1 \"_maxPlexConnections\" 1 1 \"_maxPlexType\" 1 1 \"_plexLinedefXY\" 1 1 \"_plexLinedefX\" 1 1 \"_plexLinedefY\" 1 1 \"_plexLinedefXtoY\" 1 1 \"_plexLinedefAUX\" 1 1 \"_plexConnectX\" 1 1 \"_plexConnectY\" 1 1 \"_plex_gamma\" 1 1 \"_dof_enable\" 1 1 \"_dof_samples\" 1 1 \"_dof_rings\" 1 1 \"focalDepth\" 1 1 \"_depthOfField\" 1 1 \"_depthMult\" 1 1 \"_maxDofSize\" 1 1 \"dof_aspect\" 1 1 \"dof_threshold\" 1 1 \"dof_gain\" 1 1 \"dof_bias\" 1 1 \"dof_fringe\" 1 1 \"_flatshading\" 1 1 \"_backfacing\" 1 1 \"_frontfacing\" 1 1 \"_vertexMode\" 1 1 \"_depthBuffer\" 1 1 \"_texoffset\" 2 1 \"_pointSize\" 1 1 \"_gaussigma\" 1 1 \"_depthOcclusion\" 1 1 \"depthMultiplier\" 1 1 \"_maxLineSteps\" 1 1 \"_lineOffset\" 1 1 \"_lineInMultiplier\" 1 1 \"_lineOutMultiplier\" 1 1 \"_overscan\" 2 1 10 \"max_line_connections\" Int 1 1 AAAAAA== \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "//Some basic generic functions.\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float3 Cross(float3 A,float3 B)\n\{\n    return float3(A.y*B.z - A.z*B.y,A.z*B.x - A.x*B.z,A.x*B.y - A.y*B.x);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}     \n\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\ninline float mix(float _X,float _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}                                                                                              \n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n\n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight,\n    float2 overscan\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f-overscan.x || pRaster.x > imageWidth+overscan.x || \n       pRaster.y < 0.0f-overscan.y || pRaster.y > imageHeight+overscan.y || pRaster.z < 0.0f) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eRead, eAccessRandom, eEdgeClamped> src;     //The texture map\n  Image<eRead, eAccessRandom, eEdgeClamped> normals;     //The texture map  \n  Image<eRead, eAccessRandom, eEdgeClamped> occlusion;     //The texture map \n  Image<eWrite, eAccessRandom> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat,Vformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    int _filtering;        //Filter method\n    float _alphaMultiplier; //Additive multiplier\n    bool _pointRender,_wireRender,_facetRender;\n    float _maxPlexDistance; //Additive multiplier\n    int _maxPlexConnections;\n    int _maxPlexType; // 0==Grid, -1==Nearest\n    bool _plexLinedefXY,_plexLinedefX,_plexLinedefY,_plexLinedefXtoY,_plexLinedefAUX; // Define what connections NOT to include\n    bool _plexConnectX,_plexConnectY; //Connect from the edge of x to 0, or edge of y to 0, usually for spheres\n    float _plex_gamma; //The threshold making shorter paths bright and longer paths dark\n    bool _dof_enable; // Enable DOF\n    int _dof_samples; // How many samples per DOF ring\n    int _dof_rings; // How many rings \n    float focalDepth,_depthOfField,_depthMult,_maxDofSize; //DOF Settings\n    float dof_aspect; //Pixel aspect ratio\n    float dof_threshold;\n    float dof_gain;\n    float dof_bias; //bokeh edge bias\n    float dof_fringe; //bokeh chromatic aberration/fringing\n    bool _flatshading,_backfacing,_frontfacing; //Vertex rendering settings\n    int _vertexMode;  //The rendering output mode, (think AOV)\n    bool _depthBuffer; //Non-additive, only render front most pixel\n    float2 _texoffset;\n    int _pointSize;\n    float _gaussigma;\n    bool _depthOcclusion;\n    float depthMultiplier;\n    float _maxLineSteps; //cap the line length to avoid process lock\n    float _lineOffset; //Alow you to shrink or extend the lines\n    float _lineInMultiplier,_lineOutMultiplier; //Control the brightness of the wires at the tips.\n    float2 _overscan; //This will allow you to render some extra outside the bounds of the image.\n\n  local: //Local variables\n    int max_line_connections;\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(Vformat,      \"vertexformat\", int2(10,10));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(_filtering, \"Filtering Method\", 1); \n    defineParam(_alphaMultiplier, \"_alphaMultiplier\", 1.0f);     \n    defineParam(_pointRender, \"_pointRender\", true);  \n    defineParam(_wireRender, \"_wireRender\", true);\n    defineParam(_facetRender, \"_facetRender\", true);\n    defineParam(_maxPlexDistance, \"_maxLDistance\", 1.0f);    \n    defineParam(_maxPlexConnections, \"_maxLConnections\", 1);    \n    defineParam(_maxPlexType, \"_maxPlexType\", 0); \n    defineParam(_plexLinedefXY, \"_plexLinedefXY\", false);      \n    defineParam(_plexLinedefXtoY, \"_plexLinedefXtoY\", false); //NYI\n    defineParam(_plexLinedefAUX, \"_plexLinedefAUX\", false); \n    defineParam(_plexLinedefX, \"_plexLinedefX\", false);  \n    defineParam(_plexLinedefY, \"_plexLinedefY\", false);  \n    defineParam(_plexConnectX, \"_plexConnectX\", false);      \n    defineParam(_plexConnectY, \"_plexConnectY\", false);   \n    defineParam(_plex_gamma, \"_L_gamma\", 1.0f);\n    //DOF SETTINGS   \n    defineParam(_dof_enable, \"Enable Depth of Field\", false);   \n    defineParam(_dof_samples, \"samples\", 3);    \n    defineParam(_dof_rings, \"rings\", 5);   \n    defineParam(focalDepth, \"focalDepth\", 1.0f);  \n    defineParam(_depthOfField, \"_depthOfField\", 4.0f);  \n    defineParam(_depthMult, \"_depthMult\", 0.1f);  \n    defineParam(_maxDofSize, \"_maxDofSize\", 8.0f);  \n    defineParam(dof_aspect, \"dof_aspect\", 1.0f);  \n    defineParam(dof_threshold, \"dof_threshold\", 1.0f);  \n    defineParam(dof_gain, \"dof_gain\", 0.0f);  \n    defineParam(dof_bias, \"dof_bias\", -2.0f);  \n    defineParam(dof_fringe, \"dof_fringe\", 0.0f); \n    //SHADING SETTINGS \n    defineParam(_flatshading, \"_flatshading\", true);  \n    defineParam(_vertexMode, \"_vertexMode\", 0);  \n    defineParam(_backfacing, \"_backfacing\", true);    \n    defineParam(_frontfacing, \"_frontfacing\", true);        \n    defineParam(_depthBuffer, \"_depthBuffer\", true);  \n    defineParam(_texoffset, \"_texoffset\", float2(0.5f,0.5f)); \n    defineParam(_pointSize, \"_pointSize\", 1); \n    defineParam(_gaussigma, \"_gaussigma\", 1.0f); \n    defineParam(_depthOcclusion, \"_depthOcclusion\", true); \n    defineParam(depthMultiplier, \"depthMultiplier\", 1.0f); \n    defineParam(_maxLineSteps, \"_maxLineSteps\", 4000.0f); \n    defineParam(_lineOffset, \"_lineOffset\", 1.0f); \n    defineParam(_lineInMultiplier, \"_lineInMultiplier\", 1.0f);   \n    defineParam(_lineOutMultiplier, \"_lineOutMultiplier\", 1.0f);     \n    defineParam(_overscan, \"_overscan\",float2(0.0f,0.0f));    \n\n  \}\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    max_line_connections = 80;\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n  \}\n\n  //Convert a 3d point position into a 2d raster position.\n  float3 Reconsile3D(float3 _PointPos)\{\n      vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      return tRaster;\n  \}\n\n//------------------------------\n//-------DRAW FUNCTIONS---------\n//------------------------------\n  //Write pixels to output.\n  void writepixel(float posx,float posy, float4 color,int index,float weight=1.0f)\n  \{ \n      if (_depthOcclusion)\{\n        float4 depthSample = occlusion(posx,posy);\n        if (depthSample.x<=vRaster.z && depthSample.w>0.0f)\{\n\n          float depth = (vRaster.z-depthSample.x);\n          color = color*(1.0f-depthSample.w);\n          color = color / (((depth*depth)*depthMultiplier)+1.0f);\n          //return;\n        \}\n      \}\n      float4 finalOutput; //This is used to store the final output\n      float4 dstSample; //This is used to store a sample of the destination\n      if ( dst.bounds.inside( posx, posy ) ) \{ //Test if the pixel written to is inside the output image. \n        if (_depthBuffer) \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          if ((dstSample.w>color.w)||dstSample.w==0.0f) \{\n            dst(posx,posy) = color;\n          \}\n        \}\n        else \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          finalOutput = dstSample + (color*_alphaMultiplier*weight);\n          finalOutput.w = dstSample.w + ((color.w*_alphaMultiplier*weight));\n\n          finalOutput.w = (dstSample.w + ((color.w*_alphaMultiplier*weight)))-(dstSample.w * ((color.w*_alphaMultiplier*weight)));\n\n          dst(posx,posy) = finalOutput;\n        \}\n      \} \n  \}\n\n  //Calculate a Bilinear Plot\n  void bilinear_Plot(float2 temppos,float4 color,int index)\n  \{\n    float2 p;\n    p.x=Frac(temppos.x);\n    p.y=Frac(temppos.y);\n    float weights\[] = \{(1.0f-p.x)*(1.0f-p.y), p.x*(1.0f-p.y), (1.0f-p.x)*p.y, p.x*p.y\};\n    int2 _position = int2(floor(temppos.x)-0,floor(temppos.y)-0); \n    writepixel(_position.x,_position.y,color,index,weights\[0]);\n    writepixel(_position.x+1,_position.y,color,index,weights\[1]);\n    writepixel(_position.x,_position.y+1,color,index,weights\[2]);\n    writepixel(_position.x+1,_position.y+1,color,index,weights\[3]);\n  \}\n\n  //NYI, unused!\n  void gaussian(float2 temppos,float4 color,int index)\{\n    float in_x = temppos.x;\n    float in_y = temppos.y;\n    int kernelSize = (_pointSize+1)*2;\n    int subsize = (kernelSize /2)-1;\n    float gKernel\[64]\[64];\n    float sigma = _gaussigma;\n    float intSigma = float(_pointSize);\n    float r, s = intSigma * sigma * sigma;\n\n    float sum = 0.0f;\n\n    // generate 5x5 kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            r = float(sqrt(x*x + y*y));\n            gKernel\[x + subsize]\[y + subsize] = (exp(-(r*r)/s))/(3.141592654f * s);\n            sum += gKernel\[x + subsize]\[y + subsize];\n        \}\n    \}\n\n    // normalize the Kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            gKernel\[x + subsize]\[y + subsize] /= sum;\n            writepixel(in_x+x,in_y+y,color,index,gKernel\[x + subsize]\[y + subsize]);\n        \}\n    \}\n  \}\n\n//-------------------------------------\n// DrawLine\n// ----------\n// Draw a line between two points, \n// x,y being 2d screenspace pos and z being depth.\n//-------------------------------------\n  void DrawLine(float3 origin, float3 endpoint,float4 _colorA,float4 _colorB) \{\n    float4 _color;\n    float3 delta = origin-endpoint;\n    float3 curPoint = origin;\n    float mag = sqrt(delta.x*delta.x+delta.y*delta.y);\n    mag = min(mag,_maxLineSteps); //Lets not go crazy, we cap it at 10.000 to avoid insane unwated processing time \n    for( float a = 0; a < mag*_lineOffset; a = a + 1.0f )\{\n      curPoint -= (delta/mag);\n      _color = (_colorA*(1.0f-(a/mag*1.0f)))+(_colorB*(a/mag*1.00f));\n      if (_dof_enable)\{\n        Bokeh(curPoint,_color);\n      \}\n      else \{\n        bilinear_Plot(float2(curPoint.x,curPoint.y),_color,1);\n      \}\n      \n    \}\n  \}\n\n//-------------------------------------\n// Point_Render\n//-------------------------------------\nvoid point_render(int2 pos, float3 screen_pos)\{\n  float4 color = src(pos.x,pos.y);\n\n  if (_filtering == 1)\{\n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        if (_depthBuffer) \{color.w = screen_pos.z;\} //Added\n        bilinear_Plot(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  /*\n  //THIS PART NEEDS TO BE RE-WRITTEN.\n  else if (_filtering == 2)\{ \n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        gaussian(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  */\n  else \{\n      int2 _position = int2(floor(screen_pos.x),floor(screen_pos.y)); \n      if (_depthBuffer) \{color.w = screen_pos.z;\}\n      writepixel(_position.x,_position.y, color,1,1.0f); //OutputSample\n  \}\n\n\}\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nvoid facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x+1,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos,V0_N,V1_N,V2_N;\n    float2 V0_ST,V1_ST,V2_ST;\n    float4 V1_Sample,V2_Sample;\n    float4 _tn;\n    float3 normal0,normal1,normal2;\n    float2 UV_Format = float2(Vformat.x,Vformat.y);\n\n\n    int2 P0 = int2(pos.x-1,pos.y-1);\n    int2 P1 = int2(pos.x+1,pos.y+1);\n    if (_plexConnectX && pos.x == int(Vformat.x))\{\n      insideX == true;\n      P1 = int2(0.0f,pos.y+1);\n    \}\n    if (_plexConnectY && pos.y == int(Vformat.y))\{\n      insideYtop == true;\n      P1 = int2(pos.x+1,0);\n    \} \n\n    if (_plexConnectY && pos.y == 0)\{\n      insideY == true;\n      P0 = int2(pos.x-1,int(UV_Format.y));\n    \} \n\n    if (!_flatshading) \{\n      _tn = normals(pos.x,pos.y);\n      V0_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n    V0_ST = float2(pos.x,pos.y)/UV_Format;\n\n  if (insideX) \{\n    V2_Sample = ppos(P1.x,pos.y);\n    V2_ST = float2(P1.x,pos.y)/UV_Format;\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (!_flatshading) \{\n      _tn = normals(P1.x,pos.y);\n      V2_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n        \n\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(P1.x,P0.y);\n        V1_ST = float2(P1.x,P0.y)/UV_Format;\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(P1.x,P0.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}\n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V2_Pos,V1_Pos,_vWorld,V2_wPos,V1_wPos,V0_N,V2_N,V1_N,V0_ST,V2_ST,V1_ST);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,P1.y);\n        V1_ST = float2(pos.x,P1.y)/UV_Format;        \n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(pos.x,P1.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}        \n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V1_Pos,V2_Pos,_vWorld,V1_wPos,V2_wPos,V0_N,V1_N,V2_N,V0_ST,V1_ST,V2_ST);\n        \}\n      \}\n    \}\n  \}\n\}\n\n\n\n//This function will calculate if pixel C is inside the triangle\nfloat edgeFunction(float3 a, float3 b, float3 c) \n\{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n\} \n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat Distance(float3 _a,float3 _b)\n\{\n          float xd = _a.x - _b.x;\n          float yd = _a.y - _b.y;\n          float zd = _a.z - _b.z;\n          return sqrt(xd*xd + yd*yd + zd*zd);\n\}\n\nvoid DrawTriangle(float3 V0, float3 V1, float3 V2,float3 WP0, float3 WP1, float3 WP2,float3 N0, float3 N1, float3 N2, float2 st0,float2 st1,float2 st2) \{\n\n  // Precompute reciprocal of vertex z-coordinate \n  V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n\n  float2 st0n = st0 * V0.z;\n  float2 st1n = st1 * V1.z; \n  float2 st2n = st2 * V2.z; //Normal version of ST\n\n  bool inside; \n  float X0 = Fmin(V0.x,V1.x,V2.x)-1.0f;\n  float X1 = Fmax(V0.x,V1.x,V2.x)+1.0f;\n  float Y0 = Fmin(V0.y,V1.y,V2.y)-1.0f;\n  float Y1 = Fmax(V0.y,V1.y,V2.y)+1.0f;\n  float area = edgeFunction(V2, V1, V0);\n\n\n  float2 sampos = float2(st0.x*float(Vformat.x),st0.y*float(Vformat.y));\n  float4 text0 = src(sampos.x,sampos.y);\n  sampos = float2(st1.x*float(Vformat.x),st1.y*float(Vformat.y));\n  float4 text1 = src(sampos.x,sampos.y);\n  sampos = float2(st2.x*float(Vformat.x),st2.y*float(Vformat.y));  //Why do we have to do this? =(\n  float4 text2 = src(sampos.x,sampos.y);\n  sampos = float2(min(min(st0.x,st1.x),st2.x)*float(Vformat.x),min(min(st0.y,st1.y),st2.y)*float(Vformat.y));\n  float4 text3 = src(sampos.x,sampos.y);\n\n\n  for( int x = X0; x < X1 ; x++) \{\n    for( int y = Y0; y < Y1 ; y++) \{\n      float3 pixelSample(x + _texoffset.x, y + _texoffset.y,0.0f); \n\n      //This is the part where we test if the current pixel is inside the triangle\n      //We check both for front facing and back faing options\n      float w0 = edgeFunction(V1, V0, pixelSample); //Front Facing\n      float w1 = edgeFunction(V2, V1, pixelSample); \n      float w2 = edgeFunction(V0, V2, pixelSample); \n      float w3 = edgeFunction(V0, V1, pixelSample); //Back Facing\n      float w4 = edgeFunction(V1, V2, pixelSample); \n      float w5 = edgeFunction(V2, V0, pixelSample);\n\n      //writepixel(x,y, float4(w1),1,1.0f);\n      if ((w0 >= 0 && w1 >= 0 && w2 >= 0 && _frontfacing) || (w3 >= 0 && w4 >= 0 && w5 >= 0 && _backfacing)) \{ //The curent pixel is inside the triangle\n\n       // calculate vectors from point f to vertices p1, p2 and p3:\n       float3 f1 = V0-pixelSample;\n       float3 f2 = V1-pixelSample;\n       float3 f3 = V2-pixelSample;\n       // calculate the areas and factors (order of parameters doesn't matter):\n       float a = length(cross(V0-V1,V0-V2 )); // main triangle area a\n       area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n        w0 /= area; \n        w1 /= area; \n        w2 /= area; \n\n        w3 /= area; \n        w4 /= area; \n        w5 /= area; \n\n       float a1 = length(cross(f2, f3)) / a; // p1's triangle area / a\n       float a2 = length(cross(f3, f1)) / a; // p2's triangle area / a \n       float a3 = length(cross(f1, f2)) / a; // p3's triangle area / a\n       float a_magnitude = a1+a2+a3;\n       a1 = a1/a_magnitude;\n       a2 = a2/a_magnitude;\n       a3 = a3/a_magnitude;\n       float z = 1.0f / (V0.z * a1 + V1.z * a2 + V2.z * a3); \n\n\n        // find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):\n        float2 uv = st0 * a1 + st1 * a2 + st2 * a3;\n        float2 st = st0 * w0 + st1 * w1 + st2 * w2; \n        st *= z;      \n\n\n        //Calculate normals. Eighter we have flat shading, else we calculate a normal per pixel\n        float3 normalB;\n        if (_flatshading) \{\n          normalB = CalculateSurfaceNormals(WP0,WP1,WP2);\n\n        \}\n        else \{\n          float3 c0 = N2/float3(V0.z); \n          float3 c1 = N0/float3(V1.z); \n          float3 c2 = N1/float3(V2.z);  \n\n          normalB.x = w0 * c0.x + w1 * c1.x + w2 * c2.x; \n          normalB.y = w0 * c0.y + w1 * c1.y + w2 * c2.y; \n          normalB.z = w0 * c0.z + w1 * c1.z + w2 * c2.z; \n\n          normalB.x *= z, normalB.y *= z, normalB.z *= z; \n        \}\n        normalB = normalize(normalB);\n\n        //CALCULATE THE OBJECT TEXTURE COORDINATES\n        float zn = 1.0f / (V0.z * w0 + V1.z * w1 + V2.z * w2); \n        st = st0n * w0 + st1n * w1 + st2n * w2; \n        st *= zn;   \n        //--END \n\n        float3 Wpos = WP0*a1 + WP1*a2 + WP2*a3; //World Position.\n        float3 ViewNormal = normalize(float3(cameraToWorld\[3]\[0],cameraToWorld\[3]\[1],cameraToWorld\[3]\[2])-Wpos);\n\n        float nDotView =  dot(normalB,ViewNormal);\n        nDotView = 1.0f-fabs(nDotView); //make sure that the view normal ramps back around when doing backface\n        float4 tempout;\n\n        //Flatshading or regular?\n        if (!_flatshading) \{\n          tempout = text0 * a1 + text1 * a2 + text2 * a3; \n        \}\n        else\{\n          tempout = text3;\n        \}\n\n        //Additional Render Modes\n        if (_vertexMode == 1)\{\n          tempout = float4(a1,a2,a3,1.0f);\n        \}\n        else if (_vertexMode == 2)\{\n          tempout = float4(normalB.x,normalB.y,normalB.z,1.0f);\n        \}\n        else if (_vertexMode == 3)\{\n          tempout = float4(nDotView,nDotView,nDotView,1.0f);\n        \}\n        else if (_vertexMode == 4)\{\n          tempout = float4(uv.x,uv.y,0.0f,1.0f);\n        \}       \n        else if (_vertexMode == 5)\{\n          tempout = float4(st.x,st.y,0.0f,1.0f);\n        \}               \n        else if (_vertexMode == 6)\{\n          tempout = float4(ViewNormal.x,ViewNormal.y,ViewNormal.z,1.0f);\n        \}             \n        else if (_vertexMode == 7)\{\n          tempout = float4(Wpos.x,Wpos.y,Wpos.z,1.0f);\n        \}   \n\n        if (_depthBuffer)\{\n          writepixel(x,y, float4(tempout.x,tempout.y,tempout.z,z),1,1.0f);  \n        \}\n        else \{\n          if (_dof_enable)\{\n            Bokeh(float3(x,y,z),float4(tempout.x,tempout.y,tempout.z,z));\n          \}\n          else \{\n            bilinear_Plot(float2(x,y),float4(tempout.x,tempout.y,tempout.z,z),1);\n          \}\n        \}\n\n      \}  \n\n    \}\n  \}\n\}\n\n//-------------------------------------\n// Wire_Render\n//-------------------------------------\nvoid wire_render(int2 pos) \{\n  float4 temp = float4(0.0f,0.0f,0.0f,FLT_MAX);\n  float4 wire_ref_sample;\n  int2 tempXY = int2(0,0);\n  float4 plexlist\[11] = \{temp,temp,temp,temp,temp,temp,temp,temp,temp,temp,temp\}; \n  int2 plexlistXY\[11] = \{tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY\};\n  int plex_count = 0; //We use this to figure how many points that should connect.\n  float plex_dist;\n  float3 plex_position,plex_position_b;\n  float4 temp_pos, temp_pos_b; //Temporary Position Containers\n  if (_maxPlexType == -1) \{ //Used for random connection types\n    for( int x = 0; x < max_line_connections ; x++)\{ //THIS 80 NUMBER IS THE LIMIT TO AVOID TOO SLOW PROCESSING!\n      for( int y = 0; y < max_line_connections ; y++)\{\n        wire_ref_sample = ppos(x,y);\n        if (wire_ref_sample.w != 0.0f && pos.x!=x && pos.y != y) \{ \n          plex_position = float3(wire_ref_sample.x,wire_ref_sample.y,wire_ref_sample.z)*(zoom);\n          float xd = plex_position.x - vWorld.x;\n          float yd = plex_position.y - vWorld.y;\n          float zd = plex_position.z - vWorld.z;\n          float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n          if (plex_dist<_maxPlexDistance)\{\n            plex_count = min(10,plex_count+1); //Add one to the count\n            for( int h = 0; h < plex_count+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n              if (plex_dist < plexlist\[h].w) \{                  \n                for( int i = plex_count+1; i > h ; i--) \{\n                  plexlist\[i] = plexlist\[i-1];\n                  plexlistXY\[i] = plexlistXY\[i-1];\n                \}\n                plexlist\[h] = float4(plex_position.x,plex_position.y,plex_position.z,plex_dist);\n                plexlistXY\[h] = int2(x,y);\n                break;        \n              \}\n            \}\n          \} \n        \}\n      \}\n    \}\n  \}\n  else\{ //Used for standard connection types\n    float4 temp_pos;\n    bool insideX = !(Vformat.x < pos.x+1);\n    bool insideY = !(Vformat.y < pos.y+1);\n\n\n    if (!_plexLinedefAUX)\{\n      temp_pos = normals(pos.x,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,vWorld+plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideX && !_plexLinedefX) \{\n      temp_pos = ppos(pos.x+1,pos.y );\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && !_plexLinedefX) \{\n      temp_pos = ppos(0,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideY && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\}                          \n    \}\n    else if ( _plexConnectY  && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,0);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    //_plexConnect\n    if ( insideX && insideY && !_plexLinedefXY) \{              \n      temp_pos = ppos(pos.x+1,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && _plexConnectY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && insideY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectY && insideX && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n  \}   \n\n  //now that all the connections have been sorted by distance then we connect the dots.\n  for( int x = 0; x < min(_maxPlexConnections,plex_count) ; x++)\{\n    plex_position = float3(plexlist\[x].x,plexlist\[x].y,plexlist\[x].z);\n    plex_dist = plexlist\[x].w;\n\n\n    float plex_distribution = 1.0f-((plexlist\[x].w-plexlist\[0].w)/((plexlist\[min(_maxPlexConnections,plex_count)].w-plexlist\[0].w)+0.00001f)); //Where does it lie between the best and the worst distance?\n    //plexlistXY\n\n    float4 plex_col = float4(pow(1.0f-(plex_dist/_maxPlexDistance),1.0f/_plex_gamma))*float4(plex_distribution); //This one is quite cool aswell, but does leave the center ones a bit too focused \n    float4 plex_colorA = src(pos.x,pos.y);\n    float4 plex_colorB = src( plexlistXY\[x].x,plexlistXY\[x].y);\n    plex_col *= 0.1f;\n\n    computePixelCoordinates(plex_position, pRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n    if (dst.bounds.inside(int(vRaster.x),int(vRaster.y)) || dst.bounds.inside(int(pRaster.x),int(pRaster.y)))\{\n        DrawLine(vRaster,pRaster,(plex_colorA*plex_col)*_lineInMultiplier,(plex_colorB*plex_col)*_lineOutMultiplier);\n    \}\n  \}\n\}\n\nvoid wire_connection(float3 p_source,float3 p_target, float4 (&p_plexlist)\[11], int2 (&p_plexlistXY)\[11],int &p_plexcount,int2 position) \{\n  float xd = p_target.x - p_source.x;\n  float yd = p_target.y - p_source.y;\n  float zd = p_target.z - p_source.z;\n  float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n  if (plex_dist<_maxPlexDistance)\{\n    p_plexcount = min(11,p_plexcount+1); //Add one to the count\n    for( int h = 0; h < p_plexcount+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n      if (plex_dist < p_plexlist\[h].w) \{                  \n        for( int i = p_plexcount+1; i > h ; i--) \{\n          p_plexlist\[i] = p_plexlist\[i-1];\n          p_plexlistXY\[i] = p_plexlistXY\[i-1];\n        \}\n        p_plexlist\[h] = float4(p_target.x,p_target.y,p_target.z,plex_dist);\n        p_plexlistXY\[h] = int2(position.x,position.y);\n        break;        \n      \}\n    \}  \n  \}\n\}\n//-------END OF WIRE RENDER FUNCTIONS---------\n\n\n\n\n//-------------------------------\n//-------BOKEH FUNCTIONS---------\n//thanks to: http://devlog-martinsh.blogspot.dk/2011/11/glsl-depth-of-field-with-bokeh-v21.html\nfloat2 rand(float2 coord) //generating noise/pattern texture for dithering\n\{\n  float noiseX = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.25)+(Frac(coord.y*(WHformat\[1]/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.75)+(Frac(coord.y*(WHformat\[1]/2.0))*0.25))*2.0-1.0;\n  noiseX = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f))) * 43758.5453f),0.0f,1.0f)*2.0f-1.0f;\n  noiseY = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f)*2.0f)) * 43758.5453f),0.0f,1.0f)*2.0-1.0f;\n  return float2(noiseX,noiseY);\n\}\n//-------------------------------------\n// Bokeh\n//-------------------------------------\nvoid Bokeh(float3 pos,float4 color)\{\n  float blur = 0.0;\n  blur = clamp((fabs(pos.z - focalDepth)/_depthOfField)*100.0f,-_maxDofSize,_maxDofSize);\n  \n  float w = (1.0/WHformat.x)*blur;//+noise.x;\n  float h = (1.0/(WHformat.x*dof_aspect))*blur;//+noise.y;\n  float3 v3_col = float3(color.x,color.y,color.z);\n  int ringsamples;\n  float s = 1.0;  \n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples; \n    for (int j = 0 ; j < ringsamples ; j += 1)  \n    \{ \n      s += (1.0f*mix(1.0f,(float(i))/(float(_dof_rings)),dof_bias)*1.0f); //No need to do this in the loop\n    \}\n  \}\n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples;\n     \n    for (int j = 0 ; j < ringsamples ; j += 1)   \n    \{\n      float step = PI*2.0 / float(ringsamples);\n      float pw = (cos(float(j)*step)*(float(i)/_dof_rings));\n      float ph = (sin(float(j)*step)*(float(i)/_dof_rings));\n      float p = 1.0;\n\n      float posx = pos.x+((pw*w)*blur);\n      float posy = pos.y+((ph*h)*blur);\n\n\n      float3 lumcoeff = float3(0.299,0.587,0.114);\n      float lum = dot(v3_col, lumcoeff);\n      float thresh = max((lum-dof_threshold)*dof_gain, 0.0f);\n      v3_col+mix(float3(0.0),v3_col,thresh*blur);\n\n      float3 col = (v3_col*mix(1.0,(float(i))/(float(_dof_rings)),dof_bias)*p)/s; \n      bilinear_Plot(float2(posx,posy),float4(col.x,col.y,col.z,color.w/(_dof_rings*_dof_rings)),1);\n    \}\n  \}\n\}\n//-------END OF BOKEH FUNCTIONS---------\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float2 posf = float2(pos.x,pos.y);\n\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n\n      //Convert worldspace coordinates to screenspcace coordinates.\n      vWorld = float3(_sample.x,_sample.y,_sample.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, vRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      if (ret) \{ //Only create points that are visible on screen\n        if (_pointRender)\{\n          point_render(pos,vRaster);\n        \}\n      \} //Pointrender over\n\n      if (_wireRender && _maxPlexConnections>=1) \{\n        if (max(pos.x,pos.y)<=max_line_connections || (_maxPlexType==0))\{ // Don't process more wires than allowed in nearest mode.\n          wire_render(pos);\n        \}\n      \} //WireRender over\n\n      if (_facetRender) \{\n        facet_render(pos,float3(_sample.x,_sample.y,_sample.z));\n      \}  //FacetRender over\n      \n    \}\n  \} //----> process\n\};\n"
  useGPUIfAvailable false
  rebuild ""
  PointRender3D_cam_Matrix {
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
    }
  PointRender3D_focallength {{parent.Camera1.focal}}
  PointRender3D_hapeture {{parent.Camera1.haperture}}
  PointRender3D_format {{!proxy?Settings_Format.width:Settings_Format.width*proxy_scale} {!proxy?Settings_Format.height:Settings_Format.height*proxy_scale}}
  PointRender3D_vertexformat {{parent.InputFormat.box.r-1} {parent.InputFormat.box.t-1}}
  PointRender3D__alphaMultiplier {{parent.AlphaMultiplier}}
  PointRender3D__pointRender {{parent.RenderMode==0}}
  PointRender3D__wireRender {{parent.RenderMode==1}}
  PointRender3D__facetRender {{parent.RenderMode==2}}
  PointRender3D__maxLDistance {{parent.wire_maxdistance}}
  PointRender3D__maxLConnections {{parent.wire_connections}}
  PointRender3D__maxPlexType {{-parent.wire_type}}
  PointRender3D__plexLinedefXY {{!parent.connect_xy}}
  PointRender3D__plexLinedefX {{!parent.connect_x}}
  PointRender3D__plexLinedefY {{!parent.connect_y}}
  PointRender3D__plexLinedefAUX {{!connect_aux}}
  PointRender3D__plexConnectX {{parent.CloseX}}
  PointRender3D__plexConnectY {{parent.CloseY}}
  PointRender3D__L_gamma {{parent.wire_Threshold}}
  "PointRender3D_Enable Depth of Field" {{parent.dof_enable}}
  PointRender3D_samples {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_rings {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_focalDepth {{parent.dof_focaldepth}}
  PointRender3D__depthOfField {{parent.dof_dof}}
  PointRender3D__depthMult 0
  PointRender3D__maxDofSize {{parent.dof_maxSize*400}}
  PointRender3D_dof_aspect {{parent.dof_Aspect}}
  PointRender3D_dof_bias {{parent.dof_bias}}
  PointRender3D__flatshading {{parent.facet_flatShading}}
  PointRender3D__backfacing {{parent.facet_backface}}
  PointRender3D__frontfacing {{parent.facet_front}}
  PointRender3D__vertexMode {{parent.renderMode}}
  PointRender3D__depthBuffer {{parent.facet_depth}}
  PointRender3D__texoffset {-0.5 0.5}
  PointRender3D__pointSize 0
  PointRender3D__depthOcclusion {{parent.UseOcclusionMap}}
  PointRender3D__maxLineSteps {{parent.maxSamples}}
  PointRender3D__lineOffset {{parent.lineoffset}}
  PointRender3D__lineInMultiplier {{parent.inGain}}
  PointRender3D__lineOutMultiplier {{parent.outGain}}
  PointRender3D__overscan {{parent.overscan} {parent.overscan}}
  format "1280 720 0 0 1280 720 1 HD_720"
  rebuild_finalise ""
  name BlinkScript1
  xpos -27
  ypos 159
 }
set N1ce436e0 [stack 0]
 TimeBlur {
  divisions {{parent.Samples}}
  shutter {{parent.Shutter}}
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur
  xpos -27
  ypos 301
  disable {{1-parent.mb_enable x89 0}}
 }
 ShuffleCopy {
  inputs 2
  alpha alpha2
  black alpha
  out2 depth
  name ShuffleCopy2
  xpos -27
  ypos 411
  disable {{!parent.OutputZdepth}}
 }
 CopyBBox {
  inputs 2
  name CopyBBox1
  xpos -27
  ypos 521
 }
 Reformat {
  format {{{Settings_Format.format}}}
  resize none
  center false
  pbb {{max(parent.overscan.w,parent.overscan.h)!=0}}
  name Reformat1
  xpos -27
  ypos 545
 }
 Group {
  name SoftLook
  xpos -27
  ypos 647
  disable {{!parent.HighlightCompression}}
  addUserKnob {20 User}
  addUserKnob {26 ""}
  addUserKnob {7 Add R 0 4}
  Add {{parent.HighlightCeiling}}
  addUserKnob {7 Offset R 0 4}
  Offset {{parent.Compression}}
 }
  Input {
   inputs 0
   name Input1
   xpos -248
   ypos 500
  }
set N1cedf5c0 [stack 0]
  Expression {
   expr0 r/(r+parent.Offset)*parent.Add
   expr1 g/(g+parent.Offset)*parent.Add
   expr2 b/(b+parent.Offset)*parent.Add
   expr3 a/(a+parent.Offset)*parent.Add
   name Expression1
   xpos -339
   ypos 576
  }
push $N1cedf5c0
  ShuffleCopy {
   inputs 2
   red red
   green green
   blue blue
   alpha alpha2
   name ShuffleCopy1
   xpos -248
   ypos 576
  }
  Output {
   name Output1
   xpos -248
   ypos 651
  }
 end_group
 ShuffleCopy {
  inputs 2
  in pos
  red red
  green green
  blue blue
  out pos
  name ShuffleCopy1
  xpos -27
  ypos 860
  disable true
 }
 Output {
  name Output1
  xpos -27
  ypos 897
 }
push $N1cd8b1e0
 PositionToPoints2 {
  display textured
  render_mode textured
  P_channel pos
  detail 0.25
  pointSize 0.6
  name PreviewNode
  xpos -22
  ypos 8
  disable {{!parent.Enable3DPreview}}
 }
push $N1cbc0dc0
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize none
  filter Impulse
  black_outside true
  name Reformat3
  xpos -633
  ypos -1109
  disable {{!wire_type==1}}
 }
push $N1cc053f0
push $N1cc25260
push $N1cc29dc0
 Merge2 {
  inputs 2
  operation min
  Achannels {-pos.red -pos.green -pos.blue pos.alpha}
  Bchannels {-pos.red -pos.green -pos.blue pos.alpha}
  output {-pos.red -pos.green -pos.blue pos.alpha}
  name Merge4
  xpos -582
  ypos -634
 }
 Merge2 {
  inputs 2
  operation min
  Achannels {-pos.red -pos.green -pos.blue pos.alpha}
  Bchannels {-pos.red -pos.green -pos.blue pos.alpha}
  output {-pos.red -pos.green -pos.blue pos.alpha}
  name Merge5
  xpos -582
  ypos -602
 }
push $N1cc3d170
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -456
  ypos -402
 }
push $N1ce436e0
 Viewer {
  frame 36
  frame_range 1-100
  name Viewer1
  xpos -27
  ypos 325
 }
 Input {
  inputs 0
  name InputCamera
  xpos -1271
  ypos 89
  number 1
 }
 Camera {
  useMatrix true
  matrix {
      {1 0 0 0}
      {0 {1/Settings_Format.actual_format.pixel_aspect} 0 0}
      {0 0 1 0}
      {0 0 0 1}
    }
  projection_mode {{"\[value the_cam]projection_mode"}}
  focal {{"\[value \[value the_cam]focal]"}}
  haperture {{"\[value \[value the_cam]haperture]"}}
  vaperture {{"\[value \[value the_cam]vaperture]"}}
  near {{"\[value \[value the_cam]near]"}}
  far {{"\[value \[value the_cam]far]"}}
  win_translate {{"\[lindex \[value \[value the_cam]win_translate] 0]"} {"\[lindex \[value \[value the_cam]win_translate] 1]"}}
  win_scale {{"\[lindex \[value \[value the_cam]win_scale] 0]"} {"\[lindex \[value \[value the_cam]win_scale] 1]"}}
  winroll {{"\[value \[value the_cam]winroll]"}}
  focal_point {{"\[value \[value the_cam]focal_point]"}}
  fstop {{"\[value \[value the_cam]fstop]"}}
  name Camera1
  help "DummyCam by Adrian Pueyo\n\nCamera that apart from the matrices also grabs all the \"Projection\" values from the upstream camera that it's connected to. Turns into a default Camera if not Camera connected.\n\nCan also be used inside of groups and gizmos, as many levels deep as you want :D\n\nAll using live and super fast TCL.\n\nadrianpueyo.com, 2019"
  onCreate "n = nuke.thisNode()\nfor k in \[\"projection_mode\",\"focal\",\"haperture\",\"vaperture\",\"near\",\"far\",\"win_translate\",\"win_scale\",\"winroll\",\"focal_point\",\"fstop\"]:\n    n\[k].setFlag(0x0000000010000000)"
  label "(thanks to Adrian Pueyo and Ernest Dios)"
  xpos -1261
  ypos 198
  addUserKnob {20 DummyCam l Defaults}
  addUserKnob {43 the_cam +INVISIBLE}
  the_cam "\[\nset the_knob \"focal\"\nset knob_index 0\nset starting_point \"this.input0\"\nset default \"this\"\nset default \[append default \".d_\"]\n\n# If cam has no inputs, return the default...\nif \{\[exists \$starting_point]\} \{\n    set x \[node \$starting_point]\n\} \{ \n    return \$default\n\}\n\nset finished 0\nwhile \{\$finished != 1\} \{\n\n    # First look for a Cam or Input or topnode.\n    while \{\[class \$x] != \"Camera2\" && \[class \$x] != \"Camera\" && \[class \$x] != \"Input\" && \$x != \[topnode \$x]\} \{\n        set x \[node \$x.input0]\n    \}\n\n    # Then, check if node is a cam (and return), and otherwise, if it's an input, see if the parent exists and move to it.\n    if \{\[class \$x]==\"Camera2\"||\[class \$x]==\"Camera\"\} \{\n        set x \[append x \".\"]\n        return \$x\n    \} \{ \n        if \{\[class \$x]==\"Input\"\} \{ \n            set inp \"\$x.parent.input\"\n            set inputNum \[value \$x.number]\n            set inp \[append inp \$inputNum]\n            if \{\[exists \$inp]\} \{\n                set x \[node \$inp]\n            \} \{ \n                set finished 1\n            \}\n        \} \{ \n            set finished 1\n        \}\n    \}\n\}\nreturn \$default\n]"
  addUserKnob {4 d_projection_mode l projection M {perspective orthographic uv spherical ""}}
  addUserKnob {7 d_focal l focal R 0 100}
  d_focal 50
  addUserKnob {7 d_haperture l "horiz aperture" R 0 50}
  d_haperture 24.576
  addUserKnob {7 d_vaperture l "vert aperture" R 0 50}
  d_vaperture 18.672
  addUserKnob {7 d_near l near R 0 10}
  d_near 0.1
  addUserKnob {7 d_far l far R 0 10000}
  d_far 10000
  addUserKnob {12 d_win_translate l "window translate"}
  addUserKnob {12 d_win_scale l "window scale"}
  d_win_scale {1 1}
  addUserKnob {7 d_winroll l "window roll" R 0 45}
  addUserKnob {7 d_focal_point l "focal distance" R 0 10}
  d_focal_point 2
  addUserKnob {7 d_fstop l fstop R 0 30}
  d_fstop 16
  addUserKnob {26 text l " " T "<span style=\"color:#666\"><br/><b>DummyCam v1.0</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2019</span>"}
 }
end_group
Write {
 channels rgba
 name Write4
 xpos -1792
 ypos 2380
 addUserKnob {20 caravr l CaraVR}
 addUserKnob {4 viewPresets l "View Presets" M {main stereo cams "stereo cams" all}}
 addUserKnob {22 set l Set -STARTLINE T "w = nuke.thisNode()\nscriptViews = nuke.views()\nviewPreset = w\['viewPresets'].getValue()\nselectedViews = None\nif viewPreset == 0:\n  selectedViews = \['main']\nif viewPreset == 1:\n  stereoViews = \['left', 'right']\n  if set(stereoViews).issubset(set(scriptViews)):\n    selectedViews = stereoViews\n  else:\n    selectedViews = None\nelif viewPreset == 2:\n  selectedViews = \[v for v in scriptViews if 'cam' in v and not ('_left' in v or '_right' in v)]\nelif viewPreset == 3:\n  selectedViews = \[v for v in scriptViews if 'cam' in v and ('_left' in v or '_right' in v)]\nelif viewPreset == 4:\n  selectedViews = scriptViews\nif selectedViews:\n  w\['views'].fromScript(' '.join(selectedViews))\n"}
}
Read {
 inputs 0
 file_type exr
 file /jobs/TRAINVFX/REF/montreal/general_reference/data/2021/Elements/fractal_distortion/fractal_distortion_v01.####.exr
 localizationPolicy off
 format "1920 1080 0 0 1920 1080 1 Canon 5D mkIII HD"
 proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 first 1001
 last 1050
 origfirst 1001
 origlast 1050
 origset true
 smartGrade true
 name Read6
 xpos -1793
 ypos 2402
 postage_stamp_frame 1025
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 _ivyFile "no results were found for query (Leaf) (WHERE Leaf.job = 'TRAINVFX' AND Leaf.location = '/jobs/TRAINVFX/REF/montreal/general_reference/data/2021/Elements/fractal_distortion/fractal_distortion_v01.#.exr' AND Leaf.deleted = '0000-00-00 00:00:00' AND Leaf.archived = '0000-00-00 00:00:00' AND Leaf.provisional = '0')"
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 addUserKnob {1 leaf_label l Leaf}
 addUserKnob {1 ivy_version l Version}
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
push $N1dc39c60
push $N1dcaf550
Shuffle {
 in __Pworld
 out pos
 name Shuffle4
 xpos 2217
 ypos 1964
}
Group {
 inputs 2
 name Point_Render4
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 xpos 2217
 ypos 2052
 addUserKnob {20 User l "Point Render" t dd}
 addUserKnob {26 info_header l "" +STARTLINE T "Point Render v1.2"}
 addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {4 RenderMode l "Render Mode" t "Some generators support multiple render modes other than just point rendering. This should be considered a experimental feature, but can be used to great effect.\n\nIn the Render Settings tab you can find more controls relating to Wire and Facet rendering modes.\n\nNote that Facet Render can be slow when really close to a object. " M {"Point Render" "Wire Render" "Facet Render (experimental)" "" "" ""}}
 RenderMode "Wire Render"
 addUserKnob {7 FocalLength l "Focal Length" t "The point render does not take the focal length from the input camera, so if you want to match it to a camera you should link the focal length from the camera to this." +INVISIBLE R 0 200}
 FocalLength 40
 addUserKnob {7 horizontalApeture l "Horiz Apeture" +INVISIBLE R 0 100}
 horizontalApeture 24.576
 addUserKnob {14 overscan l Overscan R 0 100}
 addUserKnob {7 AlphaMultiplier l Exposure t "This is a general exposure modifier that lets you adjust the overall brightness of the render." R 0 2}
 AlphaMultiplier 1
 addUserKnob {6 OutputZdepth l "Output Z-depth" t "Will output a Z-depth channel. This will cause reduced rendering performence." +STARTLINE}
 addUserKnob {6 UseOcclusionMap l "Use Occlusion Map" t "Enable the Occlusion map input. This lets you use a depth map as a holdout.\n\nNote:\nThe Red channal should contain the depth (absolute distance, not 1/depth)\nThe Alpha channal must be 1 for the areas that you want to holdout." +STARTLINE}
 addUserKnob {4 occ_method l "" t "Real Depth - input RGB should be the distance to the camera, and A should be the alpha (White occlude, Black ingore).\n\n1/depth.z (Scanline Render) - Will use the depth.Z channal from the scanline render and convert to real depth internally. Alpha is still required." -STARTLINE M {"Real Depth" "1/depth.z (Scanline Render)" ""}}
 occ_method "1/depth.z (Scanline Render)"
 addUserKnob {26 devider_cc l "<b><font color=#7DADF9>Preview</font><b>"}
 addUserKnob {6 FastPreview l "Fast Preview" t "Reduce the number of points for a quick preview of the final render." +STARTLINE}
 addUserKnob {6 HighlightCompression l "Hilight Compression" t "Compresses the highlights to make it easier to see bright details." +STARTLINE}
 addUserKnob {7 HighlightCeiling l "Highlight Ceiling" t "Adjust the cealing for the highlight compression." R 1 10}
 HighlightCeiling 1.15
 addUserKnob {7 Compression t "The compression amount." -STARTLINE R 0 5}
 Compression 1
 addUserKnob {26 devider_format l "<b><font color=#7DADF9>Format</font><b>"}
 addUserKnob {41 format l "output format" T Settings_Format.format}
 addUserKnob {20 WireRender l "Render Settings"}
 addUserKnob {26 devider_wirerender l "<b><font color=#7DADF9>Wire Rendering</font><b>"}
 addUserKnob {4 wire_type l "Connection Mode" t "*Normal\nConnect lines between the local neigbours of the 2d position map\n\n*Nearest\nConnect lines to the nearest points (in 3D space). This mode is limited to 100x100 points for performence reasons!" M {Normal Nearest "" "" "" "" "" "" "" ""}}
 addUserKnob {26 text l "Normal Mode Wires" T " "}
 addUserKnob {6 connect_x l x t "Connect wires in the (uv) X axis." -STARTLINE}
 connect_x true
 addUserKnob {6 connect_xy l xy t "Connect wires in the (uv) XY axis." -STARTLINE}
 connect_xy true
 addUserKnob {6 connect_y l y t "Connect wires in the (uv) Y axis." -STARTLINE}
 connect_y true
 addUserKnob {6 connect_aux l aux t "If you input a vector map into the Aux input for this node, and enable this option, you will get a wire from each point along that vector." -STARTLINE}
 addUserKnob {7 wire_maxdistance l "Max Distance" t "The maximum distance that the wires connect." R 0 10}
 wire_maxdistance 6
 addUserKnob {7 wire_Threshold l "Distance Threshold" t "Control the max distance threshold" R 0 2}
 wire_Threshold 0.5
 addUserKnob {3 wire_connections l "Max Connections" t "The maximum number of connections (Not Yet Implemented)"}
 wire_connections 4
 addUserKnob {7 maxSamples l "Max Line Samples" t "The maximum length of a line. Once a line is longer than this, it will start break up. \nThis can also be used as a creative effect if you set it low, try setting it to 10 in wire mode to get dotted lines" R 0 10000}
 maxSamples 10000
 addUserKnob {7 lineoffset l "Line Offset" t "Expand or contract the lines."}
 lineoffset 1
 addUserKnob {7 inGain l "In Gain" t "Gain the brightness of the in-point of the lines"}
 inGain 1
 addUserKnob {7 outGain l "Out Gain" t "Gain the brightness of the out-point of the lines" -STARTLINE}
 outGain 1
 addUserKnob {26 devider_facet l "<b><font color=#7DADF9>Facet Rendering</font><b>"}
 addUserKnob {4 renderMode l "Render Mode" t "Pick the desidered render mode." M {Diffuse "Local ST" Normal "Facing Ratio" UV ST "View Normal" "World Position" "" ""}}
 addUserKnob {6 facet_flatShading l "Flat Shading" t "Flat shading" +STARTLINE}
 addUserKnob {6 facet_depth l "Depth Buffer" t "Enable depth sorting to avoid additive surfaces." -STARTLINE}
 addUserKnob {6 facet_front l "Front Face" t "Render front facing facets" +STARTLINE}
 facet_front true
 addUserKnob {6 facet_backface l "Back Face" t "Render backfacing faces" -STARTLINE}
 facet_backface true
 addUserKnob {26 _1 l "<b><font color=#7DADF9>Other</font><b>"}
 addUserKnob {6 CloseX l "Close X" t "On spheres or round objects this closes the loop" +STARTLINE}
 addUserKnob {6 CloseY l "Close Y" t "On spheres or round objects this closes the loop" -STARTLINE}
 addUserKnob {20 Fog_1 l Fog}
 addUserKnob {26 Devider_Fog l "<b><font color=#7DADF9>Fog</font><b>"}
 addUserKnob {6 Fog t "Fog reduces the brightness of poins far from the camera." +STARTLINE}
 addUserKnob {7 FogNear l "Fog Near" R 0 200}
 FogNear 1
 addUserKnob {7 FogFar l "Fog Far" R 0 200}
 FogFar 150
 addUserKnob {7 FogExponent l "Fog Exponent" R 0 8}
 FogExponent 8
 addUserKnob {20 DepthOfField l "Depth of Field"}
 addUserKnob {26 devider_dof l "<b><font color=#7DADF9>Depth Of Field</font><b>"}
 addUserKnob {6 dof_enable l Enable +STARTLINE}
 addUserKnob {7 dof_focaldepth l "Focal Depth" R 0 40}
 dof_focaldepth 24.1
 addUserKnob {7 dof_dof l "Depth of Field" R 0 10}
 dof_dof 1
 addUserKnob {7 dof_maxSize l "Max Size"}
 dof_maxSize 0.6
 addUserKnob {7 dof_Aspect l "Aspect Ratio"}
 dof_Aspect 1
 addUserKnob {7 dof_bias l Bias R -3 3}
 dof_bias -0.2
 addUserKnob {4 Dof_Quality l Quality M {Low Medium High Extreme}}
 addUserKnob {20 MotionBlur}
 addUserKnob {26 devider_MotionBlur l "<b><font color=#7DADF9>Motion Blur</font><b>"}
 addUserKnob {6 mb_enable l Enable +STARTLINE}
 mb_enable true
 addUserKnob {6 Fast l "Fast (Interpolated)" -STARTLINE}
 Fast true
 addUserKnob {3 Samples}
 Samples 8
 addUserKnob {7 Shutter R 0 2}
 Shutter 1
 addUserKnob {4 pulldown l "Shutter Offset" M {Centered Start End ""}}
 addUserKnob {20 preview_3d l "3D Preview"}
 addUserKnob {6 Enable3DPreview l "Enable 3D Preview" t "Display a preview of the points in the Nuke 3D view." +STARTLINE}
 Enable3DPreview true
 addUserKnob {41 pointSize l "point size" T PreviewNode.pointSize}
 addUserKnob {41 detail l "point detail" T PreviewNode.detail}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x388e8e00
  label "Output Format Manager"
  note_font_size 22
  xpos -1079
  ypos 117
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode10
  tile_color 0x388e8e00
  label "AUX Input"
  note_font_size 22
  xpos -385
  ypos 178
  bdwidth 207
  bdheight 178
 }
 BackdropNode {
  inputs 0
  name BackdropNode11
  tile_color 0x388e8e00
  label "Point Render"
  note_font_size 22
  xpos -96
  ypos 99
  bdwidth 203
  bdheight 131
 }
 BackdropNode {
  inputs 0
  name BackdropNode12
  tile_color 0x388e8e00
  label "Normal Generator\nFor Vertex Normals"
  note_font_size 22
  xpos -616
  ypos 243
  bdwidth 191
  bdheight 122
 }
 BackdropNode {
  inputs 0
  name BackdropNode13
  tile_color 0x388e8e00
  label "Ensure output format"
  note_font_size 22
  xpos -622
  ypos -41
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode14
  tile_color 0x388e8e00
  label "Motion Blur"
  note_font_size 22
  xpos -85
  ypos 255
  bdwidth 264
  bdheight 96
 }
 BackdropNode {
  inputs 0
  name BackdropNode15
  tile_color 0x388e8e00
  label "Soft Preview"
  note_font_size 22
  xpos -83
  ypos 601
  bdwidth 191
  bdheight 94
 }
 BackdropNode {
  inputs 0
  name BackdropNode16
  tile_color 0x388e8e00
  label "Final format"
  note_font_size 22
  xpos -84
  ypos 482
  bdwidth 192
  bdheight 95
 }
 BackdropNode {
  inputs 0
  name BackdropNode17
  tile_color 0x388e8e00
  label "No Clue =)"
  note_font_size 22
  xpos -385
  ypos -41
  bdwidth 160
  bdheight 87
 }
 BackdropNode {
  inputs 0
  name BackdropNode18
  tile_color 0x388e8e00
  label "Z-Depth Shuffle"
  note_font_size 22
  xpos -85
  ypos 367
  bdwidth 264
  bdheight 96
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0x388e8e00
  label Motionblur
  note_font_size 22
  xpos -672
  ypos -781
  bdwidth 258
  bdheight 246
 }
 BackdropNode {
  inputs 0
  name BackdropNode3
  tile_color 0x388e8e00
  label "Fast Preview"
  note_font_size 22
  xpos -669
  ypos -971
  bdwidth 254
  bdheight 138
 }
 BackdropNode {
  inputs 0
  name BackdropNode4
  tile_color 0x388e8e00
  label "Nearest Wire Mode Clamp"
  note_font_size 22
  xpos -666
  ypos -1184
  bdwidth 253
  bdheight 111
 }
 BackdropNode {
  inputs 0
  name BackdropNode5
  tile_color 0x388e8e00
  label Occlusion
  note_font_size 22
  xpos 208
  ypos 27
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode6
  tile_color 0x388e8e00
  label "Input Camera Container"
  note_font_size 22
  xpos -1357
  ypos 121
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode7
  tile_color 0x388e8e00
  label "3D Preview"
  note_font_size 22
  xpos -88
  ypos -45
  bdwidth 207
  bdheight 102
 }
 BackdropNode {
  inputs 0
  name BackdropNode8
  tile_color 0x388e8e00
  label "Input Format Manager"
  note_font_size 22
  xpos -526
  ypos -459
  bdwidth 208
  bdheight 97
 }
 BackdropNode {
  inputs 0
  name BackdropNode9
  tile_color 0x388e8e00
  label FOG
  note_font_size 22
  xpos -602
  ypos -253
  bdwidth 370
  bdheight 152
 }
 Input {
  inputs 0
  name InputPointData
  xpos -584
  ypos -1321
 }
 Dot {
  name Dot4
  xpos -550
  ypos -1234
 }
set N1dd59180 [stack 0]
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize fill
  filter Impulse
  black_outside true
  name Reformat5
  xpos -584
  ypos -906
  disable {{!parent.FastPreview==1}}
 }
 Grade {
  white 10
  name Grade2
  xpos -584
  ypos -874
  disable {{!parent.FastPreview}}
 }
 Dot {
  name Dot2
  xpos -550
  ypos -712
 }
set N1dd7d7d0 [stack 0]
 Group {
  name FrameHold3
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -501
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame+1}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot6
  xpos -467
  ypos -659
 }
set N1dd9d7c0 [stack 0]
push $N1dd7d7d0
 Group {
  name FrameHold2
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -660
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot5
  xpos -626
  ypos -659
 }
set N1ddbd630 [stack 0]
 Dissolve {
  inputs 2
  which {{frame-floor(frame)}}
  name Dissolve1
  xpos -582
  ypos -666
  disable {{1-parent.mb_enable}}
 }
set N1ddc2190 [stack 0]
push $N1dd7d7d0
 Switch {
  inputs 2
  which {{parent.Fast}}
  name Switch2
  xpos -584
  ypos -567
 }
 Dot {
  name DataFetch
  label "data fetch\t"
  note_font_color 0xff21ff
  xpos -550
  ypos -513
  addUserKnob {20 User}
  addUserKnob {3 n_particles l "Number of Particles"}
  addUserKnob {3 gentype l "Type Of Generator"}
  addUserKnob {26 info l "" -STARTLINE T "0 = unknown, 1 = Card, 2 = Sphere, 3 = Grid"}
 }
set N1ddd5540 [stack 0]
 Dot {
  name Dot3
  xpos -635
  ypos -513
 }
 Dot {
  name Dot1
  xpos -635
  ypos 863
 }
 Reformat {
  inputs 0
  format "1920 1080 0 0 1920 1080 1 HD_1080"
  resize distort
  center false
  black_outside true
  name Settings_Format
  xpos -992
  ypos 209
 }
 AdjBBox {
  numpixels {{parent.overscan} {parent.overscan}}
  name AdjBBox2
  xpos -992
  ypos 241
 }
 Input {
  inputs 0
  name InputOcclusion
  xpos 238
  ypos 75
  number 2
 }
 Expression {
  expr0 depth.Z>0?1/depth.Z:0
  name Expression2
  xpos 238
  ypos 104
  disable {{!parent.occ_method}}
 }
 Constant {
  inputs 0
  channels rgb
  color 1
  format {{{parent.Settings_Format.format}}}
  name Empty
  xpos 371
  ypos 139
 }
 Switch {
  inputs 2
  which {{parent.UseOcclusionMap}}
  name Switch1
  xpos 238
  ypos 163
 }
 AdjBBox {
  numpixels {{parent.overscan} {parent.overscan}}
  name AdjBBox1
  xpos 118
  ypos 163
 }
set N1de1ef60 [stack 0]
 Input {
  inputs 0
  name Aux
  xpos -324
  ypos 214
  number 3
 }
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter Impulse
  black_outside true
  name Reformat2
  xpos -324
  ypos 238
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop1
  xpos -324
  ypos 462
 }
push $N1ddd5540
 Shuffle {
  in pos
  name Shuffle1
  xpos -584
  ypos -192
 }
set N1de459c0 [stack 0]
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter Impulse
  black_outside true
  name Reformat4
  xpos -584
  ypos 18
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop2
  xpos -584
  ypos 48
 }
 Dot {
  name Dot8
  xpos -550
  ypos 166
 }
set N1de6fbf0 [stack 0]
 Group {
  name Point_Normal2
  tile_color 0x434343ff
  note_font_color 0x55ffffff
  xpos -584
  ypos 498
  disable {{!(renderMode==2&&RenderMode==2)}}
  addUserKnob {20 User}
  addUserKnob {26 info l "" +STARTLINE T "Point Normal v1.0"}
  addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
  addUserKnob {26 info_1 l "" +STARTLINE T "well, not much to do here =)"}
 }
  Input {
   inputs 0
   name Input1
   xpos 389
   ypos 207
  }
  Shuffle {
   in pos
   name Shuffle1
   xpos 389
   ypos 294
  }
  BlinkScript {
   kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/BasicLight.cpp
   recompileCount 69
   ProgramGroup 1
   KernelDescription "2 \"PointRender3D\" iterate pixelWise d5452fe7b684561fcfa5182d0c789025a037cc4fe4474c24e065e3fa53fcd8ce 2 \"ppos\" Read Random \"dst\" Write Point 9 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"Zoom\" Float 1 AACAPw== \"half Lambert\" Bool 1 AQ== \"light Mode\" Int 1 AAAAAA== \"light_position\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"light_color\" Float 3 AACAPwAAgD8AAIA/AAAAAA== 9 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"zoom\" 1 1 \"halfLambert\" 1 1 \"lightMode\" 1 1 \"lightPos\" 3 1 \"lightcolor\" 3 1 10 \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"namount\" Float 1 1 AAAAAA=="
   kernelSource "inline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}\n\ninline float saturate(float _in)\n\{\n    return max(0.0f,min(1.0f,_in));\n\}\n\ninline float3 reflect(float3 incidence,float3 normal)\n\{\n  return incidence - 2.f * dot(incidence, normal) * normal;\n\}\n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n    \n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    if (fabs(pScreen.x) > canvasWidth || fabs(pScreen.y) > canvasHeight) \n         return false; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eWrite> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    bool halfLambert;\n    int lightMode;\n    float3 lightPos;\n    float3 lightcolor;\n\n\n  local: //Local variables\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n    float namount; //dither amount\n\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(halfLambert, \"half Lambert\", true);\n    defineParam(lightMode, \"light Mode\", 0);\n    defineParam(lightPos,      \"light_position\", float3(0,0,0));  \n    defineParam(lightcolor,      \"light_color\", float3(1.0,1.0,1.0)); \n  \}\n\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n    namount = 0.0001; //dither amount\n  \}\n\n\n\nfloat3 Reconsile3D(float3 _PointPos)\{\n    vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n    int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    return tRaster;\n\}\n\n\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nfloat3 facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos;\n    float4 V0_Sample,V1_Sample,V2_Sample;\n    float3 normal0,normal1,normal2;\n\n    //for area calculation\n    float area;\n    float3 V0,V1,V2;\n    float3 output = float3(0.0f);\n  if (insideX) \{\n    V2_Sample = ppos(pos.x+1,pos.y);\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(pos.x+1,pos.y-1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n            float3 Normal = CalculateVertexNormals(_vWorld,V2_wPos,V1_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          //write output\n          output +=  float3(Normal.x,Normal.y,Normal.z);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,pos.y+1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n          float3 Normal = CalculateVertexNormals(_vWorld,V1_wPos,V2_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          output += float3(Normal.x,Normal.y,Normal.z);\n\n        \}\n      \}\n    \}\n  \}\n  return output;\n\}\n\n\n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 hitNormal = cross((V1 - V0),(V2 - V0)); \n        return hitNormal;\n\}\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float3 output = float3(0.0f);\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float3 point_pos = float3(_sample.x,_sample.y,_sample.z);\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n      dst() = float4(0.0f);\n      output+=facet_render(pos,float3(_sample.x,_sample.y,_sample.z))*2.0f;\n      _sample = ppos(pos.x-1,pos.y); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x-1,pos.y+1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y+1),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x,pos.y-1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x,pos.y-1),float3(_sample.x,_sample.y,_sample.z));\n\n      output = normalize(output);\n      float3 normal = -output;\n\n      \n\n\n      dst() = float4(normal.x,normal.y,normal.z,1.0f);\n    \}\n  \} //----> process\n\};\n"
   rebuild ""
   "PointRender3D_half Lambert" false
   PointRender3D_light_position {{parent.Axis1.translate} {parent.Axis1.translate} {parent.Axis1.translate}}
   PointRender3D_light_color {0 0 0}
   rebuild_finalise ""
   name BlinkScript1
   xpos 389
   ypos 344
  }
  Grade {
   multiply 0.5
   add 0.5
   black_clamp false
   name Grade1
   xpos 389
   ypos 376
   disable true
  }
  Output {
   name Output1
   xpos 389
   ypos 459
  }
  Axis2 {
   inputs 0
   translate {0.5 0.5 0.5}
   name Axis1
   xpos 661
   ypos 318
   addUserKnob {20 Ivy}
   addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
   addUserKnob {26 divider4 l "" +STARTLINE}
   addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
   _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
   addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
   addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
   addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
   _expressions {{curve}}
   addUserKnob {26 divider0 l "" +STARTLINE}
   addUserKnob {20 dbinfo l "DB Info" n 1}
   dbinfo 0
   addUserKnob {1 twig_dnuuid l "Twig Id"}
   addUserKnob {1 stalk_dnuuid l "Stalk Id"}
   addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
   addUserKnob {1 leaf_dnuuid l "Leaf Id"}
   addUserKnob {26 divider1 l "" +STARTLINE}
   addUserKnob {1 twigtype l "Twig Type"}
   addUserKnob {1 leaf_label l Leaf}
   addUserKnob {1 ivy_version l Version}
   addUserKnob {43 ivy_notes l Notes}
   addUserKnob {26 divider2 l "" +STARTLINE}
   addUserKnob {1 build_label l "Build Label"}
   addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
  }
 end_group
 Switch {
  inputs 2
  which {{parent.connect_aux}}
  name Switch3
  xpos -324
  ypos 498
 }
set N1dee7200 [stack 0]
push $N1de459c0
 Expression {
  temp_name0 xd
  temp_expr0 red-Camera1.world_matrix.3
  temp_name1 yd
  temp_expr1 green-Camera1.world_matrix.7
  temp_name2 zd
  temp_expr2 blue-Camera1.world_matrix.11
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  expr3 Distance
  name Expression1
  xpos -456
  ypos -192
 }
 Grade {
  channels rgba
  blackpoint {{parent.FogFar}}
  whitepoint {{parent.FogNear}}
  gamma {{1/(parent.FogExponent+0.000000001)}}
  white_clamp true
  name Grade1
  xpos -456
  ypos -168
 }
push $N1ddd5540
 Dot {
  name Dot7
  xpos -307
  ypos -513
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge1
  xpos -341
  ypos -168
  disable {{!parent.Fog}}
 }
 Shuffle {
  name Shuffle3
  xpos -341
  ypos 8
 }
set N1df23580 [stack 0]
 Shuffle {
  red white
  green white
  blue white
  name Shuffle2
  xpos -28
  ypos 76
 }
push $N1de6fbf0
 BlinkScript {
  inputs 4
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Render/3D_PointRender_v18.cpp
  recompileCount 806
  ProgramGroup 1
  KernelDescription "2 \"PointRender3D\" iterate pixelWise b6c79b641c58390f32c944e2b5792a8702107f9cfc926636430288e7e0e1b392 5 \"ppos\" Read Random \"src\" Read Random \"normals\" Read Random \"occlusion\" Read Random \"dst\" Write Random 50 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"vertexformat\" Int 2 CgAAAAoAAAA= \"Zoom\" Float 1 AACAPw== \"Filtering Method\" Int 1 AQAAAA== \"_alphaMultiplier\" Float 1 AACAPw== \"_pointRender\" Bool 1 AQ== \"_wireRender\" Bool 1 AQ== \"_facetRender\" Bool 1 AQ== \"_maxLDistance\" Float 1 AACAPw== \"_maxLConnections\" Int 1 AQAAAA== \"_maxPlexType\" Int 1 AAAAAA== \"_plexLinedefXY\" Bool 1 AA== \"_plexLinedefX\" Bool 1 AA== \"_plexLinedefY\" Bool 1 AA== \"_plexLinedefXtoY\" Bool 1 AA== \"_plexLinedefAUX\" Bool 1 AA== \"_plexConnectX\" Bool 1 AA== \"_plexConnectY\" Bool 1 AA== \"_L_gamma\" Float 1 AACAPw== \"Enable Depth of Field\" Bool 1 AA== \"samples\" Int 1 AwAAAA== \"rings\" Int 1 BQAAAA== \"focalDepth\" Float 1 AACAPw== \"_depthOfField\" Float 1 AACAQA== \"_depthMult\" Float 1 zczMPQ== \"_maxDofSize\" Float 1 AAAAQQ== \"dof_aspect\" Float 1 AACAPw== \"dof_threshold\" Float 1 AACAPw== \"dof_gain\" Float 1 AAAAAA== \"dof_bias\" Float 1 AAAAwA== \"dof_fringe\" Float 1 AAAAAA== \"_flatshading\" Bool 1 AQ== \"_backfacing\" Bool 1 AQ== \"_frontfacing\" Bool 1 AQ== \"_vertexMode\" Int 1 AAAAAA== \"_depthBuffer\" Bool 1 AQ== \"_texoffset\" Float 2 AAAAPwAAAD8= \"_pointSize\" Int 1 AQAAAA== \"_gaussigma\" Float 1 AACAPw== \"_depthOcclusion\" Bool 1 AQ== \"depthMultiplier\" Float 1 AACAPw== \"_maxLineSteps\" Float 1 AAB6RQ== \"_lineOffset\" Float 1 AACAPw== \"_lineInMultiplier\" Float 1 AACAPw== \"_lineOutMultiplier\" Float 1 AACAPw== \"_overscan\" Float 2 AAAAAAAAAAA= \"isDepth\" Bool 1 AA== 50 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"Vformat\" 2 1 \"zoom\" 1 1 \"_filtering\" 1 1 \"_alphaMultiplier\" 1 1 \"_pointRender\" 1 1 \"_wireRender\" 1 1 \"_facetRender\" 1 1 \"_maxPlexDistance\" 1 1 \"_maxPlexConnections\" 1 1 \"_maxPlexType\" 1 1 \"_plexLinedefXY\" 1 1 \"_plexLinedefX\" 1 1 \"_plexLinedefY\" 1 1 \"_plexLinedefXtoY\" 1 1 \"_plexLinedefAUX\" 1 1 \"_plexConnectX\" 1 1 \"_plexConnectY\" 1 1 \"_plex_gamma\" 1 1 \"_dof_enable\" 1 1 \"_dof_samples\" 1 1 \"_dof_rings\" 1 1 \"focalDepth\" 1 1 \"_depthOfField\" 1 1 \"_depthMult\" 1 1 \"_maxDofSize\" 1 1 \"dof_aspect\" 1 1 \"dof_threshold\" 1 1 \"dof_gain\" 1 1 \"dof_bias\" 1 1 \"dof_fringe\" 1 1 \"_flatshading\" 1 1 \"_backfacing\" 1 1 \"_frontfacing\" 1 1 \"_vertexMode\" 1 1 \"_depthBuffer\" 1 1 \"_texoffset\" 2 1 \"_pointSize\" 1 1 \"_gaussigma\" 1 1 \"_depthOcclusion\" 1 1 \"depthMultiplier\" 1 1 \"_maxLineSteps\" 1 1 \"_lineOffset\" 1 1 \"_lineInMultiplier\" 1 1 \"_lineOutMultiplier\" 1 1 \"_overscan\" 2 1 \"isDepth\" 1 1 10 \"max_line_connections\" Int 1 1 AAAAAA== \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "//Some basic generic functions.\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float3 Cross(float3 A,float3 B)\n\{\n    return float3(A.y*B.z - A.z*B.y,A.z*B.x - A.x*B.z,A.x*B.y - A.y*B.x);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}     \n\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\ninline float mix(float _X,float _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}                                                                                              \n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n\n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight,\n    float2 overscan\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f-overscan.x || pRaster.x > imageWidth+overscan.x || \n       pRaster.y < 0.0f-overscan.y || pRaster.y > imageHeight+overscan.y || pRaster.z < 0.0f) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eRead, eAccessRandom, eEdgeClamped> src;     //The texture map\n  Image<eRead, eAccessRandom, eEdgeClamped> normals;     //The texture map  \n  Image<eRead, eAccessRandom, eEdgeClamped> occlusion;     //The texture map \n  Image<eWrite, eAccessRandom> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat,Vformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    int _filtering;        //Filter method\n    float _alphaMultiplier; //Additive multiplier\n    bool _pointRender,_wireRender,_facetRender;\n    float _maxPlexDistance; //Additive multiplier\n    int _maxPlexConnections;\n    int _maxPlexType; // 0==Grid, -1==Nearest\n    bool _plexLinedefXY,_plexLinedefX,_plexLinedefY,_plexLinedefXtoY,_plexLinedefAUX; // Define what connections NOT to include\n    bool _plexConnectX,_plexConnectY; //Connect from the edge of x to 0, or edge of y to 0, usually for spheres\n    float _plex_gamma; //The threshold making shorter paths bright and longer paths dark\n    bool _dof_enable; // Enable DOF\n    int _dof_samples; // How many samples per DOF ring\n    int _dof_rings; // How many rings \n    float focalDepth,_depthOfField,_depthMult,_maxDofSize; //DOF Settings\n    float dof_aspect; //Pixel aspect ratio\n    float dof_threshold;\n    float dof_gain;\n    float dof_bias; //bokeh edge bias\n    float dof_fringe; //bokeh chromatic aberration/fringing\n    bool _flatshading,_backfacing,_frontfacing; //Vertex rendering settings\n    int _vertexMode;  //The rendering output mode, (think AOV)\n    bool _depthBuffer; //Non-additive, only render front most pixel\n    float2 _texoffset;\n    int _pointSize;\n    float _gaussigma;\n    bool _depthOcclusion;\n    float depthMultiplier;\n    float _maxLineSteps; //cap the line length to avoid process lock\n    float _lineOffset; //Alow you to shrink or extend the lines\n    float _lineInMultiplier,_lineOutMultiplier; //Control the brightness of the wires at the tips.\n    float2 _overscan; //This will allow you to render some extra outside the bounds of the image.\n    bool isDepth; //This will allow you to render some extra outside the bounds of the image.\n\n  local: //Local variables\n    int max_line_connections;\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(Vformat,      \"vertexformat\", int2(10,10));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(_filtering, \"Filtering Method\", 1); \n    defineParam(_alphaMultiplier, \"_alphaMultiplier\", 1.0f);     \n    defineParam(_pointRender, \"_pointRender\", true);  \n    defineParam(_wireRender, \"_wireRender\", true);\n    defineParam(_facetRender, \"_facetRender\", true);\n    defineParam(_maxPlexDistance, \"_maxLDistance\", 1.0f);    \n    defineParam(_maxPlexConnections, \"_maxLConnections\", 1);    \n    defineParam(_maxPlexType, \"_maxPlexType\", 0); \n    defineParam(_plexLinedefXY, \"_plexLinedefXY\", false);      \n    defineParam(_plexLinedefXtoY, \"_plexLinedefXtoY\", false); //NYI\n    defineParam(_plexLinedefAUX, \"_plexLinedefAUX\", false); \n    defineParam(_plexLinedefX, \"_plexLinedefX\", false);  \n    defineParam(_plexLinedefY, \"_plexLinedefY\", false);  \n    defineParam(_plexConnectX, \"_plexConnectX\", false);      \n    defineParam(_plexConnectY, \"_plexConnectY\", false);   \n    defineParam(_plex_gamma, \"_L_gamma\", 1.0f);\n    //DOF SETTINGS   \n    defineParam(_dof_enable, \"Enable Depth of Field\", false);   \n    defineParam(_dof_samples, \"samples\", 3);    \n    defineParam(_dof_rings, \"rings\", 5);   \n    defineParam(focalDepth, \"focalDepth\", 1.0f);  \n    defineParam(_depthOfField, \"_depthOfField\", 4.0f);  \n    defineParam(_depthMult, \"_depthMult\", 0.1f);  \n    defineParam(_maxDofSize, \"_maxDofSize\", 8.0f);  \n    defineParam(dof_aspect, \"dof_aspect\", 1.0f);  \n    defineParam(dof_threshold, \"dof_threshold\", 1.0f);  \n    defineParam(dof_gain, \"dof_gain\", 0.0f);  \n    defineParam(dof_bias, \"dof_bias\", -2.0f);  \n    defineParam(dof_fringe, \"dof_fringe\", 0.0f); \n    //SHADING SETTINGS \n    defineParam(_flatshading, \"_flatshading\", true);  \n    defineParam(_vertexMode, \"_vertexMode\", 0);  \n    defineParam(_backfacing, \"_backfacing\", true);    \n    defineParam(_frontfacing, \"_frontfacing\", true);        \n    defineParam(_depthBuffer, \"_depthBuffer\", true);  \n    defineParam(_texoffset, \"_texoffset\", float2(0.5f,0.5f)); \n    defineParam(_pointSize, \"_pointSize\", 1); \n    defineParam(_gaussigma, \"_gaussigma\", 1.0f); \n    defineParam(_depthOcclusion, \"_depthOcclusion\", true); \n    defineParam(depthMultiplier, \"depthMultiplier\", 1.0f); \n    defineParam(_maxLineSteps, \"_maxLineSteps\", 4000.0f); \n    defineParam(_lineOffset, \"_lineOffset\", 1.0f); \n    defineParam(_lineInMultiplier, \"_lineInMultiplier\", 1.0f);   \n    defineParam(_lineOutMultiplier, \"_lineOutMultiplier\", 1.0f);     \n    defineParam(_overscan, \"_overscan\",float2(0.0f,0.0f));    \n\n  \}\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    max_line_connections = 80;\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n  \}\n\n  //Convert a 3d point position into a 2d raster position.\n  float3 Reconsile3D(float3 _PointPos)\{\n      vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      return tRaster;\n  \}\n\n//------------------------------\n//-------DRAW FUNCTIONS---------\n//------------------------------\n  //Write pixels to output.\n  void writepixel(float posx,float posy, float4 color,int index,float weight=1.0f)\n  \{ \n      if (_depthOcclusion)\{\n        float4 depthSample = occlusion(posx,posy);\n        if (depthSample.x<=vRaster.z && depthSample.w>0.0f)\{\n\n          float depth = (vRaster.z-depthSample.x);\n          color = color*(1.0f-depthSample.w);\n          color = color / (((depth*depth)*depthMultiplier)+1.0f);\n          //return;\n        \}\n      \}\n      float4 finalOutput; //This is used to store the final output\n      float4 dstSample; //This is used to store a sample of the destination\n      if ( dst.bounds.inside( posx, posy ) ) \{ //Test if the pixel written to is inside the output image. \n        if (_depthBuffer) \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          if ((dstSample.w>color.w)||dstSample.w==0.0f) \{\n            dst(posx,posy) = color;\n          \}\n        \}\n        else \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          finalOutput = dstSample + (color*_alphaMultiplier*weight);\n          finalOutput.w = dstSample.w + ((color.w*_alphaMultiplier*weight));\n\n          finalOutput.w = (dstSample.w + ((color.w*_alphaMultiplier*weight)))-(dstSample.w * ((color.w*_alphaMultiplier*weight)));\n\n          dst(posx,posy) = finalOutput;\n        \}\n      \} \n  \}\n\n  //Calculate a Bilinear Plot\n  void bilinear_Plot(float2 temppos,float4 color,int index)\n  \{\n    float2 p;\n    p.x=Frac(temppos.x);\n    p.y=Frac(temppos.y);\n    float weights\[] = \{(1.0f-p.x)*(1.0f-p.y), p.x*(1.0f-p.y), (1.0f-p.x)*p.y, p.x*p.y\};\n    int2 _position = int2(floor(temppos.x)-0,floor(temppos.y)-0); \n    writepixel(_position.x,_position.y,color,index,weights\[0]);\n    writepixel(_position.x+1,_position.y,color,index,weights\[1]);\n    writepixel(_position.x,_position.y+1,color,index,weights\[2]);\n    writepixel(_position.x+1,_position.y+1,color,index,weights\[3]);\n  \}\n\n  //NYI, unused!\n  void gaussian(float2 temppos,float4 color,int index)\{\n    float in_x = temppos.x;\n    float in_y = temppos.y;\n    int kernelSize = (_pointSize+1)*2;\n    int subsize = (kernelSize /2)-1;\n    float gKernel\[64]\[64];\n    float sigma = _gaussigma;\n    float intSigma = float(_pointSize);\n    float r, s = intSigma * sigma * sigma;\n\n    float sum = 0.0f;\n\n    // generate 5x5 kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            r = float(sqrt(x*x + y*y));\n            gKernel\[x + subsize]\[y + subsize] = (exp(-(r*r)/s))/(3.141592654f * s);\n            sum += gKernel\[x + subsize]\[y + subsize];\n        \}\n    \}\n\n    // normalize the Kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            gKernel\[x + subsize]\[y + subsize] /= sum;\n            writepixel(in_x+x,in_y+y,color,index,gKernel\[x + subsize]\[y + subsize]);\n        \}\n    \}\n  \}\n\n//-------------------------------------\n// DrawLine\n// ----------\n// Draw a line between two points, \n// x,y being 2d screenspace pos and z being depth.\n//-------------------------------------\n  void DrawLine(float3 origin, float3 endpoint,float4 _colorA,float4 _colorB) \{\n    float4 _color;\n    float3 delta = origin-endpoint;\n    float3 curPoint = origin;\n    float mag = sqrt(delta.x*delta.x+delta.y*delta.y);\n    mag = min(mag,_maxLineSteps); //Lets not go crazy, we cap it at 10.000 to avoid insane unwated processing time \n    for( float a = 0; a < mag*_lineOffset; a = a + 1.0f )\{\n      curPoint -= (delta/mag);\n      _color = (_colorA*(1.0f-(a/mag*1.0f)))+(_colorB*(a/mag*1.00f));\n      if (_dof_enable)\{\n        Bokeh(curPoint,_color);\n      \}\n      else \{\n        if (_depthBuffer && isDepth) \{_color = float4(1.0f,1.0f,1.0f,curPoint.z);\} //Added\n        bilinear_Plot(float2(curPoint.x,curPoint.y),_color,1);\n      \}\n      \n    \}\n  \}\n\n//-------------------------------------\n// Point_Render\n//-------------------------------------\nvoid point_render(int2 pos, float3 screen_pos)\{\n  float4 color = src(pos.x,pos.y);\n\n  if (_filtering == 1)\{\n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        if (_depthBuffer) \{color.w = screen_pos.z;\} //Added\n        bilinear_Plot(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  /*\n  //THIS PART NEEDS TO BE RE-WRITTEN.\n  else if (_filtering == 2)\{ \n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        gaussian(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  */\n  else \{\n      int2 _position = int2(floor(screen_pos.x),floor(screen_pos.y)); \n      if (_depthBuffer) \{color.w = screen_pos.z;\}\n      writepixel(_position.x,_position.y, color,1,1.0f); //OutputSample\n  \}\n\n\}\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nvoid facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x+1,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos,V0_N,V1_N,V2_N;\n    float2 V0_ST,V1_ST,V2_ST;\n    float4 V1_Sample,V2_Sample;\n    float4 _tn;\n    float3 normal0,normal1,normal2;\n    float2 UV_Format = float2(Vformat.x,Vformat.y);\n\n\n    int2 P0 = int2(pos.x-1,pos.y-1);\n    int2 P1 = int2(pos.x+1,pos.y+1);\n    if (_plexConnectX && pos.x == int(Vformat.x))\{\n      insideX == true;\n      P1 = int2(0.0f,pos.y+1);\n    \}\n    if (_plexConnectY && pos.y == int(Vformat.y))\{\n      insideYtop == true;\n      P1 = int2(pos.x+1,0);\n    \} \n\n    if (_plexConnectY && pos.y == 0)\{\n      insideY == true;\n      P0 = int2(pos.x-1,int(UV_Format.y));\n    \} \n\n    if (!_flatshading) \{\n      _tn = normals(pos.x,pos.y);\n      V0_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n    V0_ST = float2(pos.x,pos.y)/UV_Format;\n\n  if (insideX) \{\n    V2_Sample = ppos(P1.x,pos.y);\n    V2_ST = float2(P1.x,pos.y)/UV_Format;\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (!_flatshading) \{\n      _tn = normals(P1.x,pos.y);\n      V2_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n        \n\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(P1.x,P0.y);\n        V1_ST = float2(P1.x,P0.y)/UV_Format;\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(P1.x,P0.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}\n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V2_Pos,V1_Pos,_vWorld,V2_wPos,V1_wPos,V0_N,V2_N,V1_N,V0_ST,V2_ST,V1_ST);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,P1.y);\n        V1_ST = float2(pos.x,P1.y)/UV_Format;        \n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(pos.x,P1.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}        \n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V1_Pos,V2_Pos,_vWorld,V1_wPos,V2_wPos,V0_N,V1_N,V2_N,V0_ST,V1_ST,V2_ST);\n        \}\n      \}\n    \}\n  \}\n\}\n\n\n\n//This function will calculate if pixel C is inside the triangle\nfloat edgeFunction(float3 a, float3 b, float3 c) \n\{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n\} \n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat Distance(float3 _a,float3 _b)\n\{\n          float xd = _a.x - _b.x;\n          float yd = _a.y - _b.y;\n          float zd = _a.z - _b.z;\n          return sqrt(xd*xd + yd*yd + zd*zd);\n\}\n\nvoid DrawTriangle(float3 V0, float3 V1, float3 V2,float3 WP0, float3 WP1, float3 WP2,float3 N0, float3 N1, float3 N2, float2 st0,float2 st1,float2 st2) \{\n\n  // Precompute reciprocal of vertex z-coordinate \n  V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n\n  float2 st0n = st0 * V0.z;\n  float2 st1n = st1 * V1.z; \n  float2 st2n = st2 * V2.z; //Normal version of ST\n\n  bool inside; \n  float X0 = Fmin(V0.x,V1.x,V2.x)-1.0f;\n  float X1 = Fmax(V0.x,V1.x,V2.x)+1.0f;\n  float Y0 = Fmin(V0.y,V1.y,V2.y)-1.0f;\n  float Y1 = Fmax(V0.y,V1.y,V2.y)+1.0f;\n  float area = edgeFunction(V2, V1, V0);\n\n\n  float2 sampos = float2(st0.x*float(Vformat.x),st0.y*float(Vformat.y));\n  float4 text0 = src(sampos.x,sampos.y);\n  sampos = float2(st1.x*float(Vformat.x),st1.y*float(Vformat.y));\n  float4 text1 = src(sampos.x,sampos.y);\n  sampos = float2(st2.x*float(Vformat.x),st2.y*float(Vformat.y));  //Why do we have to do this? =(\n  float4 text2 = src(sampos.x,sampos.y);\n  sampos = float2(min(min(st0.x,st1.x),st2.x)*float(Vformat.x),min(min(st0.y,st1.y),st2.y)*float(Vformat.y));\n  float4 text3 = src(sampos.x,sampos.y);\n\n\n  for( int x = X0; x < X1 ; x++) \{\n    for( int y = Y0; y < Y1 ; y++) \{\n      float3 pixelSample(x + _texoffset.x, y + _texoffset.y,0.0f); \n\n      //This is the part where we test if the current pixel is inside the triangle\n      //We check both for front facing and back faing options\n      float w0 = edgeFunction(V1, V0, pixelSample); //Front Facing\n      float w1 = edgeFunction(V2, V1, pixelSample); \n      float w2 = edgeFunction(V0, V2, pixelSample); \n      float w3 = edgeFunction(V0, V1, pixelSample); //Back Facing\n      float w4 = edgeFunction(V1, V2, pixelSample); \n      float w5 = edgeFunction(V2, V0, pixelSample);\n\n      //writepixel(x,y, float4(w1),1,1.0f);\n      if ((w0 >= 0 && w1 >= 0 && w2 >= 0 && _frontfacing) || (w3 >= 0 && w4 >= 0 && w5 >= 0 && _backfacing)) \{ //The curent pixel is inside the triangle\n\n       // calculate vectors from point f to vertices p1, p2 and p3:\n       float3 f1 = V0-pixelSample;\n       float3 f2 = V1-pixelSample;\n       float3 f3 = V2-pixelSample;\n       // calculate the areas and factors (order of parameters doesn't matter):\n       float a = length(cross(V0-V1,V0-V2 )); // main triangle area a\n       area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n        w0 /= area; \n        w1 /= area; \n        w2 /= area; \n\n        w3 /= area; \n        w4 /= area; \n        w5 /= area; \n\n       float a1 = length(cross(f2, f3)) / a; // p1's triangle area / a\n       float a2 = length(cross(f3, f1)) / a; // p2's triangle area / a \n       float a3 = length(cross(f1, f2)) / a; // p3's triangle area / a\n       float a_magnitude = a1+a2+a3;\n       a1 = a1/a_magnitude;\n       a2 = a2/a_magnitude;\n       a3 = a3/a_magnitude;\n       float z = 1.0f / (V0.z * a1 + V1.z * a2 + V2.z * a3); \n\n\n        // find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):\n        float2 uv = st0 * a1 + st1 * a2 + st2 * a3;\n        float2 st = st0 * w0 + st1 * w1 + st2 * w2; \n        st *= z;      \n\n\n        //Calculate normals. Eighter we have flat shading, else we calculate a normal per pixel\n        float3 normalB;\n        if (_flatshading) \{\n          normalB = CalculateSurfaceNormals(WP0,WP1,WP2);\n\n        \}\n        else \{\n          float3 c0 = N2/float3(V0.z); \n          float3 c1 = N0/float3(V1.z); \n          float3 c2 = N1/float3(V2.z);  \n\n          normalB.x = w0 * c0.x + w1 * c1.x + w2 * c2.x; \n          normalB.y = w0 * c0.y + w1 * c1.y + w2 * c2.y; \n          normalB.z = w0 * c0.z + w1 * c1.z + w2 * c2.z; \n\n          normalB.x *= z, normalB.y *= z, normalB.z *= z; \n        \}\n        normalB = normalize(normalB);\n\n        //CALCULATE THE OBJECT TEXTURE COORDINATES\n        float zn = 1.0f / (V0.z * w0 + V1.z * w1 + V2.z * w2); \n        st = st0n * w0 + st1n * w1 + st2n * w2; \n        st *= zn;   \n        //--END \n\n        float3 Wpos = WP0*a1 + WP1*a2 + WP2*a3; //World Position.\n        float3 ViewNormal = normalize(float3(cameraToWorld\[3]\[0],cameraToWorld\[3]\[1],cameraToWorld\[3]\[2])-Wpos);\n\n        float nDotView =  dot(normalB,ViewNormal);\n        nDotView = 1.0f-fabs(nDotView); //make sure that the view normal ramps back around when doing backface\n        float4 tempout;\n\n        //Flatshading or regular?\n        if (!_flatshading) \{\n          tempout = text0 * a1 + text1 * a2 + text2 * a3; \n        \}\n        else\{\n          tempout = text3;\n        \}\n\n        //Additional Render Modes\n        if (_vertexMode == 1)\{\n          tempout = float4(a1,a2,a3,1.0f);\n        \}\n        else if (_vertexMode == 2)\{\n          tempout = float4(normalB.x,normalB.y,normalB.z,1.0f);\n        \}\n        else if (_vertexMode == 3)\{\n          tempout = float4(nDotView,nDotView,nDotView,1.0f);\n        \}\n        else if (_vertexMode == 4)\{\n          tempout = float4(uv.x,uv.y,0.0f,1.0f);\n        \}       \n        else if (_vertexMode == 5)\{\n          tempout = float4(st.x,st.y,0.0f,1.0f);\n        \}               \n        else if (_vertexMode == 6)\{\n          tempout = float4(ViewNormal.x,ViewNormal.y,ViewNormal.z,1.0f);\n        \}             \n        else if (_vertexMode == 7)\{\n          tempout = float4(Wpos.x,Wpos.y,Wpos.z,1.0f);\n        \}   \n\n        if (_depthBuffer)\{\n          writepixel(x,y, float4(tempout.x,tempout.y,tempout.z,z),1,1.0f);  \n        \}\n        else \{\n          if (_dof_enable)\{\n            Bokeh(float3(x,y,z),float4(tempout.x,tempout.y,tempout.z,z));\n          \}\n          else \{\n            bilinear_Plot(float2(x,y),float4(tempout.x,tempout.y,tempout.z,z),1);\n          \}\n        \}\n\n      \}  \n\n    \}\n  \}\n\}\n\n//-------------------------------------\n// Wire_Render\n//-------------------------------------\nvoid wire_render(int2 pos) \{\n  float4 temp = float4(0.0f,0.0f,0.0f,FLT_MAX);\n  float4 wire_ref_sample;\n  int2 tempXY = int2(0,0);\n  float4 plexlist\[11] = \{temp,temp,temp,temp,temp,temp,temp,temp,temp,temp,temp\}; \n  int2 plexlistXY\[11] = \{tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY\};\n  int plex_count = 0; //We use this to figure how many points that should connect.\n  float plex_dist;\n  float3 plex_position,plex_position_b;\n  float4 temp_pos, temp_pos_b; //Temporary Position Containers\n  if (_maxPlexType == -1) \{ //Used for random connection types\n    for( int x = 0; x < max_line_connections ; x++)\{ //THIS 80 NUMBER IS THE LIMIT TO AVOID TOO SLOW PROCESSING!\n      for( int y = 0; y < max_line_connections ; y++)\{\n        wire_ref_sample = ppos(x,y);\n        if (wire_ref_sample.w != 0.0f && pos.x!=x && pos.y != y) \{ \n          plex_position = float3(wire_ref_sample.x,wire_ref_sample.y,wire_ref_sample.z)*(zoom);\n          float xd = plex_position.x - vWorld.x;\n          float yd = plex_position.y - vWorld.y;\n          float zd = plex_position.z - vWorld.z;\n          float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n          if (plex_dist<_maxPlexDistance)\{\n            plex_count = min(10,plex_count+1); //Add one to the count\n            for( int h = 0; h < plex_count+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n              if (plex_dist < plexlist\[h].w) \{                  \n                for( int i = plex_count+1; i > h ; i--) \{\n                  plexlist\[i] = plexlist\[i-1];\n                  plexlistXY\[i] = plexlistXY\[i-1];\n                \}\n                plexlist\[h] = float4(plex_position.x,plex_position.y,plex_position.z,plex_dist);\n                plexlistXY\[h] = int2(x,y);\n                break;        \n              \}\n            \}\n          \} \n        \}\n      \}\n    \}\n  \}\n  else\{ //Used for standard connection types\n    float4 temp_pos;\n    bool insideX = !(Vformat.x < pos.x+1);\n    bool insideY = !(Vformat.y < pos.y+1);\n\n\n    if (!_plexLinedefAUX)\{\n      temp_pos = normals(pos.x,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,vWorld+plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideX && !_plexLinedefX) \{\n      temp_pos = ppos(pos.x+1,pos.y );\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && !_plexLinedefX) \{\n      temp_pos = ppos(0,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideY && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\}                          \n    \}\n    else if ( _plexConnectY  && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,0);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    //_plexConnect\n    if ( insideX && insideY && !_plexLinedefXY) \{              \n      temp_pos = ppos(pos.x+1,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && _plexConnectY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && insideY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectY && insideX && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n  \}   \n\n  //now that all the connections have been sorted by distance then we connect the dots.\n  for( int x = 0; x < min(_maxPlexConnections,plex_count) ; x++)\{\n    plex_position = float3(plexlist\[x].x,plexlist\[x].y,plexlist\[x].z);\n    plex_dist = plexlist\[x].w;\n\n\n    float plex_distribution = 1.0f-((plexlist\[x].w-plexlist\[0].w)/((plexlist\[min(_maxPlexConnections,plex_count)].w-plexlist\[0].w)+0.00001f)); //Where does it lie between the best and the worst distance?\n    //plexlistXY\n\n    float4 plex_col = float4(pow(1.0f-(plex_dist/_maxPlexDistance),1.0f/_plex_gamma))*float4(plex_distribution); //This one is quite cool aswell, but does leave the center ones a bit too focused \n    float4 plex_colorA = src(pos.x,pos.y);\n    float4 plex_colorB = src( plexlistXY\[x].x,plexlistXY\[x].y);\n    plex_col *= 0.1f;\n\n    computePixelCoordinates(plex_position, pRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n    if (dst.bounds.inside(int(vRaster.x),int(vRaster.y)) || dst.bounds.inside(int(pRaster.x),int(pRaster.y)))\{\n        DrawLine(vRaster,pRaster,(plex_colorA*plex_col)*_lineInMultiplier,(plex_colorB*plex_col)*_lineOutMultiplier);\n    \}\n  \}\n\}\n\nvoid wire_connection(float3 p_source,float3 p_target, float4 (&p_plexlist)\[11], int2 (&p_plexlistXY)\[11],int &p_plexcount,int2 position) \{\n  float xd = p_target.x - p_source.x;\n  float yd = p_target.y - p_source.y;\n  float zd = p_target.z - p_source.z;\n  float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n  if (plex_dist<_maxPlexDistance)\{\n    p_plexcount = min(11,p_plexcount+1); //Add one to the count\n    for( int h = 0; h < p_plexcount+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n      if (plex_dist < p_plexlist\[h].w) \{                  \n        for( int i = p_plexcount+1; i > h ; i--) \{\n          p_plexlist\[i] = p_plexlist\[i-1];\n          p_plexlistXY\[i] = p_plexlistXY\[i-1];\n        \}\n        p_plexlist\[h] = float4(p_target.x,p_target.y,p_target.z,plex_dist);\n        p_plexlistXY\[h] = int2(position.x,position.y);\n        break;        \n      \}\n    \}  \n  \}\n\}\n//-------END OF WIRE RENDER FUNCTIONS---------\n\n\n\n\n//-------------------------------\n//-------BOKEH FUNCTIONS---------\n//thanks to: http://devlog-martinsh.blogspot.dk/2011/11/glsl-depth-of-field-with-bokeh-v21.html\nfloat2 rand(float2 coord) //generating noise/pattern texture for dithering\n\{\n  float noiseX = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.25)+(Frac(coord.y*(WHformat\[1]/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.75)+(Frac(coord.y*(WHformat\[1]/2.0))*0.25))*2.0-1.0;\n  noiseX = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f))) * 43758.5453f),0.0f,1.0f)*2.0f-1.0f;\n  noiseY = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f)*2.0f)) * 43758.5453f),0.0f,1.0f)*2.0-1.0f;\n  return float2(noiseX,noiseY);\n\}\n//-------------------------------------\n// Bokeh\n//-------------------------------------\nvoid Bokeh(float3 pos,float4 color)\{\n  float blur = 0.0;\n  blur = clamp((fabs(pos.z - focalDepth)/_depthOfField)*100.0f,-_maxDofSize,_maxDofSize);\n  \n  float w = (1.0/WHformat.x)*blur;//+noise.x;\n  float h = (1.0/(WHformat.x*dof_aspect))*blur;//+noise.y;\n  float3 v3_col = float3(color.x,color.y,color.z);\n  int ringsamples;\n  float s = 1.0;  \n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples; \n    for (int j = 0 ; j < ringsamples ; j += 1)  \n    \{ \n      s += (1.0f*mix(1.0f,(float(i))/(float(_dof_rings)),dof_bias)*1.0f); //No need to do this in the loop\n    \}\n  \}\n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples;\n     \n    for (int j = 0 ; j < ringsamples ; j += 1)   \n    \{\n      float step = PI*2.0 / float(ringsamples);\n      float pw = (cos(float(j)*step)*(float(i)/_dof_rings));\n      float ph = (sin(float(j)*step)*(float(i)/_dof_rings));\n      float p = 1.0;\n\n      float posx = pos.x+((pw*w)*blur);\n      float posy = pos.y+((ph*h)*blur);\n\n\n      float3 lumcoeff = float3(0.299,0.587,0.114);\n      float lum = dot(v3_col, lumcoeff);\n      float thresh = max((lum-dof_threshold)*dof_gain, 0.0f);\n      v3_col+mix(float3(0.0),v3_col,thresh*blur);\n\n      float3 col = (v3_col*mix(1.0,(float(i))/(float(_dof_rings)),dof_bias)*p)/s; \n      bilinear_Plot(float2(posx,posy),float4(col.x,col.y,col.z,color.w/(_dof_rings*_dof_rings)),1);\n    \}\n  \}\n\}\n//-------END OF BOKEH FUNCTIONS---------\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float2 posf = float2(pos.x,pos.y);\n\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n\n      //Convert worldspace coordinates to screenspcace coordinates.\n      vWorld = float3(_sample.x,_sample.y,_sample.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, vRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      if (ret) \{ //Only create points that are visible on screen\n        if (_pointRender)\{\n          point_render(pos,vRaster);\n        \}\n      \} //Pointrender over\n\n      if (_wireRender && _maxPlexConnections>=1) \{\n        if (max(pos.x,pos.y)<=max_line_connections || (_maxPlexType==0))\{ // Don't process more wires than allowed in nearest mode.\n          wire_render(pos);\n        \}\n      \} //WireRender over\n\n      if (_facetRender) \{\n        facet_render(pos,float3(_sample.x,_sample.y,_sample.z));\n      \}  //FacetRender over\n      \n    \}\n  \} //----> process\n\};\n"
  useGPUIfAvailable false
  rebuild ""
  PointRender3D_cam_Matrix {
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
    }
  PointRender3D_focallength {{parent.Camera1.focal}}
  PointRender3D_hapeture {{parent.Camera1.haperture}}
  PointRender3D_format {{!proxy?Settings_Format.width:Settings_Format.width*proxy_scale} {!proxy?Settings_Format.height:Settings_Format.height*proxy_scale}}
  PointRender3D_vertexformat {{parent.InputFormat.box.r-1} {parent.InputFormat.box.t-1}}
  PointRender3D__alphaMultiplier {{parent.AlphaMultiplier}}
  PointRender3D__pointRender {{parent.RenderMode==0}}
  PointRender3D__wireRender {{parent.RenderMode==1}}
  PointRender3D__facetRender {{parent.RenderMode==2}}
  PointRender3D__maxLDistance {{parent.wire_maxdistance}}
  PointRender3D__maxLConnections {{parent.wire_connections}}
  PointRender3D__maxPlexType {{-parent.wire_type}}
  PointRender3D__plexLinedefXY {{!parent.connect_xy}}
  PointRender3D__plexLinedefX {{!parent.connect_x}}
  PointRender3D__plexLinedefY {{!parent.connect_y}}
  PointRender3D__plexLinedefAUX {{!connect_aux}}
  PointRender3D__plexConnectX {{parent.CloseX}}
  PointRender3D__plexConnectY {{parent.CloseY}}
  PointRender3D__L_gamma {{parent.wire_Threshold}}
  "PointRender3D_Enable Depth of Field" {{parent.dof_enable}}
  PointRender3D_samples {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_rings {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_focalDepth {{parent.dof_focaldepth}}
  PointRender3D__depthOfField {{parent.dof_dof}}
  PointRender3D__depthMult 0
  PointRender3D__maxDofSize {{parent.dof_maxSize*400}}
  PointRender3D_dof_aspect {{parent.dof_Aspect}}
  PointRender3D_dof_bias {{parent.dof_bias}}
  PointRender3D__flatshading {{parent.facet_flatShading}}
  PointRender3D__backfacing {{parent.facet_backface}}
  PointRender3D__frontfacing {{parent.facet_front}}
  PointRender3D__vertexMode {{parent.renderMode}}
  PointRender3D__texoffset {-0.5 0.5}
  PointRender3D__pointSize 0
  PointRender3D__depthOcclusion {{parent.UseOcclusionMap}}
  PointRender3D__maxLineSteps {{parent.maxSamples}}
  PointRender3D__lineOffset {{parent.lineoffset}}
  PointRender3D__lineInMultiplier {{parent.inGain}}
  PointRender3D__lineOutMultiplier {{parent.outGain}}
  PointRender3D__overscan {{parent.overscan} {parent.overscan}}
  PointRender3D_isDepth true
  format "1280 720 0 0 1280 720 1 HD_720"
  rebuild_finalise ""
  name BlinkScriptZdepth
  label Zdepth
  xpos -28
  ypos 100
 }
 Dot {
  name Dot10
  xpos 97
  ypos 112
 }
 TimeBlur {
  divisions {{parent.Samples}}
  shutter {{parent.Shutter}}
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur1
  xpos 63
  ypos 300
  disable {{1-parent.mb_enable x89 0}}
 }
 Expression {
  expr3 a!=0?a/r:0
  name Expression3
  selected true
  xpos 63
  ypos 324
 }
 Dot {
  name Dot9
  xpos 97
  ypos 414
 }
push $N1de1ef60
push $N1dee7200
push $N1df23580
push $N1de6fbf0
 BlinkScript {
  inputs 4
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Render/3D_PointRender_v17.cpp
  recompileCount 803
  ProgramGroup 1
  KernelDescription "2 \"PointRender3D\" iterate pixelWise 0c100cf8a634aa2c2e18f544ec8abfd6d5d138cc25ae8f7d7127230910c2e91f 5 \"ppos\" Read Random \"src\" Read Random \"normals\" Read Random \"occlusion\" Read Random \"dst\" Write Random 49 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"vertexformat\" Int 2 CgAAAAoAAAA= \"Zoom\" Float 1 AACAPw== \"Filtering Method\" Int 1 AQAAAA== \"_alphaMultiplier\" Float 1 AACAPw== \"_pointRender\" Bool 1 AQ== \"_wireRender\" Bool 1 AQ== \"_facetRender\" Bool 1 AQ== \"_maxLDistance\" Float 1 AACAPw== \"_maxLConnections\" Int 1 AQAAAA== \"_maxPlexType\" Int 1 AAAAAA== \"_plexLinedefXY\" Bool 1 AA== \"_plexLinedefX\" Bool 1 AA== \"_plexLinedefY\" Bool 1 AA== \"_plexLinedefXtoY\" Bool 1 AA== \"_plexLinedefAUX\" Bool 1 AA== \"_plexConnectX\" Bool 1 AA== \"_plexConnectY\" Bool 1 AA== \"_L_gamma\" Float 1 AACAPw== \"Enable Depth of Field\" Bool 1 AA== \"samples\" Int 1 AwAAAA== \"rings\" Int 1 BQAAAA== \"focalDepth\" Float 1 AACAPw== \"_depthOfField\" Float 1 AACAQA== \"_depthMult\" Float 1 zczMPQ== \"_maxDofSize\" Float 1 AAAAQQ== \"dof_aspect\" Float 1 AACAPw== \"dof_threshold\" Float 1 AACAPw== \"dof_gain\" Float 1 AAAAAA== \"dof_bias\" Float 1 AAAAwA== \"dof_fringe\" Float 1 AAAAAA== \"_flatshading\" Bool 1 AQ== \"_backfacing\" Bool 1 AQ== \"_frontfacing\" Bool 1 AQ== \"_vertexMode\" Int 1 AAAAAA== \"_depthBuffer\" Bool 1 AQ== \"_texoffset\" Float 2 AAAAPwAAAD8= \"_pointSize\" Int 1 AQAAAA== \"_gaussigma\" Float 1 AACAPw== \"_depthOcclusion\" Bool 1 AQ== \"depthMultiplier\" Float 1 AACAPw== \"_maxLineSteps\" Float 1 AAB6RQ== \"_lineOffset\" Float 1 AACAPw== \"_lineInMultiplier\" Float 1 AACAPw== \"_lineOutMultiplier\" Float 1 AACAPw== \"_overscan\" Float 2 AAAAAAAAAAA= 49 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"Vformat\" 2 1 \"zoom\" 1 1 \"_filtering\" 1 1 \"_alphaMultiplier\" 1 1 \"_pointRender\" 1 1 \"_wireRender\" 1 1 \"_facetRender\" 1 1 \"_maxPlexDistance\" 1 1 \"_maxPlexConnections\" 1 1 \"_maxPlexType\" 1 1 \"_plexLinedefXY\" 1 1 \"_plexLinedefX\" 1 1 \"_plexLinedefY\" 1 1 \"_plexLinedefXtoY\" 1 1 \"_plexLinedefAUX\" 1 1 \"_plexConnectX\" 1 1 \"_plexConnectY\" 1 1 \"_plex_gamma\" 1 1 \"_dof_enable\" 1 1 \"_dof_samples\" 1 1 \"_dof_rings\" 1 1 \"focalDepth\" 1 1 \"_depthOfField\" 1 1 \"_depthMult\" 1 1 \"_maxDofSize\" 1 1 \"dof_aspect\" 1 1 \"dof_threshold\" 1 1 \"dof_gain\" 1 1 \"dof_bias\" 1 1 \"dof_fringe\" 1 1 \"_flatshading\" 1 1 \"_backfacing\" 1 1 \"_frontfacing\" 1 1 \"_vertexMode\" 1 1 \"_depthBuffer\" 1 1 \"_texoffset\" 2 1 \"_pointSize\" 1 1 \"_gaussigma\" 1 1 \"_depthOcclusion\" 1 1 \"depthMultiplier\" 1 1 \"_maxLineSteps\" 1 1 \"_lineOffset\" 1 1 \"_lineInMultiplier\" 1 1 \"_lineOutMultiplier\" 1 1 \"_overscan\" 2 1 10 \"max_line_connections\" Int 1 1 AAAAAA== \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "//Some basic generic functions.\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float3 Cross(float3 A,float3 B)\n\{\n    return float3(A.y*B.z - A.z*B.y,A.z*B.x - A.x*B.z,A.x*B.y - A.y*B.x);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}     \n\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\ninline float mix(float _X,float _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}                                                                                              \n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n\n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight,\n    float2 overscan\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f-overscan.x || pRaster.x > imageWidth+overscan.x || \n       pRaster.y < 0.0f-overscan.y || pRaster.y > imageHeight+overscan.y || pRaster.z < 0.0f) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eRead, eAccessRandom, eEdgeClamped> src;     //The texture map\n  Image<eRead, eAccessRandom, eEdgeClamped> normals;     //The texture map  \n  Image<eRead, eAccessRandom, eEdgeClamped> occlusion;     //The texture map \n  Image<eWrite, eAccessRandom> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat,Vformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    int _filtering;        //Filter method\n    float _alphaMultiplier; //Additive multiplier\n    bool _pointRender,_wireRender,_facetRender;\n    float _maxPlexDistance; //Additive multiplier\n    int _maxPlexConnections;\n    int _maxPlexType; // 0==Grid, -1==Nearest\n    bool _plexLinedefXY,_plexLinedefX,_plexLinedefY,_plexLinedefXtoY,_plexLinedefAUX; // Define what connections NOT to include\n    bool _plexConnectX,_plexConnectY; //Connect from the edge of x to 0, or edge of y to 0, usually for spheres\n    float _plex_gamma; //The threshold making shorter paths bright and longer paths dark\n    bool _dof_enable; // Enable DOF\n    int _dof_samples; // How many samples per DOF ring\n    int _dof_rings; // How many rings \n    float focalDepth,_depthOfField,_depthMult,_maxDofSize; //DOF Settings\n    float dof_aspect; //Pixel aspect ratio\n    float dof_threshold;\n    float dof_gain;\n    float dof_bias; //bokeh edge bias\n    float dof_fringe; //bokeh chromatic aberration/fringing\n    bool _flatshading,_backfacing,_frontfacing; //Vertex rendering settings\n    int _vertexMode;  //The rendering output mode, (think AOV)\n    bool _depthBuffer; //Non-additive, only render front most pixel\n    float2 _texoffset;\n    int _pointSize;\n    float _gaussigma;\n    bool _depthOcclusion;\n    float depthMultiplier;\n    float _maxLineSteps; //cap the line length to avoid process lock\n    float _lineOffset; //Alow you to shrink or extend the lines\n    float _lineInMultiplier,_lineOutMultiplier; //Control the brightness of the wires at the tips.\n    float2 _overscan; //This will allow you to render some extra outside the bounds of the image.\n\n  local: //Local variables\n    int max_line_connections;\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(Vformat,      \"vertexformat\", int2(10,10));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(_filtering, \"Filtering Method\", 1); \n    defineParam(_alphaMultiplier, \"_alphaMultiplier\", 1.0f);     \n    defineParam(_pointRender, \"_pointRender\", true);  \n    defineParam(_wireRender, \"_wireRender\", true);\n    defineParam(_facetRender, \"_facetRender\", true);\n    defineParam(_maxPlexDistance, \"_maxLDistance\", 1.0f);    \n    defineParam(_maxPlexConnections, \"_maxLConnections\", 1);    \n    defineParam(_maxPlexType, \"_maxPlexType\", 0); \n    defineParam(_plexLinedefXY, \"_plexLinedefXY\", false);      \n    defineParam(_plexLinedefXtoY, \"_plexLinedefXtoY\", false); //NYI\n    defineParam(_plexLinedefAUX, \"_plexLinedefAUX\", false); \n    defineParam(_plexLinedefX, \"_plexLinedefX\", false);  \n    defineParam(_plexLinedefY, \"_plexLinedefY\", false);  \n    defineParam(_plexConnectX, \"_plexConnectX\", false);      \n    defineParam(_plexConnectY, \"_plexConnectY\", false);   \n    defineParam(_plex_gamma, \"_L_gamma\", 1.0f);\n    //DOF SETTINGS   \n    defineParam(_dof_enable, \"Enable Depth of Field\", false);   \n    defineParam(_dof_samples, \"samples\", 3);    \n    defineParam(_dof_rings, \"rings\", 5);   \n    defineParam(focalDepth, \"focalDepth\", 1.0f);  \n    defineParam(_depthOfField, \"_depthOfField\", 4.0f);  \n    defineParam(_depthMult, \"_depthMult\", 0.1f);  \n    defineParam(_maxDofSize, \"_maxDofSize\", 8.0f);  \n    defineParam(dof_aspect, \"dof_aspect\", 1.0f);  \n    defineParam(dof_threshold, \"dof_threshold\", 1.0f);  \n    defineParam(dof_gain, \"dof_gain\", 0.0f);  \n    defineParam(dof_bias, \"dof_bias\", -2.0f);  \n    defineParam(dof_fringe, \"dof_fringe\", 0.0f); \n    //SHADING SETTINGS \n    defineParam(_flatshading, \"_flatshading\", true);  \n    defineParam(_vertexMode, \"_vertexMode\", 0);  \n    defineParam(_backfacing, \"_backfacing\", true);    \n    defineParam(_frontfacing, \"_frontfacing\", true);        \n    defineParam(_depthBuffer, \"_depthBuffer\", true);  \n    defineParam(_texoffset, \"_texoffset\", float2(0.5f,0.5f)); \n    defineParam(_pointSize, \"_pointSize\", 1); \n    defineParam(_gaussigma, \"_gaussigma\", 1.0f); \n    defineParam(_depthOcclusion, \"_depthOcclusion\", true); \n    defineParam(depthMultiplier, \"depthMultiplier\", 1.0f); \n    defineParam(_maxLineSteps, \"_maxLineSteps\", 4000.0f); \n    defineParam(_lineOffset, \"_lineOffset\", 1.0f); \n    defineParam(_lineInMultiplier, \"_lineInMultiplier\", 1.0f);   \n    defineParam(_lineOutMultiplier, \"_lineOutMultiplier\", 1.0f);     \n    defineParam(_overscan, \"_overscan\",float2(0.0f,0.0f));    \n\n  \}\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    max_line_connections = 80;\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n  \}\n\n  //Convert a 3d point position into a 2d raster position.\n  float3 Reconsile3D(float3 _PointPos)\{\n      vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      return tRaster;\n  \}\n\n//------------------------------\n//-------DRAW FUNCTIONS---------\n//------------------------------\n  //Write pixels to output.\n  void writepixel(float posx,float posy, float4 color,int index,float weight=1.0f)\n  \{ \n      if (_depthOcclusion)\{\n        float4 depthSample = occlusion(posx,posy);\n        if (depthSample.x<=vRaster.z && depthSample.w>0.0f)\{\n\n          float depth = (vRaster.z-depthSample.x);\n          color = color*(1.0f-depthSample.w);\n          color = color / (((depth*depth)*depthMultiplier)+1.0f);\n          //return;\n        \}\n      \}\n      float4 finalOutput; //This is used to store the final output\n      float4 dstSample; //This is used to store a sample of the destination\n      if ( dst.bounds.inside( posx, posy ) ) \{ //Test if the pixel written to is inside the output image. \n        if (_depthBuffer) \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          if ((dstSample.w>color.w)||dstSample.w==0.0f) \{\n            dst(posx,posy) = color;\n          \}\n        \}\n        else \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          finalOutput = dstSample + (color*_alphaMultiplier*weight);\n          finalOutput.w = dstSample.w + ((color.w*_alphaMultiplier*weight));\n\n          finalOutput.w = (dstSample.w + ((color.w*_alphaMultiplier*weight)))-(dstSample.w * ((color.w*_alphaMultiplier*weight)));\n\n          dst(posx,posy) = finalOutput;\n        \}\n      \} \n  \}\n\n  //Calculate a Bilinear Plot\n  void bilinear_Plot(float2 temppos,float4 color,int index)\n  \{\n    float2 p;\n    p.x=Frac(temppos.x);\n    p.y=Frac(temppos.y);\n    float weights\[] = \{(1.0f-p.x)*(1.0f-p.y), p.x*(1.0f-p.y), (1.0f-p.x)*p.y, p.x*p.y\};\n    int2 _position = int2(floor(temppos.x)-0,floor(temppos.y)-0); \n    writepixel(_position.x,_position.y,color,index,weights\[0]);\n    writepixel(_position.x+1,_position.y,color,index,weights\[1]);\n    writepixel(_position.x,_position.y+1,color,index,weights\[2]);\n    writepixel(_position.x+1,_position.y+1,color,index,weights\[3]);\n  \}\n\n  //NYI, unused!\n  void gaussian(float2 temppos,float4 color,int index)\{\n    float in_x = temppos.x;\n    float in_y = temppos.y;\n    int kernelSize = (_pointSize+1)*2;\n    int subsize = (kernelSize /2)-1;\n    float gKernel\[64]\[64];\n    float sigma = _gaussigma;\n    float intSigma = float(_pointSize);\n    float r, s = intSigma * sigma * sigma;\n\n    float sum = 0.0f;\n\n    // generate 5x5 kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            r = float(sqrt(x*x + y*y));\n            gKernel\[x + subsize]\[y + subsize] = (exp(-(r*r)/s))/(3.141592654f * s);\n            sum += gKernel\[x + subsize]\[y + subsize];\n        \}\n    \}\n\n    // normalize the Kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            gKernel\[x + subsize]\[y + subsize] /= sum;\n            writepixel(in_x+x,in_y+y,color,index,gKernel\[x + subsize]\[y + subsize]);\n        \}\n    \}\n  \}\n\n//-------------------------------------\n// DrawLine\n// ----------\n// Draw a line between two points, \n// x,y being 2d screenspace pos and z being depth.\n//-------------------------------------\n  void DrawLine(float3 origin, float3 endpoint,float4 _colorA,float4 _colorB) \{\n    float4 _color;\n    float3 delta = origin-endpoint;\n    float3 curPoint = origin;\n    float mag = sqrt(delta.x*delta.x+delta.y*delta.y);\n    mag = min(mag,_maxLineSteps); //Lets not go crazy, we cap it at 10.000 to avoid insane unwated processing time \n    for( float a = 0; a < mag*_lineOffset; a = a + 1.0f )\{\n      curPoint -= (delta/mag);\n      _color = (_colorA*(1.0f-(a/mag*1.0f)))+(_colorB*(a/mag*1.00f));\n      if (_dof_enable)\{\n        Bokeh(curPoint,_color);\n      \}\n      else \{\n        bilinear_Plot(float2(curPoint.x,curPoint.y),_color,1);\n      \}\n      \n    \}\n  \}\n\n//-------------------------------------\n// Point_Render\n//-------------------------------------\nvoid point_render(int2 pos, float3 screen_pos)\{\n  float4 color = src(pos.x,pos.y);\n\n  if (_filtering == 1)\{\n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        if (_depthBuffer) \{color.w = screen_pos.z;\} //Added\n        bilinear_Plot(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  /*\n  //THIS PART NEEDS TO BE RE-WRITTEN.\n  else if (_filtering == 2)\{ \n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        gaussian(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  */\n  else \{\n      int2 _position = int2(floor(screen_pos.x),floor(screen_pos.y)); \n      if (_depthBuffer) \{color.w = screen_pos.z;\}\n      writepixel(_position.x,_position.y, color,1,1.0f); //OutputSample\n  \}\n\n\}\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nvoid facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x+1,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos,V0_N,V1_N,V2_N;\n    float2 V0_ST,V1_ST,V2_ST;\n    float4 V1_Sample,V2_Sample;\n    float4 _tn;\n    float3 normal0,normal1,normal2;\n    float2 UV_Format = float2(Vformat.x,Vformat.y);\n\n\n    int2 P0 = int2(pos.x-1,pos.y-1);\n    int2 P1 = int2(pos.x+1,pos.y+1);\n    if (_plexConnectX && pos.x == int(Vformat.x))\{\n      insideX == true;\n      P1 = int2(0.0f,pos.y+1);\n    \}\n    if (_plexConnectY && pos.y == int(Vformat.y))\{\n      insideYtop == true;\n      P1 = int2(pos.x+1,0);\n    \} \n\n    if (_plexConnectY && pos.y == 0)\{\n      insideY == true;\n      P0 = int2(pos.x-1,int(UV_Format.y));\n    \} \n\n    if (!_flatshading) \{\n      _tn = normals(pos.x,pos.y);\n      V0_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n    V0_ST = float2(pos.x,pos.y)/UV_Format;\n\n  if (insideX) \{\n    V2_Sample = ppos(P1.x,pos.y);\n    V2_ST = float2(P1.x,pos.y)/UV_Format;\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (!_flatshading) \{\n      _tn = normals(P1.x,pos.y);\n      V2_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n        \n\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(P1.x,P0.y);\n        V1_ST = float2(P1.x,P0.y)/UV_Format;\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(P1.x,P0.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}\n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V2_Pos,V1_Pos,_vWorld,V2_wPos,V1_wPos,V0_N,V2_N,V1_N,V0_ST,V2_ST,V1_ST);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,P1.y);\n        V1_ST = float2(pos.x,P1.y)/UV_Format;        \n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(pos.x,P1.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}        \n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V1_Pos,V2_Pos,_vWorld,V1_wPos,V2_wPos,V0_N,V1_N,V2_N,V0_ST,V1_ST,V2_ST);\n        \}\n      \}\n    \}\n  \}\n\}\n\n\n\n//This function will calculate if pixel C is inside the triangle\nfloat edgeFunction(float3 a, float3 b, float3 c) \n\{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n\} \n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat Distance(float3 _a,float3 _b)\n\{\n          float xd = _a.x - _b.x;\n          float yd = _a.y - _b.y;\n          float zd = _a.z - _b.z;\n          return sqrt(xd*xd + yd*yd + zd*zd);\n\}\n\nvoid DrawTriangle(float3 V0, float3 V1, float3 V2,float3 WP0, float3 WP1, float3 WP2,float3 N0, float3 N1, float3 N2, float2 st0,float2 st1,float2 st2) \{\n\n  // Precompute reciprocal of vertex z-coordinate \n  V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n\n  float2 st0n = st0 * V0.z;\n  float2 st1n = st1 * V1.z; \n  float2 st2n = st2 * V2.z; //Normal version of ST\n\n  bool inside; \n  float X0 = Fmin(V0.x,V1.x,V2.x)-1.0f;\n  float X1 = Fmax(V0.x,V1.x,V2.x)+1.0f;\n  float Y0 = Fmin(V0.y,V1.y,V2.y)-1.0f;\n  float Y1 = Fmax(V0.y,V1.y,V2.y)+1.0f;\n  float area = edgeFunction(V2, V1, V0);\n\n\n  float2 sampos = float2(st0.x*float(Vformat.x),st0.y*float(Vformat.y));\n  float4 text0 = src(sampos.x,sampos.y);\n  sampos = float2(st1.x*float(Vformat.x),st1.y*float(Vformat.y));\n  float4 text1 = src(sampos.x,sampos.y);\n  sampos = float2(st2.x*float(Vformat.x),st2.y*float(Vformat.y));  //Why do we have to do this? =(\n  float4 text2 = src(sampos.x,sampos.y);\n  sampos = float2(min(min(st0.x,st1.x),st2.x)*float(Vformat.x),min(min(st0.y,st1.y),st2.y)*float(Vformat.y));\n  float4 text3 = src(sampos.x,sampos.y);\n\n\n  for( int x = X0; x < X1 ; x++) \{\n    for( int y = Y0; y < Y1 ; y++) \{\n      float3 pixelSample(x + _texoffset.x, y + _texoffset.y,0.0f); \n\n      //This is the part where we test if the current pixel is inside the triangle\n      //We check both for front facing and back faing options\n      float w0 = edgeFunction(V1, V0, pixelSample); //Front Facing\n      float w1 = edgeFunction(V2, V1, pixelSample); \n      float w2 = edgeFunction(V0, V2, pixelSample); \n      float w3 = edgeFunction(V0, V1, pixelSample); //Back Facing\n      float w4 = edgeFunction(V1, V2, pixelSample); \n      float w5 = edgeFunction(V2, V0, pixelSample);\n\n      //writepixel(x,y, float4(w1),1,1.0f);\n      if ((w0 >= 0 && w1 >= 0 && w2 >= 0 && _frontfacing) || (w3 >= 0 && w4 >= 0 && w5 >= 0 && _backfacing)) \{ //The curent pixel is inside the triangle\n\n       // calculate vectors from point f to vertices p1, p2 and p3:\n       float3 f1 = V0-pixelSample;\n       float3 f2 = V1-pixelSample;\n       float3 f3 = V2-pixelSample;\n       // calculate the areas and factors (order of parameters doesn't matter):\n       float a = length(cross(V0-V1,V0-V2 )); // main triangle area a\n       area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n        w0 /= area; \n        w1 /= area; \n        w2 /= area; \n\n        w3 /= area; \n        w4 /= area; \n        w5 /= area; \n\n       float a1 = length(cross(f2, f3)) / a; // p1's triangle area / a\n       float a2 = length(cross(f3, f1)) / a; // p2's triangle area / a \n       float a3 = length(cross(f1, f2)) / a; // p3's triangle area / a\n       float a_magnitude = a1+a2+a3;\n       a1 = a1/a_magnitude;\n       a2 = a2/a_magnitude;\n       a3 = a3/a_magnitude;\n       float z = 1.0f / (V0.z * a1 + V1.z * a2 + V2.z * a3); \n\n\n        // find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):\n        float2 uv = st0 * a1 + st1 * a2 + st2 * a3;\n        float2 st = st0 * w0 + st1 * w1 + st2 * w2; \n        st *= z;      \n\n\n        //Calculate normals. Eighter we have flat shading, else we calculate a normal per pixel\n        float3 normalB;\n        if (_flatshading) \{\n          normalB = CalculateSurfaceNormals(WP0,WP1,WP2);\n\n        \}\n        else \{\n          float3 c0 = N2/float3(V0.z); \n          float3 c1 = N0/float3(V1.z); \n          float3 c2 = N1/float3(V2.z);  \n\n          normalB.x = w0 * c0.x + w1 * c1.x + w2 * c2.x; \n          normalB.y = w0 * c0.y + w1 * c1.y + w2 * c2.y; \n          normalB.z = w0 * c0.z + w1 * c1.z + w2 * c2.z; \n\n          normalB.x *= z, normalB.y *= z, normalB.z *= z; \n        \}\n        normalB = normalize(normalB);\n\n        //CALCULATE THE OBJECT TEXTURE COORDINATES\n        float zn = 1.0f / (V0.z * w0 + V1.z * w1 + V2.z * w2); \n        st = st0n * w0 + st1n * w1 + st2n * w2; \n        st *= zn;   \n        //--END \n\n        float3 Wpos = WP0*a1 + WP1*a2 + WP2*a3; //World Position.\n        float3 ViewNormal = normalize(float3(cameraToWorld\[3]\[0],cameraToWorld\[3]\[1],cameraToWorld\[3]\[2])-Wpos);\n\n        float nDotView =  dot(normalB,ViewNormal);\n        nDotView = 1.0f-fabs(nDotView); //make sure that the view normal ramps back around when doing backface\n        float4 tempout;\n\n        //Flatshading or regular?\n        if (!_flatshading) \{\n          tempout = text0 * a1 + text1 * a2 + text2 * a3; \n        \}\n        else\{\n          tempout = text3;\n        \}\n\n        //Additional Render Modes\n        if (_vertexMode == 1)\{\n          tempout = float4(a1,a2,a3,1.0f);\n        \}\n        else if (_vertexMode == 2)\{\n          tempout = float4(normalB.x,normalB.y,normalB.z,1.0f);\n        \}\n        else if (_vertexMode == 3)\{\n          tempout = float4(nDotView,nDotView,nDotView,1.0f);\n        \}\n        else if (_vertexMode == 4)\{\n          tempout = float4(uv.x,uv.y,0.0f,1.0f);\n        \}       \n        else if (_vertexMode == 5)\{\n          tempout = float4(st.x,st.y,0.0f,1.0f);\n        \}               \n        else if (_vertexMode == 6)\{\n          tempout = float4(ViewNormal.x,ViewNormal.y,ViewNormal.z,1.0f);\n        \}             \n        else if (_vertexMode == 7)\{\n          tempout = float4(Wpos.x,Wpos.y,Wpos.z,1.0f);\n        \}   \n\n        if (_depthBuffer)\{\n          writepixel(x,y, float4(tempout.x,tempout.y,tempout.z,z),1,1.0f);  \n        \}\n        else \{\n          if (_dof_enable)\{\n            Bokeh(float3(x,y,z),float4(tempout.x,tempout.y,tempout.z,z));\n          \}\n          else \{\n            bilinear_Plot(float2(x,y),float4(tempout.x,tempout.y,tempout.z,z),1);\n          \}\n        \}\n\n      \}  \n\n    \}\n  \}\n\}\n\n//-------------------------------------\n// Wire_Render\n//-------------------------------------\nvoid wire_render(int2 pos) \{\n  float4 temp = float4(0.0f,0.0f,0.0f,FLT_MAX);\n  float4 wire_ref_sample;\n  int2 tempXY = int2(0,0);\n  float4 plexlist\[11] = \{temp,temp,temp,temp,temp,temp,temp,temp,temp,temp,temp\}; \n  int2 plexlistXY\[11] = \{tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY\};\n  int plex_count = 0; //We use this to figure how many points that should connect.\n  float plex_dist;\n  float3 plex_position,plex_position_b;\n  float4 temp_pos, temp_pos_b; //Temporary Position Containers\n  if (_maxPlexType == -1) \{ //Used for random connection types\n    for( int x = 0; x < max_line_connections ; x++)\{ //THIS 80 NUMBER IS THE LIMIT TO AVOID TOO SLOW PROCESSING!\n      for( int y = 0; y < max_line_connections ; y++)\{\n        wire_ref_sample = ppos(x,y);\n        if (wire_ref_sample.w != 0.0f && pos.x!=x && pos.y != y) \{ \n          plex_position = float3(wire_ref_sample.x,wire_ref_sample.y,wire_ref_sample.z)*(zoom);\n          float xd = plex_position.x - vWorld.x;\n          float yd = plex_position.y - vWorld.y;\n          float zd = plex_position.z - vWorld.z;\n          float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n          if (plex_dist<_maxPlexDistance)\{\n            plex_count = min(10,plex_count+1); //Add one to the count\n            for( int h = 0; h < plex_count+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n              if (plex_dist < plexlist\[h].w) \{                  \n                for( int i = plex_count+1; i > h ; i--) \{\n                  plexlist\[i] = plexlist\[i-1];\n                  plexlistXY\[i] = plexlistXY\[i-1];\n                \}\n                plexlist\[h] = float4(plex_position.x,plex_position.y,plex_position.z,plex_dist);\n                plexlistXY\[h] = int2(x,y);\n                break;        \n              \}\n            \}\n          \} \n        \}\n      \}\n    \}\n  \}\n  else\{ //Used for standard connection types\n    float4 temp_pos;\n    bool insideX = !(Vformat.x < pos.x+1);\n    bool insideY = !(Vformat.y < pos.y+1);\n\n\n    if (!_plexLinedefAUX)\{\n      temp_pos = normals(pos.x,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,vWorld+plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideX && !_plexLinedefX) \{\n      temp_pos = ppos(pos.x+1,pos.y );\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && !_plexLinedefX) \{\n      temp_pos = ppos(0,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideY && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\}                          \n    \}\n    else if ( _plexConnectY  && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,0);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    //_plexConnect\n    if ( insideX && insideY && !_plexLinedefXY) \{              \n      temp_pos = ppos(pos.x+1,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && _plexConnectY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && insideY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectY && insideX && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n  \}   \n\n  //now that all the connections have been sorted by distance then we connect the dots.\n  for( int x = 0; x < min(_maxPlexConnections,plex_count) ; x++)\{\n    plex_position = float3(plexlist\[x].x,plexlist\[x].y,plexlist\[x].z);\n    plex_dist = plexlist\[x].w;\n\n\n    float plex_distribution = 1.0f-((plexlist\[x].w-plexlist\[0].w)/((plexlist\[min(_maxPlexConnections,plex_count)].w-plexlist\[0].w)+0.00001f)); //Where does it lie between the best and the worst distance?\n    //plexlistXY\n\n    float4 plex_col = float4(pow(1.0f-(plex_dist/_maxPlexDistance),1.0f/_plex_gamma))*float4(plex_distribution); //This one is quite cool aswell, but does leave the center ones a bit too focused \n    float4 plex_colorA = src(pos.x,pos.y);\n    float4 plex_colorB = src( plexlistXY\[x].x,plexlistXY\[x].y);\n    plex_col *= 0.1f;\n\n    computePixelCoordinates(plex_position, pRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n    if (dst.bounds.inside(int(vRaster.x),int(vRaster.y)) || dst.bounds.inside(int(pRaster.x),int(pRaster.y)))\{\n        DrawLine(vRaster,pRaster,(plex_colorA*plex_col)*_lineInMultiplier,(plex_colorB*plex_col)*_lineOutMultiplier);\n    \}\n  \}\n\}\n\nvoid wire_connection(float3 p_source,float3 p_target, float4 (&p_plexlist)\[11], int2 (&p_plexlistXY)\[11],int &p_plexcount,int2 position) \{\n  float xd = p_target.x - p_source.x;\n  float yd = p_target.y - p_source.y;\n  float zd = p_target.z - p_source.z;\n  float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n  if (plex_dist<_maxPlexDistance)\{\n    p_plexcount = min(11,p_plexcount+1); //Add one to the count\n    for( int h = 0; h < p_plexcount+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n      if (plex_dist < p_plexlist\[h].w) \{                  \n        for( int i = p_plexcount+1; i > h ; i--) \{\n          p_plexlist\[i] = p_plexlist\[i-1];\n          p_plexlistXY\[i] = p_plexlistXY\[i-1];\n        \}\n        p_plexlist\[h] = float4(p_target.x,p_target.y,p_target.z,plex_dist);\n        p_plexlistXY\[h] = int2(position.x,position.y);\n        break;        \n      \}\n    \}  \n  \}\n\}\n//-------END OF WIRE RENDER FUNCTIONS---------\n\n\n\n\n//-------------------------------\n//-------BOKEH FUNCTIONS---------\n//thanks to: http://devlog-martinsh.blogspot.dk/2011/11/glsl-depth-of-field-with-bokeh-v21.html\nfloat2 rand(float2 coord) //generating noise/pattern texture for dithering\n\{\n  float noiseX = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.25)+(Frac(coord.y*(WHformat\[1]/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.75)+(Frac(coord.y*(WHformat\[1]/2.0))*0.25))*2.0-1.0;\n  noiseX = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f))) * 43758.5453f),0.0f,1.0f)*2.0f-1.0f;\n  noiseY = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f)*2.0f)) * 43758.5453f),0.0f,1.0f)*2.0-1.0f;\n  return float2(noiseX,noiseY);\n\}\n//-------------------------------------\n// Bokeh\n//-------------------------------------\nvoid Bokeh(float3 pos,float4 color)\{\n  float blur = 0.0;\n  blur = clamp((fabs(pos.z - focalDepth)/_depthOfField)*100.0f,-_maxDofSize,_maxDofSize);\n  \n  float w = (1.0/WHformat.x)*blur;//+noise.x;\n  float h = (1.0/(WHformat.x*dof_aspect))*blur;//+noise.y;\n  float3 v3_col = float3(color.x,color.y,color.z);\n  int ringsamples;\n  float s = 1.0;  \n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples; \n    for (int j = 0 ; j < ringsamples ; j += 1)  \n    \{ \n      s += (1.0f*mix(1.0f,(float(i))/(float(_dof_rings)),dof_bias)*1.0f); //No need to do this in the loop\n    \}\n  \}\n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples;\n     \n    for (int j = 0 ; j < ringsamples ; j += 1)   \n    \{\n      float step = PI*2.0 / float(ringsamples);\n      float pw = (cos(float(j)*step)*(float(i)/_dof_rings));\n      float ph = (sin(float(j)*step)*(float(i)/_dof_rings));\n      float p = 1.0;\n\n      float posx = pos.x+((pw*w)*blur);\n      float posy = pos.y+((ph*h)*blur);\n\n\n      float3 lumcoeff = float3(0.299,0.587,0.114);\n      float lum = dot(v3_col, lumcoeff);\n      float thresh = max((lum-dof_threshold)*dof_gain, 0.0f);\n      v3_col+mix(float3(0.0),v3_col,thresh*blur);\n\n      float3 col = (v3_col*mix(1.0,(float(i))/(float(_dof_rings)),dof_bias)*p)/s; \n      bilinear_Plot(float2(posx,posy),float4(col.x,col.y,col.z,color.w/(_dof_rings*_dof_rings)),1);\n    \}\n  \}\n\}\n//-------END OF BOKEH FUNCTIONS---------\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float2 posf = float2(pos.x,pos.y);\n\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n\n      //Convert worldspace coordinates to screenspcace coordinates.\n      vWorld = float3(_sample.x,_sample.y,_sample.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, vRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1],_overscan);\n      if (ret) \{ //Only create points that are visible on screen\n        if (_pointRender)\{\n          point_render(pos,vRaster);\n        \}\n      \} //Pointrender over\n\n      if (_wireRender && _maxPlexConnections>=1) \{\n        if (max(pos.x,pos.y)<=max_line_connections || (_maxPlexType==0))\{ // Don't process more wires than allowed in nearest mode.\n          wire_render(pos);\n        \}\n      \} //WireRender over\n\n      if (_facetRender) \{\n        facet_render(pos,float3(_sample.x,_sample.y,_sample.z));\n      \}  //FacetRender over\n      \n    \}\n  \} //----> process\n\};\n"
  useGPUIfAvailable false
  rebuild ""
  PointRender3D_cam_Matrix {
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
    }
  PointRender3D_focallength {{parent.Camera1.focal}}
  PointRender3D_hapeture {{parent.Camera1.haperture}}
  PointRender3D_format {{!proxy?Settings_Format.width:Settings_Format.width*proxy_scale} {!proxy?Settings_Format.height:Settings_Format.height*proxy_scale}}
  PointRender3D_vertexformat {{parent.InputFormat.box.r-1} {parent.InputFormat.box.t-1}}
  PointRender3D__alphaMultiplier {{parent.AlphaMultiplier}}
  PointRender3D__pointRender {{parent.RenderMode==0}}
  PointRender3D__wireRender {{parent.RenderMode==1}}
  PointRender3D__facetRender {{parent.RenderMode==2}}
  PointRender3D__maxLDistance {{parent.wire_maxdistance}}
  PointRender3D__maxLConnections {{parent.wire_connections}}
  PointRender3D__maxPlexType {{-parent.wire_type}}
  PointRender3D__plexLinedefXY {{!parent.connect_xy}}
  PointRender3D__plexLinedefX {{!parent.connect_x}}
  PointRender3D__plexLinedefY {{!parent.connect_y}}
  PointRender3D__plexLinedefAUX {{!connect_aux}}
  PointRender3D__plexConnectX {{parent.CloseX}}
  PointRender3D__plexConnectY {{parent.CloseY}}
  PointRender3D__L_gamma {{parent.wire_Threshold}}
  "PointRender3D_Enable Depth of Field" {{parent.dof_enable}}
  PointRender3D_samples {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_rings {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_focalDepth {{parent.dof_focaldepth}}
  PointRender3D__depthOfField {{parent.dof_dof}}
  PointRender3D__depthMult 0
  PointRender3D__maxDofSize {{parent.dof_maxSize*400}}
  PointRender3D_dof_aspect {{parent.dof_Aspect}}
  PointRender3D_dof_bias {{parent.dof_bias}}
  PointRender3D__flatshading {{parent.facet_flatShading}}
  PointRender3D__backfacing {{parent.facet_backface}}
  PointRender3D__frontfacing {{parent.facet_front}}
  PointRender3D__vertexMode {{parent.renderMode}}
  PointRender3D__depthBuffer {{parent.facet_depth}}
  PointRender3D__texoffset {-0.5 0.5}
  PointRender3D__pointSize 0
  PointRender3D__depthOcclusion {{parent.UseOcclusionMap}}
  PointRender3D__maxLineSteps {{parent.maxSamples}}
  PointRender3D__lineOffset {{parent.lineoffset}}
  PointRender3D__lineInMultiplier {{parent.inGain}}
  PointRender3D__lineOutMultiplier {{parent.outGain}}
  PointRender3D__overscan {{parent.overscan} {parent.overscan}}
  format "1280 720 0 0 1280 720 1 HD_720"
  rebuild_finalise ""
  name BlinkScript1
  xpos -27
  ypos 159
 }
set N1dfdba50 [stack 0]
 TimeBlur {
  divisions {{parent.Samples}}
  shutter {{parent.Shutter}}
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur
  xpos -27
  ypos 301
  disable {{1-parent.mb_enable x89 0}}
 }
 ShuffleCopy {
  inputs 2
  alpha alpha2
  black alpha
  out2 depth
  name ShuffleCopy2
  xpos -27
  ypos 411
  disable {{!parent.OutputZdepth}}
 }
 CopyBBox {
  inputs 2
  name CopyBBox1
  xpos -27
  ypos 521
 }
 Reformat {
  format {{{Settings_Format.format}}}
  resize none
  center false
  pbb {{max(parent.overscan.w,parent.overscan.h)!=0}}
  name Reformat1
  xpos -27
  ypos 545
 }
 Group {
  name SoftLook
  xpos -27
  ypos 647
  disable {{!parent.HighlightCompression}}
  addUserKnob {20 User}
  addUserKnob {26 ""}
  addUserKnob {7 Add R 0 4}
  Add {{parent.HighlightCeiling}}
  addUserKnob {7 Offset R 0 4}
  Offset {{parent.Compression}}
 }
  Input {
   inputs 0
   name Input1
   xpos -248
   ypos 500
  }
set N1e077910 [stack 0]
  Expression {
   expr0 r/(r+parent.Offset)*parent.Add
   expr1 g/(g+parent.Offset)*parent.Add
   expr2 b/(b+parent.Offset)*parent.Add
   expr3 a/(a+parent.Offset)*parent.Add
   name Expression1
   xpos -339
   ypos 576
  }
push $N1e077910
  ShuffleCopy {
   inputs 2
   red red
   green green
   blue blue
   alpha alpha2
   name ShuffleCopy1
   xpos -248
   ypos 576
  }
  Output {
   name Output1
   xpos -248
   ypos 651
  }
 end_group
 ShuffleCopy {
  inputs 2
  in pos
  red red
  green green
  blue blue
  out pos
  name ShuffleCopy1
  xpos -27
  ypos 860
  disable true
 }
 Output {
  name Output1
  xpos -27
  ypos 897
 }
push $N1df23580
 PositionToPoints2 {
  display textured
  render_mode textured
  P_channel pos
  detail 0.25
  pointSize 0.6
  name PreviewNode
  xpos -22
  ypos 8
  disable {{!parent.Enable3DPreview}}
 }
push $N1dd59180
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize none
  filter Impulse
  black_outside true
  name Reformat3
  xpos -633
  ypos -1109
  disable {{!wire_type==1}}
 }
push $N1dd9d7c0
push $N1ddbd630
push $N1ddc2190
 Merge2 {
  inputs 2
  operation min
  Achannels {-pos.red -pos.green -pos.blue pos.alpha}
  Bchannels {-pos.red -pos.green -pos.blue pos.alpha}
  output {-pos.red -pos.green -pos.blue pos.alpha}
  name Merge4
  xpos -582
  ypos -634
 }
 Merge2 {
  inputs 2
  operation min
  Achannels {-pos.red -pos.green -pos.blue pos.alpha}
  Bchannels {-pos.red -pos.green -pos.blue pos.alpha}
  output {-pos.red -pos.green -pos.blue pos.alpha}
  name Merge5
  xpos -582
  ypos -602
 }
push $N1ddd5540
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -456
  ypos -402
 }
push $N1dfdba50
 Viewer {
  frame 36
  frame_range 1-100
  name Viewer1
  xpos -27
  ypos 325
 }
 Input {
  inputs 0
  name InputCamera
  xpos -1271
  ypos 89
  number 1
 }
 Camera {
  useMatrix true
  matrix {
      {1 0 0 0}
      {0 {1/Settings_Format.actual_format.pixel_aspect} 0 0}
      {0 0 1 0}
      {0 0 0 1}
    }
  projection_mode {{"\[value the_cam]projection_mode"}}
  focal {{"\[value \[value the_cam]focal]"}}
  haperture {{"\[value \[value the_cam]haperture]"}}
  vaperture {{"\[value \[value the_cam]vaperture]"}}
  near {{"\[value \[value the_cam]near]"}}
  far {{"\[value \[value the_cam]far]"}}
  win_translate {{"\[lindex \[value \[value the_cam]win_translate] 0]"} {"\[lindex \[value \[value the_cam]win_translate] 1]"}}
  win_scale {{"\[lindex \[value \[value the_cam]win_scale] 0]"} {"\[lindex \[value \[value the_cam]win_scale] 1]"}}
  winroll {{"\[value \[value the_cam]winroll]"}}
  focal_point {{"\[value \[value the_cam]focal_point]"}}
  fstop {{"\[value \[value the_cam]fstop]"}}
  name Camera1
  help "DummyCam by Adrian Pueyo\n\nCamera that apart from the matrices also grabs all the \"Projection\" values from the upstream camera that it's connected to. Turns into a default Camera if not Camera connected.\n\nCan also be used inside of groups and gizmos, as many levels deep as you want :D\n\nAll using live and super fast TCL.\n\nadrianpueyo.com, 2019"
  onCreate "n = nuke.thisNode()\nfor k in \[\"projection_mode\",\"focal\",\"haperture\",\"vaperture\",\"near\",\"far\",\"win_translate\",\"win_scale\",\"winroll\",\"focal_point\",\"fstop\"]:\n    n\[k].setFlag(0x0000000010000000)"
  label "(thanks to Adrian Pueyo and Ernest Dios)"
  xpos -1261
  ypos 198
  addUserKnob {20 DummyCam l Defaults}
  addUserKnob {43 the_cam +INVISIBLE}
  the_cam "\[\nset the_knob \"focal\"\nset knob_index 0\nset starting_point \"this.input0\"\nset default \"this\"\nset default \[append default \".d_\"]\n\n# If cam has no inputs, return the default...\nif \{\[exists \$starting_point]\} \{\n    set x \[node \$starting_point]\n\} \{ \n    return \$default\n\}\n\nset finished 0\nwhile \{\$finished != 1\} \{\n\n    # First look for a Cam or Input or topnode.\n    while \{\[class \$x] != \"Camera2\" && \[class \$x] != \"Camera\" && \[class \$x] != \"Input\" && \$x != \[topnode \$x]\} \{\n        set x \[node \$x.input0]\n    \}\n\n    # Then, check if node is a cam (and return), and otherwise, if it's an input, see if the parent exists and move to it.\n    if \{\[class \$x]==\"Camera2\"||\[class \$x]==\"Camera\"\} \{\n        set x \[append x \".\"]\n        return \$x\n    \} \{ \n        if \{\[class \$x]==\"Input\"\} \{ \n            set inp \"\$x.parent.input\"\n            set inputNum \[value \$x.number]\n            set inp \[append inp \$inputNum]\n            if \{\[exists \$inp]\} \{\n                set x \[node \$inp]\n            \} \{ \n                set finished 1\n            \}\n        \} \{ \n            set finished 1\n        \}\n    \}\n\}\nreturn \$default\n]"
  addUserKnob {4 d_projection_mode l projection M {perspective orthographic uv spherical ""}}
  addUserKnob {7 d_focal l focal R 0 100}
  d_focal 50
  addUserKnob {7 d_haperture l "horiz aperture" R 0 50}
  d_haperture 24.576
  addUserKnob {7 d_vaperture l "vert aperture" R 0 50}
  d_vaperture 18.672
  addUserKnob {7 d_near l near R 0 10}
  d_near 0.1
  addUserKnob {7 d_far l far R 0 10000}
  d_far 10000
  addUserKnob {12 d_win_translate l "window translate"}
  addUserKnob {12 d_win_scale l "window scale"}
  d_win_scale {1 1}
  addUserKnob {7 d_winroll l "window roll" R 0 45}
  addUserKnob {7 d_focal_point l "focal distance" R 0 10}
  d_focal_point 2
  addUserKnob {7 d_fstop l fstop R 0 30}
  d_fstop 16
  addUserKnob {26 text l " " T "<span style=\"color:#666\"><br/><b>DummyCam v1.0</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2019</span>"}
 }
end_group
FrameRange {
 first_frame 1000
 last_frame 2000
 time ""
 name FrameRange11
 xpos 2217
 ypos 2081
}
Retime {
 input.first 1000
 input.first_lock true
 input.last 4000
 input.last_lock true
 output.first 1000
 output.first_lock true
 output.last 1020
 output.last_lock true
 speed 142.9047619
 before continue
 after continue
 filter none
 time ""
 name Retime2
 xpos 2217
 ypos 2151
}
FrameRange {
 first_frame 1016
 last_frame 1020
 time ""
 name FrameRange13
 xpos 2217
 ypos 2175
}
Write {
 channels rgba
 name Write1
 xpos 2217
 ypos 2240
 addUserKnob {20 caravr l CaraVR}
 addUserKnob {4 viewPresets l "View Presets" M {main stereo cams "stereo cams" all}}
 addUserKnob {22 set l Set -STARTLINE T "w = nuke.thisNode()\nscriptViews = nuke.views()\nviewPreset = w\['viewPresets'].getValue()\nselectedViews = None\nif viewPreset == 0:\n  selectedViews = \['main']\nif viewPreset == 1:\n  stereoViews = \['left', 'right']\n  if set(stereoViews).issubset(set(scriptViews)):\n    selectedViews = stereoViews\n  else:\n    selectedViews = None\nelif viewPreset == 2:\n  selectedViews = \[v for v in scriptViews if 'cam' in v and not ('_left' in v or '_right' in v)]\nelif viewPreset == 3:\n  selectedViews = \[v for v in scriptViews if 'cam' in v and ('_left' in v or '_right' in v)]\nelif viewPreset == 4:\n  selectedViews = scriptViews\nif selectedViews:\n  w\['views'].fromScript(' '.join(selectedViews))\n"}
}
Text {
 inputs 0
 message /jobs/TRAINVFX/REF/montreal/general_reference/data/2021/Elements/
 font /usr/share/fonts/msttcore/trebuc.ttf
 size 80
 xjustify right
 yjustify bottom
 box {76.8 43.2 1843.2 1036.8}
 center {960 540}
 name Text1
 xpos 2457
 ypos 2278
 addUserKnob {20 dneg l DNeg}
 addUserKnob {26 _version l "" +STARTLINE +INVISIBLE T 1.0}
 addUserKnob {7 padding l "padding %" R 0 20}
 padding 4
 addUserKnob {15 orig_box +HIDDEN}
 orig_box {0 0 1920 1080}
}
push $N1be39180
push 0
push 0
push 0
push 0
push 0
push 0
push 0
Read {
 inputs 0
 file_type exr
 file /jobs/TRAINVFX/REF/montreal/general_reference/data/2021/Elements/point_cloud_shapes/point_cloud_shapes_v01.####.exr
 localizationPolicy off
 format "1920 1080 0 0 1920 1080 1 Canon 5D mkIII HD"
 proxy_format "640 480 0 0 640 480 1 "
 first 1015
 last 1025
 origfirst 1015
 origlast 1025
 origset true
 version 1
 smartGrade true
 name Read1
 xpos 2212
 ypos 2264
 postage_stamp_frame 1020
 addUserKnob {20 Ivy}
 addUserKnob {22 ivy_documentation l "Ivy Documentation" t "Open IvyTab documentation page in your web browser" T "__import__('dnnuke.utils.asst.common', fromlist=\['openDocsName']).openDocsName('IvyTab')" +STARTLINE}
 addUserKnob {26 divider4 l "" +STARTLINE}
 addUserKnob {1 _ivyVals l "" +STARTLINE +HIDDEN}
 _ivyVals "\{'ivy_job': '', 'ivy_usemanualuri': False, 'leafname': '', 'ivy_vnum': 0, 'ivy_twignametags': \{\}, 'ivy_shot': '', 'ivy_regex': False, 'ivy_type': '', 'ivy_versionquery': '', 'spider_uri': ''\}"
 addUserKnob {52 ivyTab l "" -STARTLINE T "__import__('nukescripts').panels.WidgetKnob(__import__('dnnuke.core.ivy.tab.widget.query', fromlist=\['getBoundKnob']).getBoundKnob(nuke.thisNode()))"}
 addUserKnob {1 _ivyFile l "" +STARTLINE +HIDDEN +INVISIBLE}
 _ivyFile "no results were found for query (Leaf) (WHERE Leaf.job = 'TRAINVFX' AND Leaf.location = '/jobs/TRAINVFX/REF/montreal/general_reference/data/2021/Elements/point_cloud_shapes/point_cloud_shapes_v01.#.exr' AND Leaf.deleted = '0000-00-00 00:00:00' AND Leaf.archived = '0000-00-00 00:00:00' AND Leaf.provisional = '0')"
 addUserKnob {78 _expressions l "" -STARTLINE +HIDDEN +INVISIBLE n 1}
 _expressions {{curve}}
 addUserKnob {26 divider0 l "" +STARTLINE}
 addUserKnob {20 dbinfo l "DB Info" n 1}
 dbinfo 0
 addUserKnob {1 twig_dnuuid l "Twig Id"}
 addUserKnob {1 stalk_dnuuid l "Stalk Id"}
 addUserKnob {1 twigtype_dnuuid l "Twig Type Id"}
 addUserKnob {1 leaf_dnuuid l "Leaf Id"}
 addUserKnob {26 divider1 l "" +STARTLINE}
 addUserKnob {1 twigtype l "Twig Type"}
 addUserKnob {1 leaf_label l Leaf}
 addUserKnob {1 ivy_version l Version}
 addUserKnob {43 ivy_notes l Notes}
 addUserKnob {26 divider2 l "" +STARTLINE}
 addUserKnob {1 build_label l "Build Label"}
 addUserKnob {20 dbinfoEndGroup l "DB Info" n -1}
}
push 0
Viewer {
 inputs 10
 frame_range 1003-1021
 frame_increment 50
 input_number 1
 overscan 300
 center_fstop 0
 colour_sample_bbox {0.7937499881 -0.2927083373 0.7947916389 -0.2916666567}
 samplepoints {{0.7937499881 -0.2927083373}
   }
 viewerProcess Film
 far 100000
 name Viewer1
 xpos 4214
 ypos 3295
}
